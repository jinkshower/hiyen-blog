{"componentChunkName":"component---src-templates-post-jsx","path":"/builder_pattern/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"b9b7d25c-152b-564e-804d-45dc8b79e7aa","excerpt":"개인 과제에서 을 적용해 코드를 개선한 기록 Builder Pattern? Effective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다.  Builder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객…","html":"<p>개인 과제에서 <code class=\"language-text\">Builder Pattern</code>을 적용해 코드를 개선한 기록</p>\n<hr>\n<h2>Builder Pattern?</h2>\n<p>Effective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다. </p>\n<p>Builder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객체를 생성하는 기법이다. </p>\n<h2>Menu</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Menu {    \n    private final String name;  \n    private final String description;  \n    private final double price;  \n    private final List&lt;Option> options;\n}</code></pre></div>\n<p>와 같은 네 개의 멤버 변수를 가진 Menu 클래스를 만드려 한다.\n<code class=\"language-text\">name</code>과 <code class=\"language-text\">price</code>는 필수적으로 포함되어야 하지만 <code class=\"language-text\">description</code>과 <code class=\"language-text\">options</code>는 메뉴에 따라 있을 수도, 없을 수도 있는 선택 매개변수이다.</p>\n<h2>첫 번째 시도, public 생성자</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public Menu(String name, String description, double price, List&lt;Option> options) {\n\tthis.name = name;\n\tthis.description = description;\n\tthis.price = price;\n\tthis.options = options\n}</code></pre></div>\n<p>가장 기본적인 public 생성자이다.\n얼핏 보면 아무 문제도 없어보이지만 <code class=\"language-text\">Menu</code>를 인스턴스화하며 코드에서 사용하려 해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">new Menu(\"Shack Burger\", \"너무 맛있는 쉑버거\", 6.5, List.of(new   Option(\"Regular\", 0),  \n        new Option(\"Large\", 0.9))</code></pre></div>\n<p>이 코드는</p>\n<ol>\n<li>같은 String타입의 <code class=\"language-text\">name</code>과 <code class=\"language-text\">descripton</code>이 정확한 순서로 쓰여져야 하고</li>\n<li><code class=\"language-text\">description</code>, <code class=\"language-text\">options</code>가 필요없는 경우를 대처할 수 없기 때문에</li>\n</ol>\n<p>Menu를 인스턴스화 할때마다 Menu의 생성자를 매번 확인해야 한다.  </p>\n<h2>두번째 시도 Telescoping Constructor (점층적 생성자)</h2>\n<p>위의 코드를 조금 개선해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public Menu(String name, String description, double price, List&lt;Option> options) {  \n    this.name = name;  \n    this.description = description;  \n    this.price = price;  \n    this.options = new ArrayList&lt;>(options);  \n}  \n  \npublic Menu(String name, double price) {  \n    this(name, \"\", price, new ArrayList&lt;>());  \n}  \n  \npublic Menu(String name, String description, double price) {  \n    this(name, description, price, new ArrayList&lt;>());  \n}\n\npublic Menu(String name, double price, List&lt;Options> options) {\n\tthis(name, \"\", price, options);\n}</code></pre></div>\n<p>점층적 생성자를 이용해 <code class=\"language-text\">description</code>, <code class=\"language-text\">options</code>모두 없는 경우, 하나만 없는 경우의 조합을 상정하고 순서대로 <code class=\"language-text\">this()</code>를 호출하며 생성시 주어지지 않은 파라미터는 default 값을 이용하도록 해보았다.</p>\n<p>점층적 생성자를 이용해 이제 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">new Menu(\"Burger\", 1000)</code></pre></div>\n<p>위와 같은 Menu의 생성도 가능해지게 되었다.</p>\n<p>하지만 점층적 생성자 또한</p>\n<ol>\n<li>순서를 기억하기 어렵고, </li>\n<li>Menu가 더 많은 파라미터를 요구하게 될 시의 조합을 가진 생성자를 더 생성해야 하기 때문에</li>\n</ol>\n<p>유지보수가 어렵다는 문제가 여전히 남아 있다. </p>\n<h2>세번째 시도, Builder Pattern</h2>\n<p>이러한 Menu 클래스를 Builder Pattern을 이용하여 리팩토링 해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static class Builder {  \n  \n    private final String name;  \n    private final double price;  \n  \n    private String description = \"\";  \n    private List&lt;Option> options = new ArrayList&lt;>();  \n  \n    public Builder(String name, double price) {  \n        this.name = name;  \n        this.price = price;  \n    }  \n  \n    public Builder description(String description) {  \n        this.description = description;  \n        return this;    }  \n  \n    public Builder options(List&lt;Option> options) {  \n        this.options = new ArrayList&lt;>(options);  \n        return this;    }  \n  \n    public Menu build() {  \n        return new Menu(this);  \n    }  \n}\n\nprivate Menu(Builder builder) {  \n    this.name = builder.name;  \n    this.description = builder.description;  \n    this.price = builder.price;  \n    this.options = builder.options;  \n}</code></pre></div>\n<p>Menu 클래스 생성자의 접근제어자를 <code class=\"language-text\">private</code>으로 두고 내부 클래스로 Builder를 만들었다.  <code class=\"language-text\">private</code>생성자는 <code class=\"language-text\">Builder</code>가 가져다준 매개변수를 저장한다. </p>\n<p>Builder는 기본적으로 필수적인 매개변수인 <code class=\"language-text\">name</code>과 <code class=\"language-text\">price</code>를 생성자의 파라미터로 받고 선택적인 매개변수인 <code class=\"language-text\">description</code> 과 <code class=\"language-text\">options</code>를 초기화를 해주었다.</p>\n<p>필수 매개변수만 받고 나머지는 메서드 체이닝을 통해 setter와 같은 역할을 하며 마지막으로 <code class=\"language-text\">build()</code>메서드로만 Menu를 인스턴스화 할 수 있게 했다. </p>\n<p>이를 통해 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">new Menu.Builder(\"Shack Burger\", 6.5)  \n        .description(\"너무 맛있는 쉑버거\")  \n        .options(List.of(new Option(\"Single\", 0),  \n                new Option(\"Double\", 3.6)))  \n        .build()</code></pre></div>\n<p>Menu를 위와 같이 인스턴스화 할 수 있게 되었다. </p>\n<p>그리하여</p>\n<ol>\n<li>생성자에 대한 컨트롤<br>\n정해진 방식으로만 객체가 생성될 수 있게 했고 </li>\n<li>가독성<br>\n생성자 파라미터에 메서드 명을 붙임으로써 객체 생성시의 실수가 줄어든다.\n같은 타입의 멤버 변수를 파라미터로 받아 들일 시 순서가 헷갈리거나 잘못된 값을 저장할 수 있는 문제도 메서드 명을 지정해야 하므로 방지 할 수 있다.  </li>\n<li>확장성<br>\n메서드를 추가하면 되기 때문에 4개 그 이상의 파라미터 확장 혹은 파라미터에 대한 검증 추가에 더 유연하게 대처할 수 있다 </li>\n</ol>\n<h2>내가 느낀 Builder Pattern의 단점</h2>\n<p>빌더 패턴을 사용하며 느낀 단점은</p>\n<ol>\n<li>바로바로 생성할 수 있는 public 생성자와 달리 코드를 작성하는데 비용이 든다.</li>\n<li>매개변수가 적은 경우 오히려 객체가 무거워진다 </li>\n</ol>\n<p>정도다. 하지만 테스트 코드 작성같이 다른 객체에서 Menu를 인스턴스화 할때 객체 생성에 실수가 줄어들고 이미 생성하고 있는 Menu 코드에 새로운 option을 추가한다거나 설명을 바꿀 때 편리함을 느껴서 매개변수가 많을 때는 Builder Pattern을 많이 사용할 것 같다.</p>","frontmatter":{"title":"Builder Pattern으로 코드 개선하기","date":"January 09, 2024","update":"January 09, 2024","tags":["builder_pattern","java"],"series":"java"},"fields":{"slug":"/builder_pattern/","readingTime":{"minutes":6.575}}},"seriesList":{"edges":[{"node":{"id":"3bf07a5c-66d5-5e07-9411-b18a10843f1c","fields":{"slug":"/staticfactorymethod/"},"frontmatter":{"title":"정적 팩토리 메서드, 언제 쓸까?"}}},{"node":{"id":"b9b7d25c-152b-564e-804d-45dc8b79e7aa","fields":{"slug":"/builder_pattern/"},"frontmatter":{"title":"Builder Pattern으로 코드 개선하기"}}},{"node":{"id":"fdf4dd31-0e89-586d-afc5-f7e7df28cbff","fields":{"slug":"/dependency_injection/"},"frontmatter":{"title":"의존성 주입(Dependency Injection)"}}},{"node":{"id":"aec3253b-e519-59a6-8d33-cb0126ae61b6","fields":{"slug":"/garbage_collection/"},"frontmatter":{"title":"GC와 자바의 변화과정"}}}]},"previous":{"fields":{"slug":"/http_cache/"},"frontmatter":{"title":"웹 서비스 캐시"}},"next":{"fields":{"slug":"/dependency_injection/"},"frontmatter":{"title":"의존성 주입(Dependency Injection)"}}},"pageContext":{"id":"b9b7d25c-152b-564e-804d-45dc8b79e7aa","series":"java","previousPostId":"210930ca-9014-5a1f-a94a-d8a8ea32b853","nextPostId":"fdf4dd31-0e89-586d-afc5-f7e7df28cbff"}},"staticQueryHashes":[],"slicesMap":{}}