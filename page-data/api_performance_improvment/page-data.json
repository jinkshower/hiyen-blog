{"componentChunkName":"component---src-templates-post-jsx","path":"/api_performance_improvment/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"8ff84894-52cd-5648-be4d-4ae81514bfbb","excerpt":"학습계기 프로젝트를 진행하며 api마다 부하테스트로 성능을 측정하고 있었습니다. 이 중 가장 조회가 많을 것이라 예상되는 좌석 조회 api가 너무나 성능이 떨어지는 충격적인 결과를 보게 되었는데요.. (2분동안 100명이 10초 간격으로 조회요청시)\nPasted image 20240417170414\n오류율 25%, tps 2.9, 평균 응답시간 3만대의 …","html":"<h2>학습계기</h2>\n<p>프로젝트를 진행하며 api마다 부하테스트로 성능을 측정하고 있었습니다. 이 중 가장 조회가 많을 것이라 예상되는 좌석 조회 api가 너무나 성능이 떨어지는 충격적인 결과를 보게 되었는데요..</p>\n<p>(2분동안 100명이 10초 간격으로 조회요청시)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/69471f59-4e86-4ea5-9345-926f8232f240\" alt=\"Pasted image 20240417170414\">\n오류율 25%, tps 2.9, 평균 응답시간 3만대의 처참한 결과를 받게 되었습니다.</p>\n<p>이번 기록은 해당 api를 차근차근 개선하면서 배운 점과 성능 기록을 다루려고 합니다.</p>\n<h2>원인 찾기</h2>\n<p>좌석 조회 api가 이렇게 느린 이유를 찾는 것이 우선이라고 생각했습니다.\n해당 메서드를 따라가면서 for문이 돌고 있는 건 아닌지, 불필요한 객체 생성을 하는지 점검 하고 이내 쿼리를 찾게 되었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span>  \n\ts1_0<span class=\"token punctuation\">.</span>horizontal<span class=\"token punctuation\">,</span>  \n\ts1_0<span class=\"token punctuation\">.</span>vertical  \n<span class=\"token keyword\">from</span>  \n\tseats s1_0  \n<span class=\"token keyword\">where</span>  \n\ts1_0<span class=\"token punctuation\">.</span>concert_id<span class=\"token operator\">=</span>?  \n  <span class=\"token operator\">and</span> s1_0<span class=\"token punctuation\">.</span>reserved<span class=\"token operator\">=</span>?<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">select</span>\n\ts1_0<span class=\"token punctuation\">.</span>horizontal<span class=\"token punctuation\">,</span>\n\ts1_0<span class=\"token punctuation\">.</span>vertical\n<span class=\"token keyword\">from</span>\n\tseats s1_0\n<span class=\"token keyword\">where</span>\n\ts1_0<span class=\"token punctuation\">.</span>concert_id<span class=\"token operator\">=</span>?\n <span class=\"token operator\">and</span> s1_0<span class=\"token punctuation\">.</span>availability<span class=\"token operator\">=</span>?<span class=\"token punctuation\">;</span></code></pre></div>\n<p>예약이 된 좌석의 행열, 사용불가능한 좌석의 행열을 찾는 2번의 쿼리를 실행중이었는데요, 해당 쿼리의 실행계획을 확인했습니다.</p>\n<p>(seats 테이블에 데이터가 10만개 있을 때)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/0f790ca2-1d64-4169-b0fd-ba409e438588\" alt=\"Pasted image 20240417121808\">\n테이블 풀 스캔을 한 것을 확인할 수 있습니다.</p>\n<p>즉, 10만개의 데이터를 풀스캔하는 쿼리 2개가 처참한 성능의 원인임을 확인했습니다.</p>\n<h2>1차 개선 - 쿼리개선</h2>\n<p>가장 먼저 두개의 쿼리를 하나로 합치는 작업부터 진행했습니다.</p>\n<p>구현할때는 생각도 못했는데 왜 리팩토링 할때는 이렇게 문제점이 잘보일까요? 당연히 or을 사용하면 1개의 쿼리로 해결 할 수 있는 문제였습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span>  \n    s1_0<span class=\"token punctuation\">.</span>horizontal<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>vertical<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>locked<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>reserved  \n<span class=\"token keyword\">from</span>  \n    seats s1_0  \n<span class=\"token keyword\">where</span>  \n    s1_0<span class=\"token punctuation\">.</span>concert_id<span class=\"token operator\">=</span>?  \n  <span class=\"token operator\">and</span> <span class=\"token punctuation\">(</span>  \n    s1_0<span class=\"token punctuation\">.</span>reserved<span class=\"token operator\">=</span>?  \n        <span class=\"token operator\">or</span> s1_0<span class=\"token punctuation\">.</span>availability<span class=\"token operator\">=</span>?  \n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>(1차 개선 후 측정결과)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/0226aaaa-89ea-4e81-aec3-0b9f1654755c\" alt=\"Pasted image 20240417203050\"></p>\n<p>풀테이블 스캔을 하는 쿼리가 하나 줄었을 뿐인데 오류가 발생하지 않고 tps,응답시간에 향상이 있었음을 확인했습니다.</p>\n<h2>2차  개선 - 인덱스</h2>\n<p>해당 테이블에 인덱스 작업을 하지 않았기 때문에 인덱스를 적용하면 성능을 더 개선할 수 있을거라 생각했는데요.\n인덱스의 개념과 적용방법은 <a href=\"https://jinkshower.github.io/database_index/\">이전글</a>을 참고하시면 좋을 것 같습니다.</p>\n<p>인덱스를 적용하기 위해 컬럼들을 확인 할까요?\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/867dd6b7-7404-4ca2-a567-ebc65776ed54\" alt=\"Pasted image 20240424095115\"></p>\n<p>where 절에 조건이 명시 되지 않으면 인덱스를 타지 않기 때문에 availability, reserved 두 컬럼을 후보로 두었습니다.</p>\n<p>이에 availability, reserved를 복합 인덱스로 두고 인덱스를 타게 하기 위하여 쿼리를 변경해보았습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>  \n    s1_0<span class=\"token punctuation\">.</span>horizontal<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>vertical<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>availability<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>reserved  \n<span class=\"token keyword\">FROM</span>  \n    seats s1_0  \n<span class=\"token keyword\">WHERE</span>  \n    <span class=\"token punctuation\">(</span>  \n        s1_0<span class=\"token punctuation\">.</span>reserved <span class=\"token operator\">=</span> ? <span class=\"token operator\">OR</span> s1_0<span class=\"token punctuation\">.</span>availability <span class=\"token operator\">=</span> ?  \n        <span class=\"token punctuation\">)</span>  \n  <span class=\"token operator\">AND</span> s1_0<span class=\"token punctuation\">.</span>concert_id <span class=\"token operator\">=</span> ?<span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 실행계획은 그대로였습니다.</p>\n<p><img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/1547d9e0-2730-4d3f-8d0b-27d2511189b8\" alt=\"Pasted image 20240424124427\"></p>\n<p>왜 인덱스를 타지 않았을까요?</p>\n<h3>인덱스를 타지 않는 조건</h3>\n<p>이에 대해 인덱스를 타지 않는 조건에 대해 학습하게 되었습니다.</p>\n<ol>\n<li>인덱스 컬럼을 변환하는 쿼리</li>\n<li>NULL 조건을 사용하는 쿼리</li>\n<li>LIKE 문에서 와일드 카드를 앞에 두는 쿼리</li>\n<li>OR 조건에서 모든 컬럼에 인덱스 처리가 되지 않았을 때</li>\n<li>읽어야 할 레코드가 전체 테이블의 20%를 상회하는 쿼리</li>\n<li>조건문에 인덱스 컬럼을 명시하지 않는 쿼리</li>\n</ol>\n<p>해당 조건에서 4번이 저의 상황과 일치하다고 판단되었습니다. </p>\n<p>복합 인덱스를 사용할 시 각 컬럼에 단일 인덱스를 지정하여 합치는 것과 달리 하나의 인덱스가 생성되므로 or조건의 모든 컬럼에 인덱스 처리를 했다고 판단하지 않은 것이라고 예상했습니다.(해당 부분은 좀 더 공부가 필요한 것 같습니다.)</p>\n<h3>인덱스 수정 후 측정 결과</h3>\n<p>인덱스를 타지 않는 쿼리에 대해 학습하고 복합 인덱스가 아닌, reserved와 availability 각각의 컬럼에 인덱스 처리를 하면 되겠다고 판단하게 되었습니다.</p>\n<p>(각 컬럼 인덱스 처리 후 실행계획)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/14481d19-6374-4f8c-ba97-8dd6d3bf25a7\" alt=\"Pasted image 20240424141207\"></p>\n<p>(2차 개선 후 측정결과)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/87fa645b-f502-488f-8ebc-ecd2e79bbe08\" alt=\"Pasted image 20240417170033\">\n드디어 눈에 띄는 개선 결과가 측정되었습니다</p>\n<h2>3차 개선 - 캐싱</h2>\n<p>해당 api는 예약 불가능한 좌석의 정보만 보내주고 있는게 아니라 콘서트에 대한 정보도 같이 보내주고 있었는데요,\n실시간으로 예약 상태가 변경되는 좌석과 달리 콘서트 정보는 변경이 일어날 확률이 낮다고 판단했습니다.</p>\n<p>따라서 콘서트 정보는 캐싱을 적용할 수 있을 거라 판단되었고, 간단하게 적용할 수 있는 스프링의 로컬캐시를 적용해보기로 했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>  \n<span class=\"token annotation punctuation\">@EnableCaching</span>  \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CacheConfig</span> <span class=\"token punctuation\">{</span>  \n  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token constant\">CONCERT_CACHE</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"concertCache\"</span><span class=\"token punctuation\">;</span>  \n    \n    <span class=\"token annotation punctuation\">@Bean</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">CacheManager</span> <span class=\"token function\">cacheManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentMapCacheManager</span><span class=\"token punctuation\">(</span><span class=\"token constant\">CONCERT_CACHE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n  \n    <span class=\"token comment\">//매 6시간마다 콘서트 캐시 제거  </span>\n    <span class=\"token annotation punctuation\">@CacheEvict</span><span class=\"token punctuation\">(</span>allEntries <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> value <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">CONCERT_CACHE</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>  \n    <span class=\"token annotation punctuation\">@Scheduled</span><span class=\"token punctuation\">(</span>cron <span class=\"token operator\">=</span> <span class=\"token string\">\"0 0 */6 * * *\"</span><span class=\"token punctuation\">)</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">cacheEvict</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>로컬 캐시는 ttl을 줄 수 없기 때문에 6시간 간격으로 캐시를 비워주는 스케쥴러 기능을 같이 사용했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Cacheable</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token class-name\">CacheConfig</span><span class=\"token punctuation\">.</span><span class=\"token constant\">CONCERT_CACHE</span><span class=\"token punctuation\">,</span> key <span class=\"token operator\">=</span> <span class=\"token string\">\"#concertId\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>해당 어노테이션을 캐싱이 필요한 메서드에 추가해주었습니다.</p>\n<p>(3차 개선 후 측정결과)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/e71dd8e9-7fde-4e26-a607-386ed1dafd99\" alt=\"Pasted image 20240417202422\"></p>\n<p>2차 개선에서 소폭의 성능상승이 있음을 확인했습니다.</p>\n<h2>4차 개선 - 테이블 설계 변경</h2>\n<p>3차 개선까지 한 후 인덱스와 실행계획을 다시 살펴봤습니다.\n그리고 제 고정관념에 대해서 깨닫게 되었는데요.</p>\n<p>저는 <code class=\"language-text\">콘서트의 예약 불가능한 좌석</code>을 찾기 위해서 당연스럽게 where 절에 concertId를 첫번째 조건으로 명시했었습니다.</p>\n<p>하지만 2차개선에서 인덱스를 타기 위해 조건절을 변경하면서 이러한 생각이 깨지게 되었는데요, 제가 당연하게 생각했던 것이 db입장에서는 비효율적인 쿼리를 만들고 있었습니다.</p>\n<p>제가 원했던 좌석의 행열정보는\n<code class=\"language-text\">concertId -> availability or reserved</code>의 순서로 서치를 해도,\n<code class=\"language-text\">availabilty or reserved -> concertId</code> 의 순서로 서치를 해도 같은 결과가 나옴을 깨달았습니다. </p>\n<p>또한 두개의 컬럼에 각각 인덱스를 거는 것보다 좌석의 상태를 하나의 필드로 관리하고, 이에 인덱스를 걸면 추가 인덱스에 드는 저장공간 소모를 막을 수 있고, 좌석 상태에 대한 관리점을 하나로 모을 수 있겠다는 생각이 들었습니다.</p>\n<p>따라서 availability, reserved를 status라는 enum으로 모으고 status 필드 하나에만 인덱스를 걸어 보았습니다.</p>\n<p>(바뀐 쿼리)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span>  \n    s1_0<span class=\"token punctuation\">.</span>horizontal<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span>vertical<span class=\"token punctuation\">,</span>  \n    s1_0<span class=\"token punctuation\">.</span><span class=\"token keyword\">status</span>  \n<span class=\"token keyword\">from</span>  \n    seats s1_0  \n<span class=\"token keyword\">where</span>  \n    <span class=\"token punctuation\">(</span>  \n        s1_0<span class=\"token punctuation\">.</span><span class=\"token keyword\">status</span><span class=\"token operator\">=</span>?  \n            <span class=\"token operator\">or</span> s1_0<span class=\"token punctuation\">.</span><span class=\"token keyword\">status</span><span class=\"token operator\">=</span>? \n        <span class=\"token punctuation\">)</span>  \n  <span class=\"token operator\">and</span> s1_0<span class=\"token punctuation\">.</span>concert_id<span class=\"token operator\">=</span>?<span class=\"token punctuation\">;</span></code></pre></div>\n<p>(실행계획이 길어져 markdown으로 대체 합니다)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-> Filter: (s1_0.concert_id = 2)  (cost=4.56 rows=4.5) (actual time=0.13..0.136 rows=8 loops=1)  \n    -> Index range scan on s1_0 using idx_status over (status = 'RESERVED') OR (status = 'LOCKED'), with index condition: ((s1_0.`status` = 'RESERVED') or (s1_0.`status` = 'LOCKED'))  (cost=4.56 rows=9) (actual time=0.128..0.133 rows=8 loops=1)</code></pre></div>\n<p>실행 계획을 통해 한 번의 인덱스 스캔으로 먼저 8개의 로우로 데이터를 좁히고 그 안에서 concertId를 필터했음을 알 수 있습니다.</p>\n<p>(4차 개선 후 측정결과)\n<img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/14134eaf-59a2-4fd5-8b3c-5b38923297c7\" alt=\"Pasted image 20240418165800\">\n처음의 결과와 비교해보면 30배 정도의 성능 차이가 나는 것을 확인할 수 있습니다.</p>\n<h2>마치며</h2>\n<p>이렇게 api의 성능을 차례차례 개선한 기록을 작성해보았습니다.</p>\n<p>해당 방법은 status의 수가 적을때 유효하다는 단점이 있습니다. </p>\n<p>status가 비슷한 데이터가 많아질수록 풀스캔에 가까운 쿼리가 발생할 것이라고 예상되는데요, 하지만 예매가 거의 되지 않은 상황에서는 속도 차이가 많이 나기 때문에 의미있는 결과를 냈다고 생각합니다.</p>\n<p>또한 로컬 캐시를 사용했기 때문에 스케쥴러가 분산 서버에서는 여러개 발생해 의도치 않은 캐시 삭제가 일어날 가능성도 있으니 다른 환경에서는 변경이 필요한 방법이라고 생각됩니다.</p>\n<p>직접 인덱스를 걸고 실행계획을 확인하고 부하테스트를 진행하면서 제가 작성한 코드나 쿼리에 대해 다시 한번 돌아보는 계기가 되었습니다. 하나의 쿼리를 작성할 때 이 데이터가 10만개, 100만개가 된다면 어떻게 될까를 생각하게 해준 좋은 경험이었다고 생각합니다.</p>","frontmatter":{"title":"조회 API 성능 개선","date":"April 15, 2024","update":"April 15, 2024","tags":["performanceimprovement","index","caching","querytuning"],"series":"tickitecking"},"fields":{"slug":"/api_performance_improvment/","readingTime":{"minutes":11.675}}},"seriesList":{"edges":[{"node":{"id":"3d81f9cd-1c34-5429-b102-07e4e3c0e70f","fields":{"slug":"/docker_githubactions/"},"frontmatter":{"title":"Github Actions, Docker와 함께하는 배포 자동화"}}},{"node":{"id":"78a00267-c3db-5594-a5f3-621906fc030d","fields":{"slug":"/ticket_reservation_concurrency/"},"frontmatter":{"title":"'이미 선택된 좌석입니다' 티켓 예매시 중복예매생성 문제"}}},{"node":{"id":"ff98243f-757c-5a9c-a838-c8efb698054e","fields":{"slug":"/domain_refactoring/"},"frontmatter":{"title":"리팩토링을 통해 유연한 도메인을 만들자!"}}},{"node":{"id":"10982119-8b41-58d8-b2a9-83f45f276930","fields":{"slug":"/redis_deeper/"},"frontmatter":{"title":"Redis, 좀 더 자세히 알아볼까?"}}},{"node":{"id":"8ff84894-52cd-5648-be4d-4ae81514bfbb","fields":{"slug":"/api_performance_improvment/"},"frontmatter":{"title":"조회 API 성능 개선"}}},{"node":{"id":"c6508d6f-9443-5899-9f18-6f5ec12c7d72","fields":{"slug":"/db_replication/"},"frontmatter":{"title":"알아보고 적용하는 DB Replication"}}},{"node":{"id":"ca9fbb61-c38d-5470-9356-76fec2e7afd2","fields":{"slug":"/technology_free_code/"},"frontmatter":{"title":"기술변경에 확장성을 가진 리팩토링"}}},{"node":{"id":"3243d1e2-cbd1-5c85-94bb-6d089878a5cb","fields":{"slug":"/monitoring/"},"frontmatter":{"title":"Actuator, Prometheus, Grafana로 서버 장애 대응하기"}}}]},"previous":{"fields":{"slug":"/redis_deeper/"},"frontmatter":{"title":"Redis, 좀 더 자세히 알아볼까?"}},"next":{"fields":{"slug":"/db_replication/"},"frontmatter":{"title":"알아보고 적용하는 DB Replication"}}},"pageContext":{"id":"8ff84894-52cd-5648-be4d-4ae81514bfbb","series":"tickitecking","previousPostId":"10982119-8b41-58d8-b2a9-83f45f276930","nextPostId":"c6508d6f-9443-5899-9f18-6f5ec12c7d72"}},"staticQueryHashes":[],"slicesMap":{}}