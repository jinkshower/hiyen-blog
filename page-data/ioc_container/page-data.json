{"componentChunkName":"component---src-templates-post-jsx","path":"/ioc_container/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"c17ef800-a544-57ca-92de-7d72b555fd0f","excerpt":"의존성 주입(DI)포스팅에서 이어지는 내용입니다. Inversion of Control (제어의 역전) 이란? 객체의 컨트롤이나 프로그램의 일정부분을 프레임워크의 컨테이너으로 옮기는 소프트웨어 설계의 원리를 뜻한다. \n이 원리는 여러가지 디자인 패턴(전략 패턴, 서비스 로케이터 패턴, 팩토리 패턴)으로 실현될 수 있고 특히 의존성 주입(DI)로 가장 두드…","html":"<p>의존성 주입(DI)<a href=\"https://jinkshower.github.io/dependency_injection/\">포스팅</a>에서 이어지는 내용입니다.</p>\n<h2>Inversion of Control (제어의 역전) 이란?</h2>\n<p>객체의 컨트롤이나 프로그램의 일정부분을 프레임워크의 컨테이너으로 옮기는 소프트웨어 설계의 원리를 뜻한다.\n이 원리는 여러가지 디자인 패턴(전략 패턴, 서비스 로케이터 패턴, 팩토리 패턴)으로 실현될 수 있고 특히 의존성 주입(DI)로 가장 두드러지게 나타낼 수 있다.</p>\n<h2>자바로 보는 제어의 역전</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">House</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Tv</span> tv <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Tv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">House</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 House는 Tv클래스에 대한 제어권을 가지고 있다\n즉,  House는 <code class=\"language-text\">tv</code>라는 참조변수에 어떤 Tv가 들어올지 스스로가 정하고 있다고 볼 수 있다. </p>\n<p>여기에 DI를 적용해보자 </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">House</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Tv</span> tv<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">House</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Tv</span> tv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tv <span class=\"token operator\">=</span> tv<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>House가 가지고 있던 제어권이 외부로 넘어갔다.\n즉, tv 객체를 생성하고 참조변수로 이어주는 역할을 더 이상 House가 하고 있지 않다.</p>\n<p>이렇게 House 객체는 객체를 생성하는 책임에서 벗어나게 되었고, 자신의 비즈니스 로직만 알아서 잘 실행하는 바람직한 객체가 되었다. </p>\n<p>하지만 이렇게 외부로 넘어간 제어권은 어디에 있을까?\nTv를 가지는 House를 만들기 위해서 우리의 코드 어디선가는 반드시\n<code class=\"language-text\">House house = new House(new Tv());</code>\n로 새로운 House를 만드는 호출을 해주어야만 한다. </p>\n<p>즉, 위 코드가 적힌 곳이 Main 이든, HouseFactory든 계속 제어권을 외부로 옮기는 것을 반복하다보면 어느 객체는 그 넘겨진 제어권을 실행해야 하는 것이다.</p>\n<h2>의존성을 주입하는 객체 만들기</h2>\n<p>그렇다면 의존성을 모두 한 곳에서 주입, 즉 제어권을 한 객체가 가지고 있다면 유지보수하기가 훨씬 쉬워지지 않을까? </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppConfig</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">House</span> <span class=\"token function\">house</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">House</span><span class=\"token punctuation\">(</span><span class=\"token function\">tv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Tv</span> <span class=\"token function\">tv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n<span class=\"token comment\">//        return new Tv();  </span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SmartTv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token comment\">//tv interface를 가정</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>AppConfig라는 객체를 생성하고, 여기에 모든 의존성 주입하는 코드를 작성했다. </p>\n<p>의존성 주입의 모든 장점을 유지하면서 제어권을 한 객체가 가지게 했기 때문에 이제 우리는 새로운 tv를 가진 House를 만들고 싶을 때 이 한 파일에 있는 코드 한 줄만 수정하면 된다. </p>\n<p>이렇게 어떤 객체가 어떻게 생성될 지, 프로그램을 구성하는 역할을 비즈니스 로직을 실행하는 객체들로부터 분리시킴으로써 우리는 해당 프로그램을 유지보수하는데에 엄청난 이점을 갖게 되었다.  </p>\n<p>하지만 여전히 의문이 든다.\n그럼 AppConfig는 어디서 생성하나?\nAppConfig 안의 house()를 호출하는 객체가 여전히 제어권을 가지고 있는 것 아닐까? </p>\n<h2>스프링 컨테이너</h2>\n<p>풀리지 않는 이 연쇄를 프레임워크로 넘김으로써 해결할 수 있다.\nIoC 컨테이너를 가지고 있는 프레임워크는 객체를 생성하고, 구성하고, 의존관계에 맞게 주입해주는 기능을 가지고 있다. </p>\n<p>Spring은 <code class=\"language-text\">ApplicationContext</code> interface로 IoC컨테이너 기능을 수행하고 있고, 구현체들은 다양한 설정 메타데이터(xml, java code, annotation)를 읽고, 이를 <code class=\"language-text\">Bean</code>이라는 객체로 만들어 준다. </p>\n<h2>\b스프링 컨테이너 사용하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>  \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppConfig</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token annotation punctuation\">@Bean</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">House</span> <span class=\"token function\">house</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">House</span><span class=\"token punctuation\">(</span><span class=\"token function\">tv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token annotation punctuation\">@Bean</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Tv</span> <span class=\"token function\">tv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n<span class=\"token comment\">//        return new Tv();  </span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SmartTv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tv<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{class path}<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span> \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>house<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>{class path}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span> \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>constructor-arg</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tv<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tv<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span> \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Annotation을 사용하거나, xml 파일로 객체 구성정보를 메타데이터화 할 수 있다. </p>\n<p>Annotation이나 xml모두 각각의 장단점을 가지고 있는데\nAnnotation은 물론 편리하고 간단한것이 큰 장점이며 xml은  소스코드를 건드리지 않고, 컴파일을 하지도 않으면서도 메타데이터를 변경할 수 있다.</p>\n<p>위와 같이 메타데이터를 작성하면\n스프링이 대신 객체를 각각 <code class=\"language-text\">Bean</code>으로 등록함은 물론 House에 Tv를 넣어서 생성하는 것과 같은 의존관계 설정도 자동으로 해주며 객체 라이프사이클관리도 해준다.</p>\n<p>즉, 우리는 아래와 같은 코드를 작성할 필요 없어지고 </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">AppConfig</span> appConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AppConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">House</span> house <span class=\"token operator\">=</span> appConfig<span class=\"token punctuation\">.</span><span class=\"token function\">house</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>객체 생성, 관리에 대한 제어권이 프로그래머에서 역전(Inverse) 되어 프레임워크가 맡게 된다.</em></p>\n<hr>\n<p>참고 </p>\n<p><a href=\"https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring\">https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring</a></p>\n<p><a href=\"https://docs.spring.io/spring-framework/reference/core/beans/basics.html\">https://docs.spring.io/spring-framework/reference/core/beans/basics.html</a></p>\n<p><a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8\">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8</a></p>","frontmatter":{"title":"IoC와 스프링 컨테이너","date":"January 20, 2024","update":"January 20, 2024","tags":["spring","ioc","container"],"series":"spring"},"fields":{"slug":"/ioc_container/","readingTime":{"minutes":6.235}}},"seriesList":{"edges":[{"node":{"id":"c17ef800-a544-57ca-92de-7d72b555fd0f","fields":{"slug":"/ioc_container/"},"frontmatter":{"title":"IoC와 스프링 컨테이너"}}},{"node":{"id":"6c65cd83-70af-5df5-abf5-60d838be2c24","fields":{"slug":"/spring_exception/"},"frontmatter":{"title":"AOP를 통한 Spring 예외처리"}}},{"node":{"id":"598faadf-ec7e-5e5f-877e-46e55774c613","fields":{"slug":"/jdbc_template/"},"frontmatter":{"title":"JDBC 에서 JDBC Template"}}},{"node":{"id":"e135a9fa-ab66-51f6-b17b-59a3b7f2f7f3","fields":{"slug":"/argumentresolver/"},"frontmatter":{"title":"ArgumentResolver추가로 코드 개선하기"}}},{"node":{"id":"7cff2a81-ce61-50f3-82e6-67796b44edb7","fields":{"slug":"/acceptance_test/"},"frontmatter":{"title":"인수 테스트(Acceptance Test)"}}},{"node":{"id":"8ff84894-52cd-5648-be4d-4ae81514bfbb","fields":{"slug":"/api_performance_improvment/"},"frontmatter":{"title":"조회 API 성능 개선"}}}]},"previous":{"fields":{"slug":"/first_team_assignment/"},"frontmatter":{"title":"첫 팀 과제 회고"}},"next":{"fields":{"slug":"/spring_exception/"},"frontmatter":{"title":"AOP를 통한 Spring 예외처리"}}},"pageContext":{"id":"c17ef800-a544-57ca-92de-7d72b555fd0f","series":"spring","previousPostId":"6474dbfb-71da-5cdc-b0c7-7f4ebdbd530e","nextPostId":"6c65cd83-70af-5df5-abf5-60d838be2c24"}},"staticQueryHashes":[],"slicesMap":{}}