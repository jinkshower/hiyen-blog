{"componentChunkName":"component---src-templates-post-jsx","path":"/process_thread/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"a822aa37-eb51-5729-9d86-3a0da053351b","excerpt":"'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB Process Control Block 모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.…","html":"<p>'혼자 공부하는 시스템구조&#x26;운영체제'를 읽고 공부한 내용</p>\n<h2>프로세스</h2>\n<h3>Process? Program?</h3>\n<p>우리는 흔히 <code class=\"language-text\">프로그램을 실행한다</code> 라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 <code class=\"language-text\">프로그램</code>을  '메모리에 적재하고 cpu가 실행'하여 <code class=\"language-text\">프로세스</code>화 한다와 같은 말이다. </p>\n<h3>PCB Process Control Block</h3>\n<p>모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.\n그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 <code class=\"language-text\">PCB</code>라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.</p>\n<blockquote>\n<p>[PCB에 저장되는 정보]<br>\nPID(Process ID) : 프로세스 고유의 번호\nRegisters: 레지스터의 중간값<br>\nProcess state: 대기,준비, 실행 등의 프로세스 상태\nCPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보<br>\nMemory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블\nList of Open files : 입출력장치 정보</p>\n</blockquote>\n<h3>이 PCB로 어떻게 관리하나?</h3>\n<p>CPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. </p>\n<p>이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. </p>\n<p>이 중간 정보는 <code class=\"language-text\">문맥Context</code>으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 <code class=\"language-text\">문맥 교환 Context Switching</code> 이라고 한다.\n(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)</p>\n<blockquote>\n<p>[동시에 실행되는 것 '처럼' 보인다]<br>\n프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.<br>\n정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.</p>\n</blockquote>\n<h2>프로세스의 구성</h2>\n<p><code class=\"language-text\">정적 할당 영역</code><br>\n코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only</p>\n<p>데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터\nex) 전역변수, 상수</p>\n<p><code class=\"language-text\">동적 할당 영역</code><br>\n힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간\nex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) </p>\n<p>스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터\nex)매개변수, 지역변수 </p>\n<p><em>즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다</em></p>\n<h2>프로세스의 상태</h2>\n<p>프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다.\n입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다.\n그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. </p>\n<ul>\n<li>생성 상태(new)</li>\n<li>준비 상태(ready)</li>\n<li>대기상태(blocked) </li>\n<li>실행상태(running)</li>\n<li>종료상태(terminated)</li>\n</ul>\n<p><code class=\"language-text\">준비상태 vs 대기상태</code><br>\n준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다.\n준비상태에서 실행상태가 되는 것을 <strong>dispatch</strong>라고 한다 </p>\n<p>대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 <strong>준비상태</strong>가 된다. </p>\n<h2>스레드</h2>\n<h3>프로세스와 스레드</h3>\n<p>스레드는 <code class=\"language-text\">프로세스를 구성하는 실행 단위</code>를 의미한다\n스레드는 프로세스의 자원을 공유하며 여러개가 존재 할 수 있다.\n스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. </p>","frontmatter":{"title":"프로세스","date":"December 28, 2023","update":"December 28, 2023","tags":["process","operating_system"],"series":"process"},"fields":{"slug":"/process_thread/","readingTime":{"minutes":5.89}}},"seriesList":{"edges":[{"node":{"id":"a822aa37-eb51-5729-9d86-3a0da053351b","fields":{"slug":"/process_thread/"},"frontmatter":{"title":"프로세스"}}}]},"previous":{"fields":{"slug":"/gatsby_website/"},"frontmatter":{"title":"Gatsby와 Github Pages로 개인 블로그 만들기"}},"next":null},"pageContext":{"id":"a822aa37-eb51-5729-9d86-3a0da053351b","series":"process","previousPostId":"c4a1e307-464b-5e6f-811a-e2c1b5ad3393","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}