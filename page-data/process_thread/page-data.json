{"componentChunkName":"component---src-templates-post-jsx","path":"/process_thread/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"a822aa37-eb51-5729-9d86-3a0da053351b","excerpt":"'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB Process Control Block 모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.…","html":"<p>'혼자 공부하는 시스템구조&#x26;운영체제'를 읽고 공부한 내용</p>\n<h2>프로세스</h2>\n<h3>Process? Program?</h3>\n<p>우리는 흔히 <code class=\"language-text\">프로그램을 실행한다</code> 라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 <code class=\"language-text\">프로그램</code>을  '메모리에 적재하고 cpu가 실행'하여 <code class=\"language-text\">프로세스</code>화 한다와 같은 말이다. </p>\n<h3>PCB Process Control Block</h3>\n<p>모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.\n그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 <code class=\"language-text\">PCB</code>라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.</p>\n<blockquote>\n<p>[PCB에 저장되는 정보]<br>\nPID(Process ID) : 프로세스 고유의 번호\nRegisters: 레지스터의 중간값<br>\nProcess state: 대기,준비, 실행 등의 프로세스 상태<br>\nCPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보<br>\nMemory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블<br>\nList of Open files : 입출력장치 정보</p>\n</blockquote>\n<h3>이 PCB로 어떻게 관리하나?</h3>\n<p>CPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. </p>\n<p>이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. </p>\n<p>이 중간 정보는 <code class=\"language-text\">문맥Context</code>으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 <code class=\"language-text\">문맥 교환 Context Switching</code> 이라고 한다.\n(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)</p>\n<blockquote>\n<p>[동시에 실행되는 것 '처럼' 보인다]<br>\n프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.<br>\n정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.</p>\n</blockquote>\n<h2>프로세스의 구성</h2>\n<p><code class=\"language-text\">정적 할당 영역</code><br>\n코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only</p>\n<p>데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터\nex) 전역변수, 상수</p>\n<p><code class=\"language-text\">동적 할당 영역</code><br>\n힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간\nex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) </p>\n<p>스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터\nex)매개변수, 지역변수 </p>\n<p><em>즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다</em></p>\n<h2>프로세스의 상태</h2>\n<p>프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다.\n입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다.\n그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. </p>\n<ul>\n<li>생성 상태(new)</li>\n<li>준비 상태(ready)</li>\n<li>대기상태(blocked) </li>\n<li>실행상태(running)</li>\n<li>종료상태(terminated)</li>\n</ul>\n<p><code class=\"language-text\">준비상태 vs 대기상태</code><br>\n준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다.\n준비상태에서 실행상태가 되는 것을 <strong>dispatch</strong>라고 한다 </p>\n<p>대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 <strong>준비상태</strong>가 된다. </p>\n<h2>스레드</h2>\n<h3>프로세스와 스레드</h3>\n<p>스레드는 <code class=\"language-text\">프로세스를 구성하는 실행 단위</code>를 의미한다\n스레드는 <strong>프로세스의 자원</strong>을 공유하며 여러개가 존재 할 수 있다.\n스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. </p>\n<h3>멀티스레드</h3>\n<p>멀티스레드는 <code class=\"language-text\">문맥 교환</code>으로 동시성을 획득하는 멀티프로세스와 다르게</p>\n<ol>\n<li>병렬성을 가지고 실제로 동시에 수행될 수 있다. </li>\n<li>한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.</li>\n</ol>\n<p>하지만 이러한 장점들은 단점이 될 수도 있다.</p>\n<ol>\n<li>동시에 수행될 수 있다는 것은 동기화 문제를 내재한다</li>\n<li>자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다 </li>\n</ol>\n<p>이중 첫번째 단점을 조금 더 자세히 서술하겠다.</p>\n<h3>멀티 스레드의 동기화 문제</h3>\n<p>운영체제는 여러개의 프로세스의 실행을 관리한다고 말했는데, 이는 운영체제에 <code class=\"language-text\">CPU 스케쥴링</code> 알고리즘이 존재한다는 것을 의미한다.\n그러나 멀티스레드는 A,B 스레드 중 어떤 스레드가 먼저 실행될지 결정 되어 있지 않다.\n간단한 예제로 알아보자</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Calculator</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  \n  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  \n  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> maxCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>  \n                count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>  \n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>얼핏 보면 문제가 없어보이지만 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1\n3\n4\n2\n5\n6</code></pre></div>\n<p>실행 결과는 이렇게 뒤죽박죽인채로 출력된다.\n이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 문제를 <code class=\"language-text\">Synchronization Issue</code> 라고 한다. </p>\n<p>-> 이를 해결하기 위한 다양한 방법이 있는데 자세한 내용은 다른 글에서 다룰 예정이다. </p>","frontmatter":{"title":"프로세스","date":"December 28, 2023","update":"December 28, 2023","tags":["process","operating_system"],"series":"process"},"fields":{"slug":"/process_thread/","readingTime":{"minutes":8.34}}},"seriesList":{"edges":[{"node":{"id":"a822aa37-eb51-5729-9d86-3a0da053351b","fields":{"slug":"/process_thread/"},"frontmatter":{"title":"프로세스"}}}]},"previous":{"fields":{"slug":"/gatsby_website/"},"frontmatter":{"title":"Gatsby와 Github Pages로 개인 블로그 만들기"}},"next":null},"pageContext":{"id":"a822aa37-eb51-5729-9d86-3a0da053351b","series":"process","previousPostId":"c4a1e307-464b-5e6f-811a-e2c1b5ad3393","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}