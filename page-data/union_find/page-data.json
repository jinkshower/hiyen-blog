{"componentChunkName":"component---src-templates-post-jsx","path":"/union_find/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"08134225-7821-543b-a3ae-386f3b7b4215","excerpt":"Algorithms 강의를 들으며 공부한 기록 Union Find 두 원소가 같은 집합내에 있는지 확인할때 사용하는 알고리즘이다.\nDynamic connectiviy의 자료구조 중 그래프에 edge가 추가되기만 하는 구조(Incremental connectivity) 에서 사용할 수 있다.   로 p와 q를 같은 집합으로 만들고\n로 p의 루트를 찾거나 로…","html":"<p>Algorithms 강의를 들으며 공부한 기록</p>\n<h2>Union Find</h2>\n<p>두 원소가 같은 집합내에 있는지 확인할때 사용하는 알고리즘이다.\nDynamic connectiviy의 자료구조 중 그래프에 edge가 추가되기만 하는 구조(Incremental connectivity) 에서 사용할 수 있다. </p>\n<p><code class=\"language-text\">union(int p, int q)</code> 로 p와 q를 같은 집합으로 만들고\n<code class=\"language-text\">find(int p)</code>로 p의 루트를 찾거나 <code class=\"language-text\">connected(int p, int q)</code>로 두 요소가 연결되었는가를 확인하는 알고리즘이다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UF</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">void</span> <span class=\"token function\">union</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">connected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Quick-find</h2>\n<p>가장 기본적인 방법으로 id array에 각 요소를 매핑하고 <code class=\"language-text\">union(int p, int q)</code>가 호출되면 모든 id array를 loop로 돌며 p의 id와 같은 id를 q의 id로 변경하는 방법이다</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">QuickFindUF</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UF</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> id<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">QuickFindUF</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        id <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">// id 배열 매핑</span>\n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span> \n    <span class=\"token annotation punctuation\">@Override</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">connected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> id<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> id<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// id 확인</span>\n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token annotation punctuation\">@Override</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">union</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">int</span> pid <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">int</span> qid <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> id<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n                id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> qid<span class=\"token punctuation\">;</span>  \n            <span class=\"token punctuation\">}</span>  \n        <span class=\"token punctuation\">}</span>  <span class=\"token comment\">// p와 id가 같은 모든 id를 q의 id로 바꾼다 </span>\n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>initialize : n</li>\n<li>union : n</li>\n<li>find : n</li>\n</ul>\n<p>n개의 요소에 n의 union은 n^2의 시간이 걸린다 </p>\n<h2>Quick-Union</h2>\n<p>id array를 쓰는 것은 비슷하지만 이번에는 i의 부모를 id array에 매핑한다. 즉 <code class=\"language-text\">union(int p, int q)</code>를 호출하면 p의 부모의 id를 q의 부모의 id로 바꾼다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">QuickUnionUF</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UF</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> id<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">QuickUnionUF</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        id <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            i <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 부모 루트를 최상단까지 찾는다 </span>\n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token annotation punctuation\">@Override</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">union</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//p의 루트를 q의 루트로 바꾼다</span>\n    <span class=\"token punctuation\">}</span>   \n    <span class=\"token annotation punctuation\">@Override</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">connected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>initialize : n</li>\n<li>union : n (root 찾는 비용 포함)</li>\n<li>find : n</li>\n</ul>\n<p>Quick-Find 보다 더 빠른 실행을 보이는 케이스도 있지만 알고리즘은 항상 최악의 경우를 상정해야 하므로 트리구조가 엄청나게 길거나 길이가 N이 될때 Quick-Find와 비슷하게 n^2의 실행시간을 가지게 된다</p>\n<h2>Quick Union 개선하기</h2>\n<h3>Weighting</h3>\n<p>현재 Quick Union은 트리의 크기와 상관없이 무조건 p를 q의 루트에 갖다\n붙이기 때문에 트리의 길이가 엄청나게 길어지는 문제점을 가지고 있다. </p>\n<p>하지만 union을 실행할때 트리의 사이즈를 비교하고 작은 트리를 보다 큰 트리에 연결하면 트리의 깊이를 짧게 유지할 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">QuickUnionUF</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UF</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> id<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">QuickUnionUF</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        id <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">N</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            sizes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">// size도 같이 매핑한다</span>\n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            i <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token annotation punctuation\">@Override</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">union</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//루트가 같으면 early return</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t        id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n\t        size<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> size<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t        id<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\t        size<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> size<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//사이즈 비교 후 작은 트리를 큰 트리에 병합한다</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>   \n    <span class=\"token annotation punctuation\">@Override</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">connected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>initialize : n</li>\n<li>union : lg n(root 찾기 까지 포함)</li>\n<li>find : lg n</li>\n</ul>\n<p><code class=\"language-text\">왜 lg n의 비용으로 줄어들었을까?</code> </p>\n<p>T1의 크기가 3이고  T2의 크기가 5일때 T1에 있는 a를 T2에 있는 b에 연결시킨다고 가정해보자. </p>\n<p>이때 T1은 T2에 병합되고 a의 깊이는 1이 증가하게 된다. union을 호출할때 a의 깊이는 1이 증가하는데에 비해 a가 속한 트리의 크기는 3에서 8로 최소 2배이상이 증가하게 된다.</p>\n<p>이를 계속 실행하면 </p>\n<table>\n<thead>\n<tr>\n<th>a의 깊이</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>...</th>\n<th>lg N</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a가 속한 트리의 크기</td>\n<td>1</td>\n<td>2</td>\n<td>4</td>\n<td>8</td>\n<td></td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<p>이 되기 때문에 find의 비용이 절감하게 된다</p>\n<h3>Path-Compressing</h3>\n<p>위의 알고리즘을 Path-Compressing으로 더 개선할 수 있다   </p>\n<p>현재는 <code class=\"language-text\">root()</code>를 while문으로 모든 깊이의 노드를 반복하여 검색하고 있다.</p>\n<p>이 때 이 기능이 호출될때마다 각 호출된 노드의 id를 루트의 id로 바꿔주는 작업을 하면 트리의 깊이를 더 평탄하게 바꾸어 줄 수 있다.</p>\n<p>위의 코드의 root를 </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n\t        id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// i의 루트를 부모 루트로!</span>\n            i <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>  </code></pre></div>\n<p>이렇게 바꿔주기만 해도 트리의 깊이가 계속 평탄화 되면서 root를 호출하는 모든 기능의 비용이 절감된다. </p>\n<p>참고\n<a href=\"https://www.coursera.org/learn/algorithms-part1\">https://www.coursera.org/learn/algorithms-part1</a></p>","frontmatter":{"title":"Union Find","date":"January 14, 2024","update":"January 14, 2024","tags":["algorithms","union_find"],"series":"algorithms"},"fields":{"slug":"/union_find/","readingTime":{"minutes":6.34}}},"seriesList":{"edges":[{"node":{"id":"08134225-7821-543b-a3ae-386f3b7b4215","fields":{"slug":"/union_find/"},"frontmatter":{"title":"Union Find"}}}]},"previous":{"fields":{"slug":"/dependency_injection/"},"frontmatter":{"title":"의존성 주입(Dependency Injection)"}},"next":{"fields":{"slug":"/first_team_assignment/"},"frontmatter":{"title":"첫 팀 과제 회고"}}},"pageContext":{"id":"08134225-7821-543b-a3ae-386f3b7b4215","series":"algorithms","previousPostId":"fdf4dd31-0e89-586d-afc5-f7e7df28cbff","nextPostId":"6474dbfb-71da-5cdc-b0c7-7f4ebdbd530e"}},"staticQueryHashes":[],"slicesMap":{}}