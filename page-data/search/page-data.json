{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은  과  이다.  처음에는 로 웹사이트를 만들었지만 몇 가지 고치고 싶은…","fields":{"slug":"/gatsby_website/"},"frontmatter":{"date":"December 26, 2023","title":"Gatsby와 Github Pages로 개인 블로그 만들기","tags":["gatsby","github_pages"]},"rawMarkdownBody":"\n## Gatsby로 Github pages 개인 블로그 만들기\n\nTIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 `Jekyll` 과 `Gatsby` 이다. \n\n처음에는 `Jekyll`로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 `Gatsby`로 프레임워크를 바꾸게 되었다.\n\n나는 미리 만들어진 [테마](https://github.com/devHudi/gatsby-starter-hoodie) 를 사용했다.(감사합니다)\n\n## Gatsby 설치 와 웹사이트 설정\n\nGatsby cli를 설치해준다 \n```\nnpm install -g gatsby-cli\n```\n\n`Gatsby Starter Library`에서 마음에 드는 테마를 선택할 수 있다.\n원하는 테마를 고른 뒤\n\n```\nnpx gatsby new {local-folder-name} {theme-name}\n```\n을 실행해 로컬에 Gatsby 템플레이트를  만든다.\n\n```\ncd {local-folder-name}\ngatsby develop\n```\n을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 `http://localhost:8000`이다. \n\n## Github Repository연결\n\nGithub의 새 리포지토리를 생성한다.\n나는 `{username}.github.io`로 이름을 지정했다. \n다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면 \n[Gatsby 공식문서](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/) 를 참고하길 바란다\n\n리포지토리를 생성했다면\n```\ngit remote add origin {github-https-address}\n```\n를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.\n\n그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 \n```\ngit add .\ngit commit -m \"{commit-name}\"\ngit push origin main\n```\n위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.\n\n## 배포 방법 정하기\n\n배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다\n\n1. Netlify\nGithub과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.\n[A Step-by-Step Guide: Gatsby on Netlify](https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/) 공식문서\n2. Github pages\nGithub pages에서 제공하는 `gh-pages`를 이용하여 배포할 수 있다\n[How Gatsby Works with GitHub Pages](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/)공식 문서\n\n나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 `{smt}.netflify.app`를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 `{smt}.github.io` 도메인이 마음에 들어서다(...)\n\n\n## Github Pages로 배포하기 \n\n배포용 브랜치 설정\ngh-pages는 배포용 브랜치가 따로 있어야 한다.   \n우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 `.gitignore`에서 public을 푸쉬하지 않게 설정되어 있다.\n\n현 상태에서 배포용 브랜치를 하나 만들어 둔다.\n```\ngit branch deploy\n```\n\n이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다. \n`gh-pages`패키지를 설치하자.\n\n```\nnpm install gh-pages\n```\n\n>[Trouble Shooting]   \n나는 npm install 과중에서 dependency conflict가 발생했다.   \nnode 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다\n\n>-> 위의 install 커맨드에 `--force` 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 `--legacy-peer-deps`로 자동설치를 막는 방법이 있다. 나는 `--force`로 설치했다.\n\n\n다음은 `package.json` 에 배포에 사용할 스크립트를 추가해주면 된다.\n```\n\"scripts\": {\n    \"deploy\": \"gatsby build && gh-pages -d public -b deploy\"\n}\n```\n\n그리고\n```\nnpm run deploy \n```\n를 실행한다.   \n   \n>[Trouble Shooting]   \n>위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 `npm run clean`으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.\n\n이후\nGithub repository의 Settings-Pages\n`Build and deployment`에서 배포용 브랜치로 전환해준다.\n\n이렇게 까지 하면 `Actions`에서 웹사이트를 배포해주고 브라우저에서\n```\nhttps://{user-name}.github.io/\n```\n 주소로 접속이 가능해진다. \n\n"},{"excerpt":"정적 팩토리 메서드란? Java에서는   연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에  메서드를 사용하여 인스턴스를 반환 받는 기법이 있다. 간단한 예시로 사용방법을 알아 보자.  이  클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에  를 추가함으로써 인스턴스를 반환 받는 다른  를  생성하는 기법이라고 할 수 있다.  정적팩토리 …","fields":{"slug":"/staticfactorymethod/"},"frontmatter":{"date":"December 24, 2023","title":"정적 팩토리 메서드, 언제 쓸까?","tags":["java","staticfactorymethod"]},"rawMarkdownBody":"## 정적 팩토리 메서드란?\n\nJava에서는 `new`  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 `static` 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.\n\n간단한 예시로 사용방법을 알아 보자. \n```java\nclass Car {  \n    String name;  \n  \n    Car(String name) {   \n        this.name = name;  \n    }  \n}\n```\n\n이 `Car` 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에\n```java\nstatic Car from(String name) {  \n    return new Car(name);  \n}\n```\n\n`정적 팩토리 메서드` 를 추가함으로써 인스턴스를 반환 받는 다른 `통로` 를  생성하는 기법이라고 할 수 있다. \n\n## 정적팩토리 메서드, 왜 쓰나?\n\n`Effective Java`는 1장에서 `생성자 대신 정적 팩토리 메서드를 고려하라` 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 [링크](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)   \n이 포스트에서는 내가  **개인적으로** 언제 이 기법을 사용하는지 서술해 보려고 한다.\n\n### 이름이 있는 것이 나은 경우\n\n위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자\n\n```java\npublic void createCar(String input) {  \n    Car car1 = new Car(input);  \n    Car car2 = Car.from(input);  \n}\n```\n\n위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다. \n`new` 연산자는 `이 Car는 input을 멤버 변수로 가지는군` 이라면\n`from` 은 `이 input은 객체 내에서 특정한 로직으로 변환되겠군` 이라는 멘탈 모델을 제공한다. \n\n`이름을 가질 수 있다` 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.\n\n### 한 가지 방법으로만 객체가 생성되게 하고 싶을 때\n\n우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.\n\n```java\nclass User {  \n    int id;  \n  \n    private User(int id) {  \n        this.id = id;  \n    }  \n  \n    static User from(int id) {  \n        if (isInvalidId(id)) {  \n            return null;  \n        }  \n        return new User(id);  \n    }  \n}\n```\n\n따라서 이 때는 `private` 으로 `new`연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.\n이는 `싱글톤패턴` 의 사용과도 일맥상통한다\n\n### 같은 객체가 여러번 쓰여야할 때\n\n같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에*만*  객체를 생성해 메모리를 아낄 수 있다.\n```java \nclass CarFactory {  \n  \n    static final Map<String, Car> cars = new HashMap<>();  \n  \n    static {  \n        cars.put(\"a\", new Car(\"a\"));  \n        cars.put(\"b\", new Car(\"b\"));  \n        cars.put(\"c\", new Car(\"c\"));  \n    }  \n\t  //if cache doesn't contains key, only then instantiate new car\n    static Car from(String text) {  \n        if (cars.containsKey(text)) {  \n            return cars.get(text);  \n        }  \n        return new Car(text);  \n    }  \n}\n```\n\n\n>[정리]   \n 1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우   \n 2.지정된 경우 이외의 객체 생성을 막고 싶은 경우   \n 3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 \n\n이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.\n\n## private으로 생성자 막기\n\n`Effective Java` 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 `Composition`을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. \n\n```java\nclass CarSet {  \n    private final Map<Car, String> cars;  \n    \n    public CarSet(Map<Car, String> cars) {  \n        this.coins = new HashMap<>(cars);  \n    }  \n  \n    public static CarSet from(String text) {  \n        //Complicated Logic..   \n        //..  \n        return new CarSet(cars);  \n    }  \n}\n```\n하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다\ntext를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 `재사용성` 이 늘어날 수 있기 때문이다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}