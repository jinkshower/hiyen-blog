{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"의존성이란 객체 지향 언어에서 A 객체가 B객체를 이용할때 A는 B를  고 표현한다.  A가 생성될 때 B가 필요할 수도 있고, A의 메서드의 파라미터로 B가 있을 수도 있다.  House객체가 Tv객체를 이용하는 예시를 들어보자 더이상 House객체가 변하지 않으면 위 코드는 문제가 없다.  하지만 House가 새로운 를 가져야 한다면? House를 테…","fields":{"slug":"/dependency_injection/"},"frontmatter":{"date":"January 11, 2024","title":"의존성 주입(Dependency Injection)","tags":["dependency_injection","java"]},"rawMarkdownBody":"\n## 의존성이란\n\n객체 지향 언어에서 A 객체가 B객체를 이용할때 A는 B를 `의존한다` 고 표현한다.  A가 생성될 때 B가 필요할 수도 있고, A의 메서드의 파라미터로 B가 있을 수도 있다. \n\nHouse객체가 Tv객체를 이용하는 예시를 들어보자\n\n```java\npublic class House {\n\tprivate Tv tv = new Tv(); // House는 Tv에 의존한다\n\t\n\tpublic House() {\n\t}\n}\n```\n\n더이상 House객체가 변하지 않으면 위 코드는 문제가 없다. \n\n하지만 House가 새로운 `SmartTv`를 가져야 한다면? House를 테스트할 때 다른 Tv 종류를 넣어보고 싶다면?\n\nTv를 인터페이스화 해서 다른 Tv를 넣을 수는 있지만 임시방편일 뿐이다. \n\n```java\npublic class House {\n\t//Tv tv = new Tv(); \n\tprivate Tv tv = new SmartTv(); //tv에 다른 구현체를 넣었지만..\n\t\n\tpublic House() {\n\t}\n}\n\npublic interface Tv {\n\tvoid turnOn();\n}\n\npublic class SmartTv implements Tv {\n\t// some logic\n}\n```\n\n이렇게 객체가 다른 객체에 강한 의존성을 지니면 코드를 재사용하거나 확장하는데에 문제점이 생긴다.\n\n## 의존성을 주입하자 \n\nHouse가 여러 Tv를 사용하는 것에 제약이 생긴 이유는 House가 어떠한 종류의 Tv를 자신의 상태로 가질지 미리 알고 있었기 때문이다 .\n\nDependency Injection은 객체 간의 의존관계를 느슨하게 설정해놓고 Compile Time이 아닌 Runtime에 객체가 의존하고 있는 객체를 생성 후 넣어주는 방식을 의미한다.\n\n\n- 생성자를 이용하는 방식\n\n```java\npublic class House {\n\tprivate Tv tv; //House는 어떤 Tv를 가질지 모른다\n\t\n\tpublic House(Tv tv) {\n\t\tthis.tv = tv; //외부에서 이미 생성된 tv를 주입받는다\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tHouse house = new House(new Tv()); //주입\n\t}\n}\n```\n\n- setter를 이용하는 방식\n\n```java\npublic class House {\n\tprivate Tv tv; //House는 어떤 Tv를 가질지 모른다\n\t\n\tpublic void setTv(Tv tv) {\n\t\tthis.tv = tv; //외부에서 이미 생성된 tv를 주입받는다\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tHouse house = new House();\n\t\thouse.setTv(new Tv()); //주입\n\t}\n}\n```\n\n## 의존성 주입의 장점\n\n1.  A가 B의 변경을 알 필요가 없어진다\n\nTv를 생성할때 리모컨, 버튼, 안테나 등 다양한 요소가 필요하다고 해보자. 의존성이 강할 때 Tv가 변경되면 House도 같이 변경되어야 했다. \n하지만 의존성을 주입하면 Tv가 어떻게 변경되어도 House객체 내의 코드는 수정할 필요가 없어진다. \n\n2.  A를 테스트하기 쉬워진다\n\nA와 B의 의존관계가 느슨해졌기 때문에 A와 B를 독립적으로 테스트 하는 것이 쉬워졌고 \nA에 interface화한 Tv의 여러 구현체를 주입시키는 테스트도 가능해진다. \n\n```java\n@Test  \nvoid test() {  \n    House house1 = new House(new Tv());  \n    House house2 = new House(new SmartTv());  \n}\n```\n\n\n3.  A의 public API가 명시적이게 된다\n\n의존성을 주입하기 전 House의 API를 보자\n```java\npublic class House()\n```\nHouse의 코드를 열어보지 않는 한 House가 Tv를 가지고 있는지 알 길이 없다. \n\n의존성을 주입한다면 \n```java\npublic class House(Tv tv);\n```\n가 될 것이고 House를 사용하고자 하는 다른 개발자들은 누구나 House가 Tv를 의존하는 객체임을 알 수 있다.\n"},{"excerpt":"개인 과제에서 을 적용해 코드를 개선한 기록 Builder Pattern? Effective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다.  Builder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객…","fields":{"slug":"/builder_pattern/"},"frontmatter":{"date":"January 09, 2024","title":"Builder Pattern으로 코드 개선하기","tags":["builder_pattern","java"]},"rawMarkdownBody":"\n개인 과제에서 `Builder Pattern`을 적용해 코드를 개선한 기록\n\n---\n## Builder Pattern?\n\nEffective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다. \n\nBuilder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객체를 생성하는 기법이다. \n\n## Menu\n\n```\npublic class Menu {    \n    private final String name;  \n    private final String description;  \n    private final double price;  \n    private final List<Option> options;\n}\n```\n와 같은 네 개의 멤버 변수를 가진 Menu 클래스를 만드려 한다. \n`name`과 `price`는 필수적으로 포함되어야 하지만 `description`과 `options`는 메뉴에 따라 있을 수도, 없을 수도 있는 선택 매개변수이다.\n\n## 첫 번째 시도, public 생성자\n\n```\npublic Menu(String name, String description, double price, List<Option> options) {\n\tthis.name = name;\n\tthis.description = description;\n\tthis.price = price;\n\tthis.options = options\n}\n```\n가장 기본적인 public 생성자이다. \n얼핏 보면 아무 문제도 없어보이지만 `Menu`를 인스턴스화하며 코드에서 사용하려 해보자\n```\nnew Menu(\"Shack Burger\", \"너무 맛있는 쉑버거\", 6.5, List.of(new   Option(\"Regular\", 0),  \n        new Option(\"Large\", 0.9))\n```\n이 코드는\n\n1.  같은 String타입의 `name`과 `descripton`이 정확한 순서로 쓰여져야 하고\n2.  `description`, `options`가 필요없는 경우를 대처할 수 없기 때문에\n\nMenu를 인스턴스화 할때마다 Menu의 생성자를 매번 확인해야 한다.  \n\n## 두번째 시도 Telescoping Constructor (점층적 생성자) \n\n위의 코드를 조금 개선해보자.\n```\npublic Menu(String name, String description, double price, List<Option> options) {  \n    this.name = name;  \n    this.description = description;  \n    this.price = price;  \n    this.options = new ArrayList<>(options);  \n}  \n  \npublic Menu(String name, double price) {  \n    this(name, \"\", price, new ArrayList<>());  \n}  \n  \npublic Menu(String name, String description, double price) {  \n    this(name, description, price, new ArrayList<>());  \n}\n\npublic Menu(String name, double price, List<Options> options) {\n\tthis(name, \"\", price, options);\n}\n```\n\n점층적 생성자를 이용해 `description`, `options`모두 없는 경우, 하나만 없는 경우의 조합을 상정하고 순서대로 `this()`를 호출하며 생성시 주어지지 않은 파라미터는 default 값을 이용하도록 해보았다.\n\n점층적 생성자를 이용해 이제 \n\n```\nnew Menu(\"Burger\", 1000)\n```\n\n위와 같은 Menu의 생성도 가능해지게 되었다.\n\n하지만 점층적 생성자 또한\n\n1. 순서를 기억하기 어렵고, \n2. Menu가 더 많은 파라미터를 요구하게 될 시의 조합을 가진 생성자를 더 생성해야 하기 때문에\n\n유지보수가 어렵다는 문제가 여전히 남아 있다. \n\n## 세번째 시도, Builder Pattern\n\n이러한 Menu 클래스를 Builder Pattern을 이용하여 리팩토링 해보았다.\n```\npublic static class Builder {  \n  \n    private final String name;  \n    private final double price;  \n  \n    private String description = \"\";  \n    private List<Option> options = new ArrayList<>();  \n  \n    public Builder(String name, double price) {  \n        this.name = name;  \n        this.price = price;  \n    }  \n  \n    public Builder description(String description) {  \n        this.description = description;  \n        return this;    }  \n  \n    public Builder options(List<Option> options) {  \n        this.options = new ArrayList<>(options);  \n        return this;    }  \n  \n    public Menu build() {  \n        return new Menu(this);  \n    }  \n}\n\nprivate Menu(Builder builder) {  \n    this.name = builder.name;  \n    this.description = builder.description;  \n    this.price = builder.price;  \n    this.options = builder.options;  \n}\n```\n\nMenu 클래스 생성자의 접근제어자를 `private`으로 두고 내부 클래스로 Builder를 만들었다.  `private`생성자는 `Builder`가 가져다준 매개변수를 저장한다. \n\nBuilder는 기본적으로 필수적인 매개변수인 `name`과 `price`를 생성자의 파라미터로 받고 선택적인 매개변수인 `description` 과 `options`를 초기화를 해주었다.\n\n필수 매개변수만 받고 나머지는 메서드 체이닝을 통해 setter와 같은 역할을 하며 마지막으로 `build()`메서드로만 Menu를 인스턴스화 할 수 있게 했다. \n\n이를 통해 \n```\nnew Menu.Builder(\"Shack Burger\", 6.5)  \n        .description(\"너무 맛있는 쉑버거\")  \n        .options(List.of(new Option(\"Single\", 0),  \n                new Option(\"Double\", 3.6)))  \n        .build()\n```\nMenu를 위와 같이 인스턴스화 할 수 있게 되었다. \n\n그리하여\n1. 생성자에 대한 컨트롤   \n정해진 방식으로만 객체가 생성될 수 있게 했고 \n\n2. 가독성    \n생성자 파라미터에 메서드 명을 붙임으로써 객체 생성시의 실수가 줄어든다. \n같은 타입의 멤버 변수를 파라미터로 받아 들일 시 순서가 헷갈리거나 잘못된 값을 저장할 수 있는 문제도 메서드 명을 지정해야 하므로 방지 할 수 있다.  \n\n3. 확장성  \n메서드를 추가하면 되기 때문에 4개 그 이상의 파라미터 확장 혹은 파라미터에 대한 검증 추가에 더 유연하게 대처할 수 있다 \n\n## 내가 느낀 Builder Pattern의 단점\n\n빌더 패턴을 사용하며 느낀 단점은\n\n1.  바로바로 생성할 수 있는 public 생성자와 달리 코드를 작성하는데 비용이 든다.\n2.  매개변수가 적은 경우 오히려 객체가 무거워진다 \n\n정도다. 하지만 테스트 코드 작성같이 다른 객체에서 Menu를 인스턴스화 할때 객체 생성에 실수가 줄어들고 이미 생성하고 있는 Menu 코드에 새로운 option을 추가한다거나 설명을 바꿀 때 편리함을 느껴서 매개변수가 많을 때는 Builder Pattern을 많이 사용할 것 같다."},{"excerpt":"'모든 개발자를 위한 HTTP'강의를 수강한 학습 기록 캐시란? 컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다\nCPU에서 캐시메모리는 CPU, 메모리 사이에 위치하여 자주 쓰이는 데이터를 임시로 저장하여 둘 사이의 거리에 따른 접근시간을 줄이는데 사용된다.  캐시는 다양한 종류가 있지만 웹에서의 캐시도 CPU의 캐시 메모리와 비슷하…","fields":{"slug":"/http_cache/"},"frontmatter":{"date":"January 03, 2024","title":"웹 서비스 캐시","tags":["http","cache"]},"rawMarkdownBody":"\n'모든 개발자를 위한 HTTP'강의를 수강한 학습 기록\n\n## 캐시란?\n\n컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다\nCPU에서 캐시메모리는 CPU, 메모리 사이에 위치하여 자주 쓰이는 데이터를 임시로 저장하여 둘 사이의 거리에 따른 접근시간을 줄이는데 사용된다. \n\n캐시는 다양한 종류가 있지만 웹에서의 캐시도 CPU의 캐시 메모리와 비슷하게 `자주 쓰이는 데이터를 가까운 곳에 저장하여 데이터 접근 시간을 줄인다` 는 원리를 가진다.\n\n## 웹 브라우저 캐시\n\n클라이언트에서 서버에 요청하여 10mb의 코끼리 이미지를 다운로드 받는다고 생각해보자.    \n\n캐시가 없다면 첫번째 요청에서는 10mb의 데이터를 전송받아야하지만 같은 사이트에 몇번이고 방문한다면 여러번의 요청마다 10mb의 데이터를 매번 다운로드 받아야 한다. 이러면 웹페이지의 로딩 속도는 매우 느려지고 좋지 않은 사용자 경험을 선사한다.\n\n반면 웹 브라우저를 사용하는 사용자의 로컬 환경에 캐시데이터를 저장하고 사용자가 같은 요청(코끼리 그림을 브라우저에 그려주세요)을 할 때는 서버에서 다운로드를 다시 받지 않고 캐시데이터를 바로 사용한다면 웹 페이지의 로딩 속도는 비약적으로 상승할 것이다. \n\n### 웹 브라우저 캐시 적용\n\n웹 브라우저에서 서버로 코끼리 그림을 최초로 요청하면 서버는 이에 대해`cache-control: max-age` 헤더를 포함한 응답을 준다.\n\n간단한 응답예시\n```\nHTTP/1.1 200 OK\nContent-Type:image/jpeg\nCache-Control: max-age=60\nContent-Length: 10295\n\n//\n{elephant image data}\n//\n```\n\n이때 `max-age` 에 해당하는 숫자는 이 캐시가 유효한 초단위를 의미한다.\n\n즉 이 코끼리 그림은 로컬의 캐시 저장소에서 60초간 유효하며 이 시간안에 클라이언트가 코끼리 그림을 다시 요청하면 서버에서 다시 코끼리 그림 데이터를 다운받는 게 아니라 캐시 저장소에 있는 복사된 데이터를 브라우저에서 렌더링 하게 되는 것이다.\n\n### 캐시 유효기간 \n\n당연히 캐시 유효기간이 지난 데이터의 경우 서버에 재요청을 하여 다시 다운로드 받아야 한다. 이 때 유효기간이 지난 캐시를 Stale하다라고 표현한다.    \n\n하지만 캐시 유효 기간이 지났지만 서버의 원본 데이터가 변경되지 않은 경우, 같은 데이터인데도 다시 다운로드 받아야 하면 이는 굉장히 비효율적이다. 이를 위해 캐시와 원본이 같은 데이터인지 검증하고, 같은 데이터라면 캐시를 사용하는 절차가 필요하다.\n\n## 캐시 유효성검증(Validation)과 조건부 요청(Conditional Request)\n\n캐시 데이터가 원본 데이터와 같은지 검증하기 위해 크게 두가지 방법을 사용한다\n\n### Last-Modified / If-Modified-Since\n\n첫 번재 방법은 원본 데이터가 마지막으로 수정된 시간을 응답 메시지 헤더로 추가하는 방법이다. \n\n```\nHTTP/1.1 200 OK\nContent-Type:image/jpeg\nCache-Control: max-age=60\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added\nContent-Length: 10295\n\n//\n{elephant image data}\n//\n```\n이제 캐시 저장소에 코끼리 그림과 이 원본 데이터가 마지막으로 수정된 시각까지 저장을 하게 된다. 이제 클라이언트는 요청을 할때 \n```\nGET /elephant.jpg\nif-modified-since: Wed, 21 Oct 2015 07:28:00 GMT\n```\n'이 이후로 원본이 수정되었으면' 이라는  조건부 요청을 보내고 서버에서는 이러한 조건부 요청에 따라    \n조건이 만족하면(수정 되었으면) 200 OK로 다시 10mb의 코끼리 그림을 전송하고 조건을 불만족하면(수정 되지 않았다면 )\n```\nHTTP/1.1 304 Not Modified\nContent-Type:image/jpeg\nCache-Control: max-age=60\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added\nContent-Length: 10295\n\n//\n\n//\n```\n10mb의 message body가 생략된 304 Not Modified의 응답 메시지를 보낸다. \n\n위 방법은 합리적으로 보이지만 단점도 가지고 있다\n1. 1초 미만 단위로 캐시 조정이 불가능하고\n2.  A->B->A 처럼 원본데이터가 수정되었지만 수정 전과 같은 데이터 일때\n3. 스페이스, 주석 변경처럼 크게 영향이 없는 경우\n에도 모두 재다운로드가 발생하기 때문이다.\n\n\n### ETag / If-None-Match\n\n\n위의 단점을 보완하고 캐시 로직을 서버에서 관리하고 싶을 때 ETag(Entity Tag)를 이용하게 된다 .\nETag는 각각의 캐시될 원본 데이터에 해쉬코드를 달아준다고 생각하면 된다. 데이터가 변경되고 이 데이터가 클라이언트에서 다시 다운로드 받아야 된다고 판단될 때 ETag를 변경해주면 된다. \n\n서버는 최초 응답 메시지에 코끼리 데이터와 함께 ETag를 제공한다.\n```\nHTTP/1.1 200 OK\nContent-Type:image/jpeg\nCache-Control: max-age=60\nETag: \"aaaaaaa\" //added\nContent-Length: 10295\n\n//\n{elephant image data}\n//\n```\n캐시 저장소는 이제 코끼리 그림 데이터를 ETag와 함께 저장하고 \n\n재요청시 조건부 요청을 보내게 된다.\n```\nGET /elephant.jpg\nif-none-match: \"aaaaaaa\"\n```\n위와 마찬가지로 조건을 불만족하면(수정 되지 않았다면 ) 서버는 304 상태코드와 메시지 바디가 없는 응답 메시지를 보내고 클라이언트는 캐시 저장소에 있는 코끼리 그림을 웹 브라우저에 렌더링한다.\n\n## 캐시 지시어\n\n캐시를 제어하는 방법은 위의 방법만 있는 게 아니다. 항상 최신이 되어야 하는 데이터나 개인정보 처럼 캐시를 해서는 안되는 데이터도 있기 때문이다.\n\nCache-directive(캐시 지시어)로 해당 데이터의 캐시가 어떻게 적용될지 설정할 수 있다. \n\n###  Cache-Control: no-cache\n\n데이터를 캐시해도 되지만 항상 Origin서버에 검증하고 사용되어야 하는 데이터다. 즉, 항상 최신의 데이터를 가지게 하고 싶을 때 사용한다\n\n### Cache-Control: no-store\n\n민감한 정보가 포함된 데이터이므로 캐시해서는 안된다.\n\n### Cache-Control: must-revalidate\n\n캐시 만료 후 최초조회시 Origin서버에 검증해야한다\nOrigin 서버 접근 실패시 반드시 오류가 발생해야한다.\n\n### Cache-Control: public\n\n응답이 public 캐시에 저장되어도 된다 (프록시 서버에 저장되어도 된다)\n\n### Cache-Control: private\n\n응답이 해당 사용자 만을 위한 것 private 캐시에 저장해야함(기본값)\n\n"},{"excerpt":"'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB Process Control Block 모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.…","fields":{"slug":"/process_thread/"},"frontmatter":{"date":"December 28, 2023","title":"프로세스와 스레드","tags":["process","thread","operating_system"]},"rawMarkdownBody":"\n'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용\n## 프로세스 \n\n### Process? Program?   \n우리는 흔히 `프로그램을 실행한다` 라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 `프로그램`을  '메모리에 적재하고 cpu가 실행'하여 `프로세스`화 한다와 같은 말이다. \n\n### PCB Process Control Block    \n모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.\n그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 `PCB`라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.\n\n>[PCB에 저장되는 정보]   \n>PID(Process ID) : 프로세스 고유의 번호\n>Registers: 레지스터의 중간값   \n>Process state: 대기,준비, 실행 등의 프로세스 상태  \n>CPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보   \n>Memory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블    \n>List of Open files : 입출력장치 정보\n\n### 이 PCB로 어떻게 관리하나?\nCPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. \n\n이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. \n\n이 중간 정보는 `문맥Context`으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 `문맥 교환 Context Switching` 이라고 한다. \n(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)\n\n>[동시에 실행되는 것 '처럼' 보인다]   \n>프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.   \n>정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.\n\n## 프로세스의 구성\n\n`정적 할당 영역`   \n코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only\n\n데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터 \nex) 전역변수, 상수\n\n`동적 할당 영역`   \n힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간 \nex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) \n\n스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터 \nex)매개변수, 지역변수 \n\n*즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다*\n\n## 프로세스의 상태\n\n프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다. \n입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다. \n그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. \n\n- 생성 상태(new)\n- 준비 상태(ready)\n- 대기상태(blocked) \n- 실행상태(running)\n- 종료상태(terminated)\n\n`준비상태 vs 대기상태`   \n준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다. \n준비상태에서 실행상태가 되는 것을 **dispatch**라고 한다 \n\n대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 **준비상태**가 된다. \n\n## 스레드\n\n### 프로세스와 스레드\n\n스레드는 `프로세스를 구성하는 실행 단위`를 의미한다 \n스레드는 **프로세스의 자원**을 공유하며 여러개가 존재 할 수 있다. \n스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. \n\n### 멀티스레드\n\n멀티프로세스와 비슷하게 스레드 또한 문맥교환을 하며 동시성을 가지고 처리된다. \n\n멀티스레드는 한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.\n\n하지만 자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다\n\n### 프로세스와 스레드의 동기화 문제 \n\n```java\npublic class Calculator {  \n    static int count = 0;  \n  \n    public static void main(String[] args) {  \n        int max = 10;  \n  \n        for (int i = 0; i < maxCount; i++) {  \n            new Thread(() -> {  \n                count++;  \n                System.out.println(count);  \n            }).start();  \n        }  \n    }  \n}\n```\n위 코드는 얼핏 보면 문제가 없어보이지만 \n```\n1\n3\n4\n2\n5\n6\n```\n실행결과는 뒤죽박죽인채로 나온다.   \n이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 때 이 멀티 스레드는 '`Synchronization Issue`를 가진다'라고 한다.\n\n### 프로세스 동기화 문제? 스레드 동기화 문제?\n\n둘 다 동기화 문제를 가질 수 있다.   \n위 예시에서는 스레드의 동기화를 사용했지만 `실행의 흐름`을 가지는 모든 것들이 동기화 문제를 내재하고 있다.   \n\n예를 들어 `Book.txt`를 쓰는 프로세스 A와 같은 파일을 읽는 프로세스 B가 있다면 두 프로세스가 공유자원에 접근할 수 있다는 것이고 `A->B`의 정해진 순서대로 실행되어야 하기 때문이다. "},{"excerpt":"Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은  과  이다.  처음에는 로 웹사이트를 만들었지만 몇 가지 고치고 싶은…","fields":{"slug":"/gatsby_website/"},"frontmatter":{"date":"December 26, 2023","title":"Gatsby와 Github Pages로 개인 블로그 만들기","tags":["gatsby","github_pages"]},"rawMarkdownBody":"\n## Gatsby로 Github pages 개인 블로그 만들기\n\nTIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 `Jekyll` 과 `Gatsby` 이다. \n\n처음에는 `Jekyll`로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 `Gatsby`로 프레임워크를 바꾸게 되었다.\n\n나는 미리 만들어진 [테마](https://github.com/devHudi/gatsby-starter-hoodie) 를 사용했다.(감사합니다)\n\n## Gatsby 설치 와 웹사이트 설정\n\nGatsby cli를 설치해준다 \n```\nnpm install -g gatsby-cli\n```\n\n`Gatsby Starter Library`에서 마음에 드는 테마를 선택할 수 있다.\n원하는 테마를 고른 뒤\n\n```\nnpx gatsby new {local-folder-name} {theme-name}\n```\n을 실행해 로컬에 Gatsby 템플레이트를  만든다.\n\n```\ncd {local-folder-name}\ngatsby develop\n```\n을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 `http://localhost:8000`이다. \n\n## Github Repository연결\n\nGithub의 새 리포지토리를 생성한다.\n나는 `{username}.github.io`로 이름을 지정했다. \n다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면 \n[Gatsby 공식문서](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/) 를 참고하길 바란다\n\n리포지토리를 생성했다면\n```\ngit remote add origin {github-https-address}\n```\n를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.\n\n그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 \n```\ngit add .\ngit commit -m \"{commit-name}\"\ngit push origin main\n```\n위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.\n\n## 배포 방법 정하기\n\n배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다\n\n1. Netlify\nGithub과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.\n[A Step-by-Step Guide: Gatsby on Netlify](https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/) 공식문서\n2. Github pages\nGithub pages에서 제공하는 `gh-pages`를 이용하여 배포할 수 있다\n[How Gatsby Works with GitHub Pages](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/)공식 문서\n\n나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 `{smt}.netflify.app`를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 `{smt}.github.io` 도메인이 마음에 들어서다(...)\n\n\n## Github Pages로 배포하기 \n\n배포용 브랜치 설정\ngh-pages는 배포용 브랜치가 따로 있어야 한다.   \n우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 `.gitignore`에서 public을 푸쉬하지 않게 설정되어 있다.\n\n현 상태에서 배포용 브랜치를 하나 만들어 둔다.\n```\ngit branch deploy\n```\n\n이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다. \n`gh-pages`패키지를 설치하자.\n\n```\nnpm install gh-pages\n```\n\n>[Trouble Shooting]   \n나는 npm install 과중에서 dependency conflict가 발생했다.   \nnode 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다\n\n>-> 위의 install 커맨드에 `--force` 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 `--legacy-peer-deps`로 자동설치를 막는 방법이 있다. 나는 `--force`로 설치했다.\n\n\n다음은 `package.json` 에 배포에 사용할 스크립트를 추가해주면 된다.\n```\n\"scripts\": {\n    \"deploy\": \"gatsby build && gh-pages -d public -b deploy\"\n}\n```\n\n그리고\n```\nnpm run deploy \n```\n를 실행한다.   \n   \n>[Trouble Shooting]   \n>위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 `npm run clean`으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.\n\n이후\nGithub repository의 Settings-Pages\n`Build and deployment`에서 배포용 브랜치로 전환해준다.\n\n이렇게 까지 하면 `Actions`에서 웹사이트를 배포해주고 브라우저에서\n```\nhttps://{user-name}.github.io/\n```\n 주소로 접속이 가능해진다. \n\n"},{"excerpt":"정적 팩토리 메서드란? Java에서는   연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에  메서드를 사용하여 인스턴스를 반환 받는 기법이 있다. 간단한 예시로 사용방법을 알아 보자.  이  클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에  를 추가함으로써 인스턴스를 반환 받는 다른  를  생성하는 기법이라고 할 수 있다.  정적팩토리 …","fields":{"slug":"/staticfactorymethod/"},"frontmatter":{"date":"December 24, 2023","title":"정적 팩토리 메서드, 언제 쓸까?","tags":["java","staticfactorymethod"]},"rawMarkdownBody":"## 정적 팩토리 메서드란?\n\nJava에서는 `new`  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 `static` 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.\n\n간단한 예시로 사용방법을 알아 보자. \n```java\nclass Car {  \n    String name;  \n  \n    Car(String name) {   \n        this.name = name;  \n    }  \n}\n```\n\n이 `Car` 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에\n```java\nstatic Car from(String name) {  \n    return new Car(name);  \n}\n```\n\n`정적 팩토리 메서드` 를 추가함으로써 인스턴스를 반환 받는 다른 `통로` 를  생성하는 기법이라고 할 수 있다. \n\n## 정적팩토리 메서드, 왜 쓰나?\n\n`Effective Java`는 1장에서 `생성자 대신 정적 팩토리 메서드를 고려하라` 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 [링크](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)   \n이 포스트에서는 내가  **개인적으로** 언제 이 기법을 사용하는지 서술해 보려고 한다.\n\n### 이름이 있는 것이 나은 경우\n\n위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자\n\n```java\npublic void createCar(String input) {  \n    Car car1 = new Car(input);  \n    Car car2 = Car.from(input);  \n}\n```\n\n위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다. \n`new` 연산자는 `이 Car는 input을 멤버 변수로 가지는군` 이라면\n`from` 은 `이 input은 객체 내에서 특정한 로직으로 변환되겠군` 이라는 멘탈 모델을 제공한다. \n\n`이름을 가질 수 있다` 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.\n\n### 한 가지 방법으로만 객체가 생성되게 하고 싶을 때\n\n우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.\n\n```java\nclass User {  \n    int id;  \n  \n    private User(int id) {  \n        this.id = id;  \n    }  \n  \n    static User from(int id) {  \n        if (isInvalidId(id)) {  \n            return null;  \n        }  \n        return new User(id);  \n    }  \n}\n```\n\n따라서 이 때는 `private` 으로 `new`연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.\n이는 `싱글톤패턴` 의 사용과도 일맥상통한다\n\n### 같은 객체가 여러번 쓰여야할 때\n\n같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에*만*  객체를 생성해 메모리를 아낄 수 있다.\n```java \nclass CarFactory {  \n  \n    static final Map<String, Car> cars = new HashMap<>();  \n  \n    static {  \n        cars.put(\"a\", new Car(\"a\"));  \n        cars.put(\"b\", new Car(\"b\"));  \n        cars.put(\"c\", new Car(\"c\"));  \n    }  \n\t  //if cache doesn't contains key, only then instantiate new car\n    static Car from(String text) {  \n        if (cars.containsKey(text)) {  \n            return cars.get(text);  \n        }  \n        return new Car(text);  \n    }  \n}\n```\n\n\n>[정리]   \n 1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우   \n 2.지정된 경우 이외의 객체 생성을 막고 싶은 경우   \n 3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 \n\n이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.\n\n## private으로 생성자 막기\n\n`Effective Java` 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 `Composition`을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. \n\n```java\nclass CarSet {  \n    private final Map<Car, String> cars;  \n    \n    public CarSet(Map<Car, String> cars) {  \n        this.coins = new HashMap<>(cars);  \n    }  \n  \n    public static CarSet from(String text) {  \n        //Complicated Logic..   \n        //..  \n        return new CarSet(cars);  \n    }  \n}\n```\n하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다\ntext를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 `재사용성` 이 늘어날 수 있기 때문이다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}