{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB Process Control Block 모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.…","fields":{"slug":"/process_thread/"},"frontmatter":{"date":"December 28, 2023","title":"프로세스와 스레드","tags":["process","thread","operating_system"]},"rawMarkdownBody":"\n'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용\n## 프로세스 \n\n### Process? Program?   \n우리는 흔히 `프로그램을 실행한다` 라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 `프로그램`을  '메모리에 적재하고 cpu가 실행'하여 `프로세스`화 한다와 같은 말이다. \n\n### PCB Process Control Block    \n모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.\n그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 `PCB`라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.\n\n>[PCB에 저장되는 정보]   \n>PID(Process ID) : 프로세스 고유의 번호\n>Registers: 레지스터의 중간값   \n>Process state: 대기,준비, 실행 등의 프로세스 상태  \n>CPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보   \n>Memory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블    \n>List of Open files : 입출력장치 정보\n\n### 이 PCB로 어떻게 관리하나?\nCPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. \n\n이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. \n\n이 중간 정보는 `문맥Context`으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 `문맥 교환 Context Switching` 이라고 한다. \n(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)\n\n>[동시에 실행되는 것 '처럼' 보인다]   \n>프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.   \n>정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.\n\n## 프로세스의 구성\n\n`정적 할당 영역`   \n코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only\n\n데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터 \nex) 전역변수, 상수\n\n`동적 할당 영역`   \n힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간 \nex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) \n\n스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터 \nex)매개변수, 지역변수 \n\n*즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다*\n\n## 프로세스의 상태\n\n프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다. \n입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다. \n그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. \n\n- 생성 상태(new)\n- 준비 상태(ready)\n- 대기상태(blocked) \n- 실행상태(running)\n- 종료상태(terminated)\n\n`준비상태 vs 대기상태`   \n준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다. \n준비상태에서 실행상태가 되는 것을 **dispatch**라고 한다 \n\n대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 **준비상태**가 된다. \n\n## 스레드\n\n### 프로세스와 스레드\n\n스레드는 `프로세스를 구성하는 실행 단위`를 의미한다 \n스레드는 **프로세스의 자원**을 공유하며 여러개가 존재 할 수 있다. \n스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. \n\n### 멀티스레드\n\n멀티프로세스와 비슷하게 스레드 또한 문맥교환을 하며 동시성을 가지고 처리된다. \n\n멀티스레드는 한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.\n\n하지만 자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다\n\n### 프로세스와 스레드의 동기화 문제 \n\n```java\npublic class Calculator {  \n    static int count = 0;  \n  \n    public static void main(String[] args) {  \n        int max = 10;  \n  \n        for (int i = 0; i < maxCount; i++) {  \n            new Thread(() -> {  \n                count++;  \n                System.out.println(count);  \n            }).start();  \n        }  \n    }  \n}\n```\n위 코드는 얼핏 보면 문제가 없어보이지만 \n```\n1\n3\n4\n2\n5\n6\n```\n실행결과는 뒤죽박죽인채로 나온다.   \n이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 때 이 멀티 스레드는 '`Synchronization Issue`를 가진다'라고 한다.\n\n### 프로세스 동기화 문제? 스레드 동기화 문제?\n\n둘 다 동기화 문제를 가질 수 있다.   \n위 예시에서는 스레드의 동기화를 사용했지만 `실행의 흐름`을 가지는 모든 것들이 동기화 문제를 내재하고 있다.   \n\n예를 들어 `Book.txt`를 쓰는 프로세스 A와 같은 파일을 읽는 프로세스 B가 있다면 두 프로세스가 공유자원에 접근할 수 있다는 것이고 `A->B`의 정해진 순서대로 실행되어야 하기 때문이다. "},{"excerpt":"Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은  과  이다.  처음에는 로 웹사이트를 만들었지만 몇 가지 고치고 싶은…","fields":{"slug":"/gatsby_website/"},"frontmatter":{"date":"December 26, 2023","title":"Gatsby와 Github Pages로 개인 블로그 만들기","tags":["gatsby","github_pages"]},"rawMarkdownBody":"\n## Gatsby로 Github pages 개인 블로그 만들기\n\nTIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 `Jekyll` 과 `Gatsby` 이다. \n\n처음에는 `Jekyll`로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 `Gatsby`로 프레임워크를 바꾸게 되었다.\n\n나는 미리 만들어진 [테마](https://github.com/devHudi/gatsby-starter-hoodie) 를 사용했다.(감사합니다)\n\n## Gatsby 설치 와 웹사이트 설정\n\nGatsby cli를 설치해준다 \n```\nnpm install -g gatsby-cli\n```\n\n`Gatsby Starter Library`에서 마음에 드는 테마를 선택할 수 있다.\n원하는 테마를 고른 뒤\n\n```\nnpx gatsby new {local-folder-name} {theme-name}\n```\n을 실행해 로컬에 Gatsby 템플레이트를  만든다.\n\n```\ncd {local-folder-name}\ngatsby develop\n```\n을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 `http://localhost:8000`이다. \n\n## Github Repository연결\n\nGithub의 새 리포지토리를 생성한다.\n나는 `{username}.github.io`로 이름을 지정했다. \n다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면 \n[Gatsby 공식문서](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/) 를 참고하길 바란다\n\n리포지토리를 생성했다면\n```\ngit remote add origin {github-https-address}\n```\n를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.\n\n그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 \n```\ngit add .\ngit commit -m \"{commit-name}\"\ngit push origin main\n```\n위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.\n\n## 배포 방법 정하기\n\n배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다\n\n1. Netlify\nGithub과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.\n[A Step-by-Step Guide: Gatsby on Netlify](https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/) 공식문서\n2. Github pages\nGithub pages에서 제공하는 `gh-pages`를 이용하여 배포할 수 있다\n[How Gatsby Works with GitHub Pages](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/)공식 문서\n\n나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 `{smt}.netflify.app`를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 `{smt}.github.io` 도메인이 마음에 들어서다(...)\n\n\n## Github Pages로 배포하기 \n\n배포용 브랜치 설정\ngh-pages는 배포용 브랜치가 따로 있어야 한다.   \n우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 `.gitignore`에서 public을 푸쉬하지 않게 설정되어 있다.\n\n현 상태에서 배포용 브랜치를 하나 만들어 둔다.\n```\ngit branch deploy\n```\n\n이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다. \n`gh-pages`패키지를 설치하자.\n\n```\nnpm install gh-pages\n```\n\n>[Trouble Shooting]   \n나는 npm install 과중에서 dependency conflict가 발생했다.   \nnode 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다\n\n>-> 위의 install 커맨드에 `--force` 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 `--legacy-peer-deps`로 자동설치를 막는 방법이 있다. 나는 `--force`로 설치했다.\n\n\n다음은 `package.json` 에 배포에 사용할 스크립트를 추가해주면 된다.\n```\n\"scripts\": {\n    \"deploy\": \"gatsby build && gh-pages -d public -b deploy\"\n}\n```\n\n그리고\n```\nnpm run deploy \n```\n를 실행한다.   \n   \n>[Trouble Shooting]   \n>위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 `npm run clean`으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.\n\n이후\nGithub repository의 Settings-Pages\n`Build and deployment`에서 배포용 브랜치로 전환해준다.\n\n이렇게 까지 하면 `Actions`에서 웹사이트를 배포해주고 브라우저에서\n```\nhttps://{user-name}.github.io/\n```\n 주소로 접속이 가능해진다. \n\n"},{"excerpt":"정적 팩토리 메서드란? Java에서는   연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에  메서드를 사용하여 인스턴스를 반환 받는 기법이 있다. 간단한 예시로 사용방법을 알아 보자.  이  클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에  를 추가함으로써 인스턴스를 반환 받는 다른  를  생성하는 기법이라고 할 수 있다.  정적팩토리 …","fields":{"slug":"/staticfactorymethod/"},"frontmatter":{"date":"December 24, 2023","title":"정적 팩토리 메서드, 언제 쓸까?","tags":["java","staticfactorymethod"]},"rawMarkdownBody":"## 정적 팩토리 메서드란?\n\nJava에서는 `new`  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 `static` 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.\n\n간단한 예시로 사용방법을 알아 보자. \n```java\nclass Car {  \n    String name;  \n  \n    Car(String name) {   \n        this.name = name;  \n    }  \n}\n```\n\n이 `Car` 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에\n```java\nstatic Car from(String name) {  \n    return new Car(name);  \n}\n```\n\n`정적 팩토리 메서드` 를 추가함으로써 인스턴스를 반환 받는 다른 `통로` 를  생성하는 기법이라고 할 수 있다. \n\n## 정적팩토리 메서드, 왜 쓰나?\n\n`Effective Java`는 1장에서 `생성자 대신 정적 팩토리 메서드를 고려하라` 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 [링크](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)   \n이 포스트에서는 내가  **개인적으로** 언제 이 기법을 사용하는지 서술해 보려고 한다.\n\n### 이름이 있는 것이 나은 경우\n\n위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자\n\n```java\npublic void createCar(String input) {  \n    Car car1 = new Car(input);  \n    Car car2 = Car.from(input);  \n}\n```\n\n위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다. \n`new` 연산자는 `이 Car는 input을 멤버 변수로 가지는군` 이라면\n`from` 은 `이 input은 객체 내에서 특정한 로직으로 변환되겠군` 이라는 멘탈 모델을 제공한다. \n\n`이름을 가질 수 있다` 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.\n\n### 한 가지 방법으로만 객체가 생성되게 하고 싶을 때\n\n우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.\n\n```java\nclass User {  \n    int id;  \n  \n    private User(int id) {  \n        this.id = id;  \n    }  \n  \n    static User from(int id) {  \n        if (isInvalidId(id)) {  \n            return null;  \n        }  \n        return new User(id);  \n    }  \n}\n```\n\n따라서 이 때는 `private` 으로 `new`연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.\n이는 `싱글톤패턴` 의 사용과도 일맥상통한다\n\n### 같은 객체가 여러번 쓰여야할 때\n\n같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에*만*  객체를 생성해 메모리를 아낄 수 있다.\n```java \nclass CarFactory {  \n  \n    static final Map<String, Car> cars = new HashMap<>();  \n  \n    static {  \n        cars.put(\"a\", new Car(\"a\"));  \n        cars.put(\"b\", new Car(\"b\"));  \n        cars.put(\"c\", new Car(\"c\"));  \n    }  \n\t  //if cache doesn't contains key, only then instantiate new car\n    static Car from(String text) {  \n        if (cars.containsKey(text)) {  \n            return cars.get(text);  \n        }  \n        return new Car(text);  \n    }  \n}\n```\n\n\n>[정리]   \n 1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우   \n 2.지정된 경우 이외의 객체 생성을 막고 싶은 경우   \n 3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 \n\n이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.\n\n## private으로 생성자 막기\n\n`Effective Java` 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 `Composition`을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. \n\n```java\nclass CarSet {  \n    private final Map<Car, String> cars;  \n    \n    public CarSet(Map<Car, String> cars) {  \n        this.coins = new HashMap<>(cars);  \n    }  \n  \n    public static CarSet from(String text) {  \n        //Complicated Logic..   \n        //..  \n        return new CarSet(cars);  \n    }  \n}\n```\n하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다\ntext를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 `재사용성` 이 늘어날 수 있기 때문이다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}