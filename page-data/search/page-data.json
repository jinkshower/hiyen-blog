{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"팀 프로젝트를 진행하면서 Github Actions를 통해 테스트 자동화 환경을 구축한 기록 코드 보러가기 학습 계기 팀프로젝트를 진행하면서 팀원들끼리 테스트 코드를 작성했지만, 이를 PR에서 확인할 수 있는 방법이 없었다.  물론 팀원들을 믿고 있지만,  나조차도 급할때는 테스트를 돌리는 걸 까먹고 push를 한 기억도 있기 때문이다..  Github …","fields":{"slug":"/githubaction_automated_test/"},"frontmatter":{"date":"March 01, 2024","title":"Github Actions 를 통한 테스트 자동화 구축","tags":["ci/cd","githubactions"]},"rawMarkdownBody":"\n\n팀 프로젝트를 진행하면서 Github Actions를 통해 테스트 자동화 환경을 구축한 기록\n\n[코드](https://github.com/jinkshower/please-praise) 보러가기\n\n## 학습 계기\n\n팀프로젝트를 진행하면서 팀원들끼리 테스트 코드를 작성했지만, 이를 PR에서 확인할 수 있는 방법이 없었다. \n\n물론 팀원들을 믿고 있지만,  나조차도 급할때는 테스트를 돌리는 걸 까먹고 push를 한 기억도 있기 때문이다.. \n\nGithub Actions를 통하면 PR마다 혹은 push마다 테스트를 자동화할 수 있는 workflow를 설정할 수 있다.\n\n## 테스트 자동화의 필요성\n\n`제 로컬에서는 잘 돌아가는데요..?`\n\n1. 환경 일관성 보장\n각자의 로컬이 아닌 독립된 (Github Actions의 경우 Runner 서버) 환경에서 테스트가 실행되기 때문에 환경 관련 문제를 사전에 감지 할 수 있다.\n즉, 배포 환경에 맞는 빌드/테스트 환경을 구축하는데 큰 도움이 된다\n\n2. 커밋 이후 안전성 확인 가능\n위에서도 말했지만 PR에 `테스트 다 통과해요~` 라는 말로는 PR에 올라온 코드는 믿을 수 없다. 독립된 환경에서 모든 테스트가 통과하는 코드라면, 안심하고 Approve를 누를 수 있게 도와준다. \n\n3. 테스트 실패를 팀 모두가 알 수 있음\n테스트 자동화 환경이 구축된 협업에서는 참여하는 모두가 테스트 실패시 에러로그를 공유할 수 있기 때문에 디버깅을 모두가 빠르게 할 수 있고, 공통적인 문제점을 캐치하기 쉬워진다. \n\n## Github Workflow 파일 작성\n\n.github/workflows/{name}.yml로 workflow 설정 파일을 추가해줬다.\n\n```yml\nname: PR Test  \n  \non:  \n  pull_request:  \n    branches: [ dev ]  \n  \njobs:  \n  test:  \n    runs-on: ubuntu-latest  \n    steps:  \n      - name: Set up JDK 17  \n        uses: actions/setup-java@v1  \n        with:  \n          java-version: 17    \n  \n      - name: Grant execute permission for gradlew  \n        run: chmod +x gradlew  \n  \n      - name: Test with Gradle  \n        run: ./gradlew --info test  \n  \n      - name: Publish Unit Test Results  \n        uses: EnricoMi/publish-unit-test-result-action@v1  \n        if: ${{ always() }}  \n        with:  \n          files: build/test-results/**/*.xml\n```\n\n한 부분씩 살펴보도록 하자.\n\n`Set up JDK 17`\n\nRunner 서버에 JDK를 설치한다. \n\n`Grant execute permission for gradlew`\n\n명령어를 통해 gradlew 스크립트에 대한 실행권한을 부여한다.\n\n`Test with Gradle`\n\n실행 권한을 받아 테스트를 실행한다\n\n`Publish Unit Test Results`\n\n다른 사람이 만든 workflow설정도 쓸 수 있다. [링크](https://github.com/EnricoMi/publish-unit-test-result-action)\n테스트 결과를 읽기 쉬운 로그로 게시해준다. \n\n하지만... \n![Pasted image 20240219161225](https://github.com/jinkshower/jinkshower.github.io/assets/135244018/1f76a31c-2e77-4ce2-bf41-818fdf1fda07)\n\n## Fail to load ApplicationContext\n\n앞에서도 말했듯이 Github Actions는 별개의 Runner서버에서 실행되기 때문에 로컬에서만 적용되는 환경설정은 오류가 발생한다\n\n나의 경우 설정 파일에 JWT 시크릿 키나 관리자 토큰 값이 있었기 때문에 기본적으로 .gitignore에 설정파일을 추가하고 팀원들도 마찬가지로 각자 로컬환경에서 설정파일을 작성했기 때문에 해당 값을 가져다 쓰는 빈을 생성하는데 문제가 발생했다.\n\n가장 빠른 해결 방법은 물론 설정파일을 깃에 업로드하는 거지만, AWS 키와 같은 절대 공개되어서는 안\n되는 정보는 깃에 올릴 수 없다.\n\n이에 대한 해결방법으로 \nGithub Secrets에 모든 설정을 등록하고 workflow에서 직접 설정파일을 작성하는 job을 추가하는 방법을 찾아봤지만 value를 암호화해야하고, 수정할때마다 secret을 삭제, 추가하는 일이 너무 번거로워 보였다.\n\n## Git Submodule로 설정파일 관리하기\n\nGit Submodule를 이용하면 리포지토리 안에 다른 리포지토리를 분리해서 넣어서 사용할 수 있다고 한다.\n\n별도의 private repository에 설정에 필요한 파일을 두고 메인 리포지토리에서 이를 연동해 사용한다면 팀원들과 설정을 공유하기도 쉽고 이를 workflow에서 사용할 수도 있다.\n\nprivate repository에 설정파일을 업로드 한 후 메인 리포지토리의 깃에서 \n`git submodule add {private-repository-url} config`\n를 입력해 서브모듈 리포지토리를 등록해준다.\n\n>[config]\n>\n>스프링은 설정파일을 가장 먼저 `src/main/resources`에서 찾지만 해당 디렉토리에 설정파일이 없을 경우 `config`디렉토리를 찾아서 적용하기 때문이다. \n>\n>나는 설정파일은 깃에 업로드하고 있지 않기 때문에 서브모듈에서 가져올 설정파일을 `config` 경로에 연동했다. \n\n>[서브모듈 최신화]\n>\n>서브 모듈은 커밋 후 푸시를 해도 메인 리포지토리에서 자동으로 추적하여 업데이트 하지 않는다.\n>\n>메인 리포지토리에서 서브모듈의 commit hash값만 참고하는 방식이기 때문에 서브모듈을 업데이트 했다면 `git submodule update --remote`로 최신화 해줘야 한다\n\n.gitmodules 파일에 서브모듈 경로가 잘 적용된 것을 확인했다면 workflow에 해당 서브모듈을 연동함을 명시해 줘야 한다. \nsecrets에 다른 리포지토리 접근을 허용하는 access token을 추가한 후\n\nworkflow 파일에 해당 작업을 추가해줬다.\n```yml\n- name: Checkout  \n  uses: actions/checkout@v2  \n  with:  \n    token: ${{ secrets.ACTION_TOKEN }}  \n    submodules: true\n```\n\n## 마치며\n\n![Pasted image 20240301233610](https://github.com/jinkshower/jinkshower.github.io/assets/135244018/701cd629-2d9a-4185-8157-803e3696b32c)\n\n이렇게 여러 시간의 시도를 통해 PR마다 테스트를 자동화해주었다.\n\n테스트 실패시 PR에 실패한 라인에 코멘트를 달아주는 workflow, 빌드/테스트 실패시 slack에 알림을 보내는 workflow도 있으니 각자의 협업 방식에 맞는 workflow를 추가해주면 된다! \n\n*틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다*\n\n"},{"excerpt":"인수테스트 에서 이어지는 글입니다. Slice Test Slice Test는 레이어별로 잘라서 레이어를 하나의 단위로 보는 테스트이다. 왜 Slice Test를 해야 하는가? 개별 레이어의 검증\nSlice Test를 통해 각 레이어를 독립적으로 테스트할 수 있다. \n즉, 테스트가 깨진다면 어디를 고쳐야할 지에 대해 빠른 피드백을 받을 수 있다. 레이어간 …","fields":{"slug":"/sprint_test_strategy/"},"frontmatter":{"date":"February 25, 2024","title":"Slice Test","tags":["spring","slicetest","testing"]},"rawMarkdownBody":"\n\n[인수테스트](https://jinkshower.github.io/acceptance_test/) 에서 이어지는 글입니다.\n\n## Slice Test\n\nSlice Test는 레이어별로 잘라서 레이어를 하나의 단위로 보는 테스트이다.\n\n### 왜 Slice Test를 해야 하는가? \n\n1. 개별 레이어의 검증\nSlice Test를 통해 각 레이어를 독립적으로 테스트할 수 있다. \n즉, 테스트가 깨진다면 어디를 고쳐야할 지에 대해 빠른 피드백을 받을 수 있다.\n\n2. 레이어간 의존성을 낮추는 리팩토링을 유도한다\n`단위 테스트`를 하다 보면 테스트하기 어려운 메인코드들이 존재한다. \n나의 경우는 다른 객체에 과도하게 의존하고 있는 메인코드들에서 테스트를 하기 어렵다는 느낌을 받은 경험이 많은데, 이를 spring의 레이어들에도 적용할 수 있다.\n\n3. @SpringBootTest는 무겁다\n인수테스트 글에서도 언급했지만 @SpringBootTest는 모든 Bean을 로드하기 때문에 속도가 느리다. \n\n이러한 이유에서 Slice Test를 개인 과제에서 적용한 기록을 적어보고자 한다.\n\n## @WebMvcTest\n\n@WebMvcTest는 웹 레이어 테스트를 하는데 필요한 빈들만 로드한다.\n즉, @Service @Repository @Component를 스캔하지 않기 때문에 수동으로 등록해주거나 Mock객체를 만들어서 주입시켜줘야 한다.\n\n작성한 코드 \n```java\n@WebMvcTest(TodoController.class)\n@ActiveProfiles(\"test\")  \n@MockBean(JpaMetamodelMappingContext.class)  \n@Import(ExternalConfig.class)  \npublic class ControllerTest {  \n  \n    @Autowired  \n    protected MockMvc mockMvc;  \n  \n    @Autowired  \n    protected ObjectMapper objectMapper;  \n\n}\n```\n\n`@WebMvcTest(TodoController.class)` \n해당 컨트롤러에 관련된 빈만 로드하게 설정해줬다.\n\n`@MockBean(JpaMetamodelMappingContext.class)`\nTodo 엔티티가 JpaAuditing을 사용하고 있기 때문에  충돌을 방지하기 위하여 로 Mock으로 대체해주었다.\n\n`@Import(ExternalConfig.class)` \n수동으로 등록한 @Component는 앞서 말했듯이 @WebMvcTest에서 컴포넌트 스캔을 하지 않기 때문에  테스트용 클래스에 빈 정보를 등록하고 해당 테스트에서 사용하게 설정해줬다.\n\n해당 클래스를 상속받아 작성한 테스트 중 일부\n```java\n@DisplayName(\"할일 생성 요청\")  \n@Test  \nvoid test1() throws Exception {  \n    //given  \n    given(userRepository.findById(eq(TEST_USER_ID))).willReturn(Optional.of(TEST_USER));  \n  \n    //when  \n    ResultActions action = mockMvc.perform(post(\"/api/todos\")  \n        .contentType(MediaType.APPLICATION_JSON)  \n        .accept(MediaType.APPLICATION_JSON)  \n        .header(JwtUtil.AUTHORIZATION_HEADER, token())  \n        .content(objectMapper.writeValueAsString(TEST_TODO_REQUEST_DTO)));  \n  \n    //then  \n    action.andExpect(status().isCreated());  \n    verify(todoService, times(1))  \n        .saveTodo(any(UserDto.class), any(TodoRequestDto.class));  \n}\n```\n\nBDD mockito를 사용하여 좀 더 가독성을 높이려고 했고, 컨트롤러 레이어만 테스트하기 때문에 service나 repository는 @MockBean으로 선언하여 사용하였다. \n\n## Service Test\n\n작성한 코드\n```java\n@ExtendWith(MockitoExtension.class)  \npublic class TodoServiceTest implements TodoFixture {  \n  \n    @InjectMocks  \n    TodoServiceImpl todoService;  \n  \n    @Mock  \n    TodoRepository todoRepository;  \n  \n    @DisplayName(\"할일 생성\")  \n    @Test  \n    void test1() {  \n        //given  \n        Todo testTodo = TEST_TODO;  \n        given(todoRepository.save(any(Todo.class))).willReturn(testTodo);  \n  \n        //when  \n        TodoResponseDto actual =  \n            todoService.saveTodo(TEST_USER_DTO, TEST_TODO_REQUEST_DTO);  \n  \n        //then  \n        TodoResponseDto expected = new TodoResponseDto(testTodo);  \n        assertThat(actual).isEqualTo(expected);  \n    }\n}\n```\n\n서비스레이어의 비즈니스 로직이 잘 작동하는지가 관건이므로 나머지는 Mock으로 처리해줬다.\n\n`@InjectMocks`\nMock객체들을 해당 객체에 주입하도록 설정해준다.\n\n`@Mock`\n데이터베이스에 저장되었는지는 관심사가 아니므로 가짜 객체를 설정해주었다.\n\n## @DataJpaTest\n\nJpa 관련 컴포넌트를 테스트하는 데 사용되는 어노테이션이다. \n전체 ApplicationContext를 로드하지 않고 DataJpaRepository와 관련된 빈들만을 로드한다.\n\n작성한 테스트\n```java\n@DataJpaTest  \n@ActiveProfiles(\"test\") \npublic class TodoRepositoryTest implements TodoFixture {  \n  \n    @Autowired  \n    TodoRepository todoRepository;  \n  \n    @Autowired  \n    UserRepository userRepository;  \n  \n    @BeforeEach  \n    void setUp() {  \n        userRepository.save(TEST_USER);  \n    }  \n  \n    @DisplayName(\"작성일 내림차순 정렬 조회\")  \n    @Test  \n    void test1() {  \n        //given  \n        Todo testTodo1 =  \n            TodoHelper.get(TEST_TODO, 1L, LocalDateTime.now().minusMinutes(2), TEST_USER);  \n        Todo testTodo2 =  \n            TodoHelper.get(TEST_TODO, 2L, LocalDateTime.now().minusMinutes(1), TEST_USER);  \n        Todo testTodo3 =  \n            TodoHelper.get(TEST_TODO, 3L, LocalDateTime.now(), TEST_USER);  \n        todoRepository.save(testTodo1);  \n        todoRepository.save(testTodo2);  \n        todoRepository.save(testTodo3);  \n  \n        //when  \n        List<Todo> actual = todoRepository.findAllByOrderByCreatedAtDesc();  \n  \n        //then  \n        List<LocalDateTime> times = actual.stream()  \n            .map(Timestamped::getCreatedAt)  \n            .toList();  \n        assertThat(times.get(2)).isBefore(times.get(1));  \n        assertThat(times.get(1)).isBefore(times.get(0));  \n    }  \n}\n```\n\nDataJpa의 기본 CRUD 기능은 라이브러리의 기능으로 간주하고 테스트를 작성하지 않았다.\n커스텀하게 작성한 쿼리메서드를 테스트하는 메서드를 작성해보았다.\n\n@DataJpaTest는 기본적으로 h2 데이터베이스를 사용하게 되어있는데, \n실제 데이터베이스를 사용하려면  `@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)` 을 추가하면 된다. \n\n*틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다*"},{"excerpt":"트랜잭션(Transaction) 트랜잭션은 데이터베이스에서 수행되는 작업의 단위를 나타내며, 더 이상 쪼갤 수 없는 쿼리들의 묶음을 말한다. 트랜잭션은 ACID 특징을 따르며, ACID는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 나타낸다. ACID 특징 1. 원자성(Atomic…","fields":{"slug":"/transaction/"},"frontmatter":{"date":"February 21, 2024","title":"Transaction","tags":["database","transaction"]},"rawMarkdownBody":"\n## 트랜잭션(Transaction)\n\n트랜잭션은 데이터베이스에서 수행되는 작업의 단위를 나타내며, 더 이상 쪼갤 수 없는 쿼리들의 묶음을 말한다. 트랜잭션은 ACID 특징을 따르며, ACID는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 나타낸다.\n\n## ACID 특징\n\n### 1. 원자성(Atomicity)\n\n- 트랜잭션을 구성하는 작업들은 모두 성공하거나 모두 실패하는 특성을 갖는다.\n- 중간 단계에서 오류가 발생하면 이전 상태로 롤백되어 어떠한 영향도 주지 않아야한다.\n\n### 2. 일관성(Consistency)\n\n- 트랜잭션 실행 전과 실행 후에 데이터베이스는 일관된 상태를 유지해야 한다\n- 트랜잭션은 데이터베이스의 무결성 제약조건을 만족해야 한다\n\n### 3. 격리성(Isolation)\n\n- 동시에 여러 트랜잭션이 실행될 때, 각 트랜잭션은 서로 간섭받지 않고 독립적으로 실행되는 특성\n- 특정 트랜잭션이 다른 트랜잭션의 작업을 볼 수 없다\n\n### 4. 지속성(Durability)\n\n- 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 한다\n- 시스템 장애 또는 다시 시작해도 데이터베이스는 변하지 않아야 한다\n\n## Commit과 Rollback 연산\n\n### Commit\n\n- 트랜잭션의 모든 작업이 성공적으로 완료되었고, 결과를 데이터베이스에 반영하는 명령\n- Commit이 수행되면 트랜잭션은 영구적으로 적용된다\n\n### Rollback\n\n- 트랜잭션의 실패나 에러가 발생한 경우, 이전 상태로 되돌리는 명령\n- 데이터베이스에 아무런 영향을 미치지 않은 것처럼 트랜잭션을 취소한다.\n\n---\n참고\n\nhttps://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/transactions.html"},{"excerpt":"프로젝트 기간(2024.02.07 - 2024.02.15) 완성 레포지토리 해당 프로젝트를 진행하며 느낀 점에 대한 기록  지켜야 할 것은 문서로 남기기 첫 협업 이후 의 중요성을 깨달았고 이번 프로젝트에서는 '이걸 지켜주세요' 라고 말하는게 아니라 지켜야할 것은 문서로 작성하기로 했다.  코드 컨벤션을 IDE에 적용, 설정하기 위한 레퍼런스를 공유했고,…","fields":{"slug":"/second_coop/"},"frontmatter":{"date":"February 15, 2024","title":"두번째 협업 회고","tags":["cooperation","retrospective"]},"rawMarkdownBody":"\n프로젝트 기간(2024.02.07 - 2024.02.15)\n\n[완성 레포지토리](https://github.com/jinkshower/OTT_Suggestion)\n\n해당 프로젝트를 진행하며 느낀 점에 대한 기록 \n\n## 지켜야 할 것은 문서로 남기기\n\n[첫 협업](https://jinkshower.github.io/first_team_assignment/) 이후 `문서화`의 중요성을 깨달았고 이번 프로젝트에서는 '이걸 지켜주세요' 라고 말하는게 아니라 지켜야할 것은 문서로 작성하기로 했다. \n\n코드 컨벤션을 IDE에 적용, 설정하기 위한 레퍼런스를 공유했고, 깃 컨벤션과 브랜치 전략을 프로젝트 초기단계에 모두 같이 모여 정했다. \n\n![Pasted image 20240215205740](https://github.com/jinkshower/jinkshower.github.io/assets/135244018/327a4bad-38ce-4946-b347-ef77829241d1)\n\nJDK 버전,  gitignore, dependency 설정 등 각자의 로컬환경에서 충돌이 일어날 수 있는 부분을 모두 통일했다.\n\n## 설계와 공통코드 \n\n서로 다른 코드 스타일을 가진 개발자들과 같이 '잘' 코드를 작성하려면 공통된 보일러플레이트가 있어야 한다고 생각했다. \n\n공통코드를 같이 프로그래밍하고, 그 것을 지켜야할 `규칙`으로 만든다면 push할 때 조금 덜 두려워질 것이라고 생각했다. \n\nIntelliJ의 CodeWithMe를 사용하여 5명이 동시에 의견을 주고 받으며 프로그래밍을 진행했고, 개인적으로 설계에서 중요하다고 생각하는 패키지구조와 도메인 클래스명들을 몹 프로그래밍으로 구현했다.\n\n`문서화` 와 `공통코드`를 통해 프로젝트 전반적으로 Merge시 충돌이 적었으며 이는 곧 생산성의 증진으로 이어졌다.\n\n## Approve를 누른다는 건\n\n주어진 프로젝트 기간이 길지 않았기 때문에 페어프로그래밍이나 몹프로그래밍으로 구현한 부분은 Approve를 급하게 누르고 진행하려는 경향이 있었다. \n\n같이 작성한 코드니까 문제가 생기지 않겠다고 생각했지만, 프로젝트 중반이 되는 지점에서 파일 개수가 많아지고 새로운 기능을 구현할수록 이전 코드와 일관성이 떨어지거나, 끼워 맞추는 식의 코드가 발생했다.\n\n해당 문제가 발생할때마다 회의를 통해 공통된 코드에 대한 인식을 리마인드하는 시간을 가져서 문제를 해결했지만 같이 프로그래밍을 한 것이라도, 세세한 코드 리뷰나 PR 기록을 남기지 않으면 결국 내가 그 코드를 마주해야 함을 깨달았다. \n\nApprove를 누른다는 건, 이 코드를 내가 작성한 것으로 생각하겠다는 허락이라는 생각이 들었다. \n\n## 협업\n\n이번 프로젝트에서 열정적이고 좋은 팀원들을 만나게 되어 혼자서 했다면 훨씬 오래 걸릴 구현들을 빠르게 진행할 수 있었지만 만약 그렇지 않았다면? 내가 함께 일하게 될 팀원들은 내 이상과 많이 다를 수도 있다. \n\n결국 협업을 통해 더 좋은 결과를 내고 싶다면, 내가 이러한 부분을 문제로 생각한다면, 그 것을 문서로 남길 수 밖에 없다는 것을 다시금 새기게 되었다. \n\n또한 내 자신의 코드스타일에 좀 더 유연함을 가져야 함을 스스로 느끼게 되었다.  내가 개인적으로 맞다고 생각하는 방향은 다른 사람이 보기에 이해되지 않는 낯선 방향일수도 있다. \n\n그리고 이를 내가 설득할 수 없다면, 그건 내가 틀린 것일 수도 있지 않을까? \n\n"},{"excerpt":"HTTP 통신의 특징 쿠키와 세션에 대해 이야기하기 전에 이들이 필요한 배경에 대해 말하려면 Http통신의 특징에 대해 이야기해봐야 한다. \n클라이언트와 서버간 tcp/ip 통신을 계-속 이어나간다면, 그리고 다수의 클라이언트의 통신이 발생하는 상황이라면 서버의 자원은 남아나지 않을 것이다. 이에 따라 응답 이후 바로 접속을 종료하는 HTTP 1.0, 일…","fields":{"slug":"/cookie_session/"},"frontmatter":{"date":"February 10, 2024","title":"쿠키와 세션","tags":["http","cookie","session"]},"rawMarkdownBody":"\n\n## HTTP 통신의 특징\n\n쿠키와 세션에 대해 이야기하기 전에 이들이 필요한 배경에 대해 말하려면 Http통신의 특징에 대해 이야기해봐야 한다.\n\n`비연결성(Connectionless)`\n클라이언트와 서버간 tcp/ip 통신을 계-속 이어나간다면, 그리고 다수의 클라이언트의 통신이 발생하는 상황이라면 서버의 자원은 남아나지 않을 것이다.\n\n이에 따라 응답 이후 바로 접속을 종료하는 HTTP 1.0, 일정시간 접속을 유지해 3 Way Handshake의 오버헤드 비용을 줄인 HTTP 1.1처럼 HTTP는 기본이 연결을 유지하지 않는 모델로 발전해왔다.\n\n`무상태(Stateless)`\n모든 HTTP 요청, 응답은 독립적이고 이전이나 이후의 요청과 무관하다.  서버는 다수의 요청에서 사용자에 대한 어떠한 정보도 저장할 필요가 없다. \n\n무상태인 HTTP의 특성에 따라 서버를 확장하기가 쉽다.(어떠한 서버든지 요청에 알맞게 응답할 수 있으므로)\n\n하지만 이러한 특성에도 불구하고 우리는 웹을 이용할때 독립적인 요청, 응답을 받는 것 같지 않다. \n\n내 장바구니에는 내가 이전에 담은 물품이 들어있고 로그인한 웹페이지는 계속 해서 내 정보를 보여주고 있기 때문이다.\n\n이러한 지속적인 연결 경험을 위한 기술이 쿠키와 세션이다.\n\n## 쿠키와 세션\n\n### 쿠키\n\n쿠키란 클라이언트에 저장될 목적으로 생성한 작은 정보를 담은 파일이다. \n클라이언트는 이 정보를 저장해 놓고 요청시에 같이 전달한다. \n\n예를 들어 로그인시 서버에서 쿠키를 만들어 응답메시지의 헤더에 넣어 보내면 클라이언트는 쿠키 저장소에 이를 저장하고 이후 요청시에 쿠키를 같이 넣어 보내면 로그인한 나의 정보에 맞는 웹페이지를 응답하는 방식이다.\n\n쿠키는 \n\n1. Name 이름 쿠키의 식별자 값\n2. Value 쿠키의 값\n3. Domain 쿠키가 저장된 도메인\n4. Path 쿠키가 사용되는 경로\n5. Expires 만료기한\n\n으로 구성된다. \n\n보통 사용자 로그인 세션관리와 광고 정보 트래킹 등에 사용된다. \n\n하지만 쿠키는 항상 서버에 전송되다 보니 네트워크 트래픽을 추가로 유발할 수 있고, 갈취되기 쉽기 때문에 보안에 민감한 데이터는 쿠키로 다루면 안된다. \n\n### 세션\n\n세션은 클라이언트 측이 아닌 서버에 정보를 일정시간 저장하는 방식이다.\n\n서버에서 클라이언트 별로 식별값인 세션Id를 부여하고 클라이언트에 대한 정보를 서버에 저장한 후, 생성된 세션Id를 쿠키로 만들어(세션 쿠키) 클라이언트에 응답한다.\n\n이 후 클라이언트는 요청에 세션Id를 담아 전송하고 이러한 세션은 클라이언트가 브라우저를 닫거나 클라이언트가 로그아웃을 하거나, 설정한 기간을 넘길 시 유효하다. \n\n세션은 쿠키와 달리 사용자의 민감한 정보를 서버에 저장하기 때문에 보안 면에서 쿠키보다 더 낫다는 장점이 있다.\n\n하지만 서버에 클라이언트 정보를 저장하는 것은 서버 용량을 차지하기도 하고 서버의 무상태성을 지향하기 힘들게 만든다\n\n만약 모든 클라이언트의 정보를 하나의 서버가 가지고 있다면 다른 서버를 이용한 확장이 어려울 것이다. \n\n이를 보완하기 위해 세션 요청을 하나의 서버로 몰아주는 Sticky Session방식이나 세션을 저장소를 따로 생성해 저장하는 방법을 택하곤 한다. \n\n*틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다*\n\n---\n참고\n\nhttps://www.geeksforgeeks.org/difference-between-session-and-cookies/\n\nhttps://developer.mozilla.org/ko/docs/Web/HTTP/Cookies\n\n모든 개발자를 위한 HTTP 웹 기본 지식 - 김영한\n\n\n\n"},{"excerpt":"인수 테스트란 무엇일까? 알아보고 적용해본 인수테스트  학습 계기 개인 과제 중 테스트에 관련해 튜터님께 피드백을 받게 되었다\n\n이와 관련해 고민과 검색을 하다  라는 키워드를 찾아내게 되었다.  인수테스트 인수테스트(Acceptance Test)란 소프트웨어 테스팅 기법 중 하나로 소프트웨어의 수용성을 테스트하는 기법이다. 인수테스트를 통해 비즈니스 요…","fields":{"slug":"/acceptance_test/"},"frontmatter":{"date":"February 04, 2024","title":"인수 테스트(Acceptance Test)","tags":["spring","acceptancetest","testing"]},"rawMarkdownBody":"\n\n인수 테스트란 무엇일까? 알아보고 적용해본 인수테스트 \n\n## 학습 계기\n\n개인 과제 중 테스트에 관련해 튜터님께 피드백을 받게 되었다\n`서비스로서의 기능을 테스트하는 것도 중요하다`\n이와 관련해 고민과 검색을 하다  `인수 테스트`라는 키워드를 찾아내게 되었다. \n\n## 인수테스트\n\n인수테스트(Acceptance Test)란 소프트웨어 테스팅 기법 중 하나로 소프트웨어의 수용성을 테스트하는 기법이다.\n\n인수테스트를 통해 비즈니스 요구사항에 대한 소프트웨어의 적합성을 평가하고 소프트웨어를 회사가  `인수`해도 되는지를 측정한다고 한다.\n\n인수 테스트는 유저가 소프트웨어를 사용하는 시나리오를 적용하여 테스트를 진행하게 된다.\n\n예를 들어 'spring이라는 필터를 클릭하면 spring을 포함하는 목록을 보여준다'가 테스트 이름이 될 수 있겠다.\n\n## 적용하기\n\n자바에서는 `MockMvc`나 `RestAssured`를 이용해서 인수테스트를 진행한다고 한다. \n\n인수테스트는 실제 시나리오를 테스트하기 위함이기 때문에 @SpringBootTest로 웹 환경을 사용하는 `RestAssured`를 공부하기로 했다\n\n[공식문서](https://github.com/rest-assured/rest-assured/wiki/Usage) 와 각종 구글링으로 사용법을 익혔고\nassertJ와 합쳐서 테스트를 작성했다. \n\n```java\n@DisplayName(\"토큰을 가졌지만 할일의 userId와 동일하지 않은 id를 가진 유저는 할 일의 상태를 수정 할 수 없다\")  \n@Test  \nvoid test8() {  \n    //given  \n    postTodo(postRequestDto, validToken1);  \n  \n    //when  \n    ExtractableResponse<Response> response = RestAssured.given().log().all()  \n            .header(\"Authorization\", validToken2)  \n            .when().patch(\"/api/todos/1/status\")  \n            .then().log().all()  \n            .extract();  \n  \n    //then  \n    assertThat(response.statusCode()).isEqualTo(HttpStatus.BAD_REQUEST.value());  \n    assertThat(response.body().asString()).contains(\"작성자가 다릅니다.\");  \n}\n```\n\n그렇게 작성한 테스트 중 하나를 가져와봤다. \n\n`given`\n\nid를 가진 토큰으로 할일이 작성 되었을때\n\n`when`\n\n다른 id를 가진 토큰을 헤더에 포함한 `/api/todos/1/status`라는 http 요청을 보내면\n\n`then`\n\n응답의 상태코드가 400임을 확인하고 에러메시지를 확인한다\n\nwhen 부분의 코드를 자세히 보면 \n```java\n    ExtractableResponse<Response> response = RestAssured.given().log().all()   //요청에 대한 조건을 추가할 수 있다\n            .header(\"Authorization\", validToken2)  \n            .when().patch(\"/api/todos/1/status\")  // http요청을 보낼수있다\n            .then().log().all()  //응답을 모두 기록하여 추출할 수 있다\n            .extract();  \n```\n로 정리할 수 있겠다.\ngiven()과 then()에 log().all()을 추가해서 응답과 요청 내용을 콘솔에 찍어서 디버그에 유용하게 쓸 수도 있다. \n\n## 느낀점\n\n인수테스트를 작성하다보니 자연스레 api명세서 자체를 테스트하고 있음을 깨닫게 되었다.\n\n또한 하나의 기능을 테스트하기 위해서는 이전 기능이 모두 작동해야하기 때문에 넓은 테스트 커버리지를 달성할 수 있었다.\n\n무엇보다 요청과 응답을 모두 콘솔에 찍을 수 있기 때문에 postman으로 직접 실행하고 디버깅하는 것보다 편한 부분이 있었다.\n\n## 하지만\n\n예시코드에서 `postTodo()`를 다시 보면 한줄이라 간단해 보이지만\n`회원가입` -`로그인` 의 과정을 모두 거치고서야 할일을 등록할 수 있기 때문에 해당 클래스의 코드가 많아지는 것은 물론이고 테스트를 돌리는데 시간도 많이 걸린다.\n\n또한 random_port를 사용하는 테스트는 @Transactional이 적용되지 않기 때문에 테스트의 격리가 어려워 진다.\n\n아직 나만의 방법을 찾지 못해서 임시방편으로 @AfterEach로 데이터베이스를 초기화하고 있지만 좋은 방법은 아닌 것같다. \n\n당장 찾아본 방법은 \n\n1.  MockMvc를 사용한다\n2.  의도적으로 다른 데이터를 사용한다\n3.  @DirtiesContext를 사용한다\n\n정도 인데 테스트 격리에 대해 조금 더 생각이 정리되면 코드로 적어보고 글로 작성해보려고 한다.\n\n*틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다*\n\n---\n참고\n\nhttps://www.geeksforgeeks.org/acceptance-testing-software-testing/\n\nhttps://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/\n\n\n\n\n"},{"excerpt":"개인과제를 진행하며 ArgumentResolver를 추가하여 코드를 개선한 기록 과제에서 만난 문제 개인 과제에서 밑과 같은 코드를 작성하게 되었다. Jwt토큰을 헤더에 넣는 방식으로 로그인 인증처리를 하고 있는데, 할일을 등록하기 위해서는 토큰 인증이 필요하고 request에서 헤더를 뽑아내서 토큰을 인증하고 인증이 통과하면 로직을 실행해야 하는 메서드…","fields":{"slug":"/argumentresolver/"},"frontmatter":{"date":"February 02, 2024","title":"ArgumentResolver추가로 코드 개선하기","tags":["spring","argumentresolver"]},"rawMarkdownBody":"\n\n개인과제를 진행하며 ArgumentResolver를 추가하여 코드를 개선한 기록\n\n## 과제에서 만난 문제\n\n개인 과제에서 밑과 같은 코드를 작성하게 되었다.\n\n```java\n@PostMapping  \npublic String postTodo(HttpServletRequest request) {  \n    String token = jwtUtil.getJwtFromHeader(request);  //헤더에서 토큰 뽑기\n    jwtUtil.validateToken(token);  //검증\n     \n    //\n    //  \n```\n\nJwt토큰을 헤더에 넣는 방식으로 로그인 인증처리를 하고 있는데, 할일을 등록하기 위해서는 토큰 인증이 필요하고 request에서 헤더를 뽑아내서 토큰을 인증하고 인증이 통과하면 로직을 실행해야 하는 메서드를 작성하게 되었다.\n\nTodo를 등록하는 것 이외에도 조회, 삭제 ,수정 모두에 토큰 검증이 필요하기 때문에 해당 코드의 중복을 막을 수 있는 방법을 찾게 되었다.\n\n## ArgumentResolver 간단하게 알아보기\n \n스프링을 쓰다 보면 다양한 파라미터를 어노테이션만 붙이고 사용한 경험이 있을 것이다.\n\n```java\npublic String hello(@PathVariable Long id,\n\t\t\t\t\t@RequestParam String username,\n\t\t\t\t\t   @RequestBody RequestDto requestDto...) {  \n    // 이들은 ?어디서? 오는 거지 ?\n}\n```\n\n스프링은 위처럼 다양한 메서드 파라미터들을 스프링 내부의 `RequestMappingHandlerAdapter` 에서 어노테이션 기반으로 처리해서 우리가 쓰는 @Controller에 보내준다.\n\n잠깐 해당 클래스의 내부를 살펴볼까? \n\n![Pasted image 20240204191203](https://github.com/jinkshower/jinkshower.github.io/assets/135244018/dd88399e-9392-421f-b877-4387b7988ee5)\n(클래스 내부의 일부다. 궁금하면 cmd+O로 검색 후 들어가보자!)\n\n해당 클래스 안에 보이는 `ArgumentResolver`들이  `DispatcherServlet`이 보내주는 http요청을 (밑에 살짝 보이는) `Converter`들을 이용해 우리가 필요로 하는 형태 변환해서 보내주고 있다.\n\n어떤 종류의 메서드 파라미터들을 할 수 있는지는 [공식문서](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html)를 참고하도록 하자.\n\n그럼 이 Jwt토큰 검증을 하는 ArgumentResolver를 추가하면 우리는 토큰 검증을 통과한 request만 받을 수 있지 않을까?\n\n## HandlerMethodArgumentResolver 구현하기\n\n내부에서 본 코드에서 `List<HandlerMethodArgumentResolver>`가 기억날지도 모르겠다.\n스프링이 제공하는 `ArgumentResolver`들은 `HandlerMethodArgumentResolver` interface를 구현하고 있다.\n\n```java\npublic interface HandlerMethodArgumentResolver {  \n    boolean supportsParameter(MethodParameter parameter);  \n  \n    @Nullable  \n    Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;  \n}\n```\n\n즉, 우리는 이 인터페이스를 구현하고 아까 본 List에 넣어주기만 하면 된다. \n\n`supportsParameter()`는 해당 파라미터를 이 Resolver가 처리할 수 있는 지를 판단하고\n`resolveArgument()`를 호출해서 실제 객체를 생성하고 컨트롤러 호출시 넘겨준다\n\n그럼 구현해볼까? \n\n```java\n@Slf4j  \n@Component  \n@RequiredArgsConstructor  \npublic class AuthArgumentResolver implements HandlerMethodArgumentResolver {  \n  \n    private final JwtUtil jwtUtil;  \n    private final UserRepository userRepository;  \n  \n    @Override  \n    public boolean supportsParameter(MethodParameter parameter) {  \n        return parameter.hasParameterAnnotation(Login.class);//어노테이션\n    }  \n  \n    @Override  \n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,  \n                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {  \n        HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();  \n  \n        String token = jwtUtil.getJwtFromHeader(request);  \n        if (!jwtUtil.validateToken(token)) {  \n            String errorMessage = \"토큰 검증에 실패했습니다.\";  \n            log.error(errorMessage);  \n            throw new InvalidTokenException(errorMessage);  \n        }  \n        Long userId = jwtUtil.getUserIdFromToken(token);  \n        User found = userRepository.findById(userId).orElseThrow(  \n                () -> {  \n                    String errorMessage = \"ID로 유저를 찾을 수 없습니다. 요청 ID: \" + userId;  \n                    log.error(errorMessage);  \n                    return new AuthenticationException(errorMessage);  \n                }  \n        );  \n        log.debug(\"검증 통과!\");  \n  \n        return new UserDto(found);  \n    }  \n}\n```\n이렇게 `resolveArgument()`에서 토큰 검증을 하고 토큰에서 id를 가지고 user를 만들어 UserDto로 보내주게 되었다.\n\n`supportsParameter()`에 있는 `Login.class`는 어노테이션 메소드 인자로 UserDto를 바로 받기 위해서 만들었다\n\n```java\n@Target(ElementType.PARAMETER) //파라미터로 이 어노테이션을 생성할 수 있다\n@Retention(RetentionPolicy.RUNTIME) \npublic @interface Login{ //어노테이션 클래스로 지정\n}\n```\n\n즉 `supportsParameter()`는 해당 파라미터에 @Login이 붙어있는지 보고,  `resolveArgument`는 해당 파라미터에 들어가는 요청에서 토큰을 검증하고 검증이 성공하면 UserDto를 보내주는 것이다.\n\n## WebMvcConfigurer에 등록하기\n\n스프링내에서 기능 확장을 하기 위해서는 `WebMvcConfigurer`를 상속받아서 인터페이스 구현체를 등록해줘야 한다.\n\n```java\n@Configuration  \n@RequiredArgsConstructor  \npublic class WebConfig implements WebMvcConfigurer {  \n  \n    private final AuthArgumentResolver authArgumentResolver;  \n  \n    @Override  \n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {  \n        resolvers.add(authArgumentResolver);  \n    }  \n}\n```\n\n이렇게 등록해줬다. \n\n## 완성코드\n\n그럼 아까 처음에 본 postTodo()는 어떻게 변했을까?\n\n```java\n@PostMapping  \npublic String postTodo(@Login UserDto userDto) {  \n    //\n    //  \n```\n\n이렇게 토큰이 검증된 User 정보를 편하고 간편하게 쓸 수 있게 되었다.\n\n*틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다*\n\n---\n\n참고\n\n스프링 부트와 AWS로 혼자 구현하는 웹서비스 - 이동욱\n\n스프링 MVC 1편, 백엔드 웹 개발 핵심기술 - 김영한\n"},{"excerpt":"JDBC Template는 어떻게 생겨났을까? JDBC코드를 개선하며 살펴보는 기록 JDBC template가 있기 전 간단하게 users 테이블에 User를 저장하고 삭제하는 \bUserDao 메서드들을 JDBC로 작성해봤다\nDataSource는 클래스를 주입받아 사용하고 있다. 자원을 쓰는 부분을 모두 null 체크를 하고 반환해줘야 하기 때문에 try…","fields":{"slug":"/jdbc_template/"},"frontmatter":{"date":"January 29, 2024","title":"JDBC 에서 JDBC Template","tags":["spring","jdbc","designpattern"]},"rawMarkdownBody":"\n\nJDBC Template는 어떻게 생겨났을까? JDBC코드를 개선하며 살펴보는 기록\n\n## JDBC template가 있기 전\n\n간단하게 users 테이블에 User를 저장하고 삭제하는 \bUserDao 메서드들을 JDBC로 작성해봤다\nDataSource는 `SimpleDriverDataSource`클래스를 주입받아 사용하고 있다.\n\n```java\npublic void add(User user) throws SQLException {  \n    Connection c = null;  \n    PreparedStatement ps = null;  \n  \n    try {  \n        c = dataSource.getConnection();  \n        ps = c.prepareStatement(\"insert into users(id, name, password) value(?,?,?)\");  \n        ps.setString(1, user.getId());  \n        ps.setString(2, user.getName());  \n        ps.setString(3, user.getPassword());  \n  \n        ps.executeUpdate();  \n    } catch (SQLException e) {  \n    } finally {  \n        if (ps != null) {  \n            try{  \n                ps.close();  \n            } catch (SQLException e) {  \n            }  \n        }  \n        if (c != null) {  \n            try {  \n                c.close();  \n            } catch (SQLException e) {  \n            }  \n        }  \n    }  \n}\n\npublic void delete() throws SQLException {  \n    Connection c = null;  \n    PreparedStatement ps = null;  \n  \n    try {  \n        c = dataSource.getConnection();  \n        ps = c.prepareStatement(\"delete from users\");  \n        ps.executeUpdate();  \n    } catch (SQLException e) {  \n    } finally {  \n        if (ps != null) {  \n            try{  \n                ps.close();  \n            } catch (SQLException e) {  \n            }  \n        }  \n        if (c != null) {  \n            try {  \n                c.close();  \n            } catch (SQLException e) {  \n            }  \n        }  \n    }  \n}\n```\n\n자원을 쓰는 부분을 모두 null 체크를 하고 반환해줘야 하기 때문에 try-catch-finally 중 제외할 부분은 없다.\n\n일단 catch하는 부분은 비워놨는데 여기서 예외처리를 추가하면 코드는 더 길어질 것이다. \n\n위 코드는 아무런 문제가 없지만 간단한 기능들을 쓰는데 이만한 코드를 작성하는 게 맞나?라는 생각이 들 수 밖에 없다. \n\n더 문제인 점은 db에 접근하는다른 기능을 만드려면 위 코드와 아주 유사한 메소드를  똑같이 생성해줘야 한다는 점이다.\n\n## 전략패턴 활용\n\n전략패턴을 활용하여  반복되는 부분을 줄여볼 수 있을 것 같다.\n\n우리가 관심 있는 부분은 쿼리문이 바뀌는 ps 부분이니 이 부분을 interface화 하고,우리가 원하는 기능을 implement하는 클래스로 만들고, 반복되는 부분에는 전략의 구현클래스를 주입 받도록 할 수 있을 것이다. \n\ninterface 클래스\n```java\npublic interface StatementStrategy {  \n    PreparedStatement makePreparedStatement(Connection c) throws SQLException;  \n}\n```\n\nadd와 delete 클래스\n```java\npublic class AddStatement implements StatementStrategy {  \n    User user;    //add 는 user가 필요하니 주입 받는다\n    public AddStatement(User user) {  \n        this.user = user;  \n    }  \n    @Override  \n    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {  \n        PreparedStatement ps = c.prepareStatement(\"insert into users(id, name, password) value(?,?,?)\");  \n        ps.setString(1, user.getId());  \n        ps.setString(2, user.getName());  \n        ps.setString(3, user.getPassword());  \n        return ps;  \n    }  \n}\n\npublic class DeleteStatement implements StatementStrategy {  \n    @Override  \n    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {  \n        PreparedStatement ps = c.prepareStatement(\"delete from users\");  \n        return ps;  \n    }  \n}\n```\n\n전략패턴을 활용하여 구현체를 주입받기\n```java\npublic void jdbcWithStatementStrategy(StatementStrategy statement) throws SQLException {  \n    Connection c = null;  \n    PreparedStatement ps = null;  \n  \n    try {  \n        c = dataSource.getConnection();  \n        ps = statement.makePreparedStatement(c);//구현체마다 다른 ps를 받을 수 있다\n  \n        ps.executeUpdate();  \n    } catch (SQLException e) {  \n        throw e;  \n    } finally {  \n        close(ps, c);  \n    }  \n}  \n  \nprivate void close(PreparedStatement ps, Connection c) throws SQLException {  \n    if (ps != null) {  \n        try {  \n            ps.close();  \n        } catch (SQLException e) {  \n        }  \n    }  \n    if (c != null) {  \n        try {  \n            c.close();  \n        } catch (SQLException e) {  \n        }  \n    }  \n}\n  \n```\n\n전략패턴을 사용하는 add, delete 메서드\n```java\npublic void add(User user) throws SQLException {  \n    StatementStrategy st = new AddStatement(user);  \n    jdbcWithStatementStrategy(st);  \n}\n\npublic void delete() throws SQLException {  \n    StatementStrategy st = new DeleteStatement();  \n    jdbcWithStatementStrategy(st);  \n}\n```\n\n\n구체화된 전략클래스들을 주입받아 실행하는 추상화된 메서드를 만들었다. close()또한 메서드 추출을 진행했다.\n\n이제 우리는 필요한 기능이 생길때 interface를 상속받은 클래스를 만들고 해당 메서드를 이용만 하면 된다.\n\n처음 코드와 비교해보면 add, delete의 코드 라인 수가 훨씬 많이 줄었다.\n\n그리고 다른 기능이 추가 구현되어도 전략 클래스를 새로 만들고 추상화된 메서드에 파라미터로 넣는 간단한 기능만 만들면 되니 확장성을 갖췄다고도 볼 수 있다.\n\n하지만 전통적인 전략패턴의 문제점을 여전히 가지고 있는데, 바로 구현클래스가 계속 늘어나는 단점이다. 또한 add(), delete()가 직접 전략의 구현체를 생성하는 것도 확장성에 문제를 일으킬 수 있다.\n\n## 템플릿/ 콜백 패턴\n\n`템플릿/콜백 패턴` 이란\n\n중복되는 부분이 있는 코드에서 변경이 일어나지 않는 부분을 `템플릿`, 변경이 일어나는 부분을 `콜백`으로 분리하여 변화되는 부분만 인자로 넘겨주는 디자인 패턴이다\n\n전략패턴으로 개선한 위의 UserDao를 템플릿/콜백으로 더 개선해볼 수 있다.\n\n```java\npublic class JDBCContext {  \n  \n    private DataSource dataSource;  \n  \n    public JDBCContext(DataSource dataSource) {  \n        this.dataSource = dataSource;  \n    }  \n//주목! \npublic void executeSql(final String query, String... args) throws SQLException {  \n    jdbcWithStatementStrategy(c -> {  \n                PreparedStatement ps = c.prepareStatement(query);  \n                for (int i = 0; i < args.length; i++) {  \n                    ps.setString(i + 1, args[i]);  \n                }  \n                return ps;  \n            }  \n    );  \n}\n  \nprivate void jdbcWithStatementStrategy(StatementStrategy stmt) throws SQLException {  \n        Connection c = null;  \n        PreparedStatement ps = null;  \n  \n        try {  \n            c = dataSource.getConnection();  \n            ps = stmt.makePreparedStatement(c);  \n  \n            ps.executeUpdate();  \n        } catch (SQLException e) {  \n            throw e;  \n        } finally {  \n            close(ps, c);  \n        }  \n    }  \n  \nprivate void close(PreparedStatement ps, Connection c) throws SQLException {  \n        if (ps != null) {  \n            try {  \n                ps.close();  \n            } catch (SQLException e) {  \n            }  \n        }  \n        if (c != null) {  \n            try {  \n                c.close();  \n            } catch (SQLException e) {  \n            }  \n        }  \n    }  \n}\n```\n\n이전 jdbcWithStatementStrategy를 가진 새로운 `JDBCContext`클래스를 만들어냈다.\n즉, 반복되는 부분을 `템플릿`으로 만들어 낸 것이다.\n\n그리고 public 메서드인 executeSql()를 추가했는데 이에 주목해보자\n\n앞선 전략패턴의 문제점이었던 구현클래스가 계속 늘어나는 문제를 람다를 사용한 익명내부 클래스 생성로 해결했다. \n\n또한 varargs를 사용하여 add()처럼 필요한 인자수가 늘어나는 문제를 해결했다. \n\n그렇다면 UserDao는 어떻게 변했을까? \n```java\nprivate JDBCContext jdbcContext;  // 주입 받는다. \n//\n//\npublic void add(final User user) throws SQLException {  \n    jdbcContext.executeSql(\"insert into users(id, name, password) value(?,?,?)\",  \n            user.getId(), user.getName(), user.getPassword());  \n}\n\npublic void delete() throws SQLException {  \n    jdbcContext.executeSql(\"delete from users\");  \n}\n```\n\n이제 UserDao는 DB에 어떻게 연결되고, 예외를 처리하고, 자원을 반환하는지 상관하지 않아도 된다. \n우리가 관심있는 query문만 DB에 Access하는 DAO의 실목적에 맞는 객체가 되었다.\n\n## JDBC Template\n\n이쯤에서 JDBC Template를 사용해서 같은 기능을 만들어 보자\n\n```java\nprivate JdbcTemplate jdbcTemplate;;  // 주입 받는다. \n//\n//\npublic void add(final User user) throws SQLException {  \n    jdbcTemplate.update(\"insert into users(id, name, password) values(?,?,?)\",  \n            user.getId(), user.getName(), user.getPassword());  \n}\n```\n\n같은 기능을 하는 JdbcTemplate의 update()메서드다\n우리가 위에서 템플릿/콜백 패턴으로 만들어낸 add()기능과 똑같다. \n\n이쯤에서 해당 update() 메서드의 내부구현을 보자\n\n*JDBC template의 내부 코드를 따라가니 너무 복잡하다면 스킵하고 결론만 봐도 괜찮습니다*\n\n*+저의 부족하고 주관적인 의견으로 보는 과정이므로 틀린 부분이 있을 수 있습니다*\n\n1층\n```java \npublic int update(String sql, @Nullable Object... args) throws DataAccessException {  \n    return this.update(sql, this.newArgPreparedStatementSetter(args));  \n}\n```\nsql문과 이후 파라미터로 varargs를 써서 여러개의 Object를 받고 있다.\n일단 sql에 집중해보자\n\n2층\n```java\npublic int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException {  \n    return this.update((PreparedStatementCreator)(new SimplePreparedStatementCreator(sql)), (PreparedStatementSetter)pss);  \n}\n```\n쿼리문을 SimplePreparedStatementCreator에 생성자 파라미터로 넘겨주고 이를 PreparedStatementCreator로 형변환을 해주고 있다 \n\nSimplePreparedStatementCreator \n```java\nprivate static class SimplePreparedStatementCreator implements PreparedStatementCreator, SqlProvider {  \n    private final String sql;  \n    public SimplePreparedStatementCreator(String sql) {  \n        Assert.notNull(sql, \"SQL must not be null\");  \n        this.sql = sql;  \n    }  \n    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {  \n        return con.prepareStatement(this.sql);  //여기\n    }  \n    public String getSql() {  \n        return this.sql;  \n    }  \n}\n```\ncreatePreparedStatement()에 주목하면 될 것 같다. \n우리가 계속 보던 prepareStatement()를 return하고 있고,\nsql의 not null을 assert하고 sql도 따로 가질 수 있는 wrapper클래스로 이해하면 될 것 같다 \n\n3층\n```java\nprotected int update(final PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss) throws DataAccessException {  \n    this.logger.debug(\"Executing prepared SQL update\");  \n    return updateCount((Integer)this.execute(psc, (ps) -> {  \n        boolean var9 = false;  \n  \n        Integer var4;  \n        try {  \n            var9 = true;  \n            if (pss != null) {  \n                pss.setValues(ps);  \n            }  \n  \n            int rows = ps.executeUpdate();  \n            if (this.logger.isTraceEnabled()) {  \n                this.logger.trace(\"SQL update affected \" + rows + \" rows\");  \n            }  \n  \n            var4 = rows;  \n            var9 = false;  \n        } finally {  \n            if (var9) {  \n                if (pss instanceof ParameterDisposer parameterDisposer) {  \n                    parameterDisposer.cleanupParameters();  \n                }  \n  \n            }  \n        }  \n  \n        if (pss instanceof ParameterDisposer parameterDisposerx) {  \n            parameterDisposerx.cleanupParameters();  \n        }  \n  \n        return var4;  \n    }, true));  \n}\n```\nthis.execute()에서 쿼리문을 처리하고 있다. \n한층만 더 내려가보자\n\n4층\n드디어 도착!\n```java\nprivate <T> T execute(PreparedStatementCreator psc, PreparedStatementCallback<T> action, boolean closeResources) throws DataAccessException {  \n    //  \n    //    \n    Connection con = DataSourceUtils.getConnection(this.obtainDataSource());  \n    PreparedStatement ps = null;  \n    Object var18;\n    //   \n    //  \n    try {  \n        ps = psc.createPreparedStatement(con);  \n        T result = action.doInPreparedStatement(ps);  \n        var18 = result;\n    } catch (SQLException var14) {  \n        //  \n        //\n\t   } finally {  \n       JdbcUtils.closeStatement(ps);  \n        DataSourceUtils.releaseConnection(con, this.getDataSource());  \n    }  \n  \n    if (closeResources) {  \n        JdbcUtils.closeStatement(ps);  \n        DataSourceUtils.releaseConnection(con, this.getDataSource());  \n    }  \n    //  \n    //\n    return var18;\n```\n예외처리에 관련된 부분은 주석처리하고 중요하다 생각되는 부분만 가져왔다. \n\n내부코드를 보면 Connection을 가져오고, Object 타입인 var18에 쿼리문 실행의 결과를 넣고 있다. 또한 try-catch-finally로 쓴 자원을 반환하고 있다. 그리고 result를 담은 var18을 반환하고 있다.\n\n우리가 만들어진 템플릿/콜백 패턴으로 만들어낸 JDBCContext와 같은 구조를 가지고 있는 것을 확인할 수 있다.\n\n## 결론\n\n순수한 JDBC를 개선하는 과정에서 변경되지 않는 부분을 따로 두고, 변경되는 부분만 추출하는 작업을 해보았다.\n\n그리고 이 과정에서 나온 결과물은 JDBCTemplate의 내부 구조와 아주 유사했다.\n\n즉, JDBC Template라는 것은 순수 JDBC에 디자인패턴(템플릿/콜백)을 적용하여 콜백에 해당하는 부분을 Public API로 드러낸 클래스라고 할 수 있다.\n\n*틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다*\n\n---\n\n\n참고\n\n토비의 스프링 3.1 vol \n\n\n"},{"excerpt":"개인과제를 진행하며 Spring의 AOP 예외 처리로 코드를 개선한 기록. 과제에서 마주한 문제 개인 과제를 진행하는 도중 Entity를 수정할때 비밀번호가 다를 경우 예외를 던지는 코드를 작성하게 되었다. 이 애플리케이션이 Java로 돌아가는 커맨드라인 프로그램이었다면 종료되었을 것이다. 하지만 Spring에서 별다른 예외처리를 하지 않고 그냥 thro…","fields":{"slug":"/spring_exception/"},"frontmatter":{"date":"January 24, 2024","title":"AOP를 통한 Spring 예외처리","tags":["spring","exception","exceptionhandler"]},"rawMarkdownBody":"\n개인과제를 진행하며 Spring의 AOP 예외 처리로 코드를 개선한 기록.\n\n## 과제에서 마주한 문제\n\n개인 과제를 진행하는 도중 Entity를 수정할때 비밀번호가 다를 경우 예외를 던지는 코드를 작성하게 되었다.\n```java\n@Transactional\npublic ScheduleResponseDto updateSchedule(Long id, ScheduleRequestDto scheduleRequestDto) {\n    Schedule schedule = findSchedule(id);\n    validatePassword(schedule.getPassword(), scheduleRequestDto.getPassword());\n\n    schedule.update(scheduleRequestDto);\n    return new ScheduleResponseDto(schedule);\n}\n\nprivate void validatePassword(String origin, String input) {  \n    if(!origin.equals(input)) {  \n        throw new IllegalArgumentException(\"[ERROR] 패스워드가 다릅니다\");  \n    }  \n}\n```\n이 애플리케이션이 Java로 돌아가는 커맨드라인 프로그램이었다면 종료되었을 것이다.\n\n하지만 Spring에서 별다른 예외처리를 하지 않고 그냥 throw로 던지는 예외의 경우 500상태코드를 반환하게 된다. \n\n`사용자` 가 알맞은 비밀번호를 입력하지 않았는데, 500 상태코드가 반환된다.\n서버 에러 메시지를 보고 계속 같은 요청을 하는 사용자도 생길테고, 이는 전반적인 사용자 경험에 큰 악영향을 미친다\n또한 사용자는 자신의 요청에 대한 피드백을 제대로 받지 못한다.\n\n## 첫 시도, Early Return\n\n```java\n@Transactional  \npublic ResponseEntity<String> updateSchedule(Long id, ScheduleRequestDto requestDto) {  \n    Schedule schedule = findSchedule(id);  \n    if (!schedule.getPassword().equals(requestDto.getPassword())) {  \n        return ResponseEntity.badRequest().body(\"비밀번호가 다릅니다\");  \n    }   // early return\n\n    schedule.update(requestDto);  \n    return ResponseEntity.ok().body(\"수정 완료!\");  \n}\n```\n수정하는 메서드에서 검증을 진행하고, 비밀번호가 다를 경우 상태코드와 함께 메시지를 전달하게 바꾸어 보았다.\n\n하지만 해당 방법은 \n1. 검증이 필요한 모든 메서드에 early return을 적용해야 하고,\n2. 검증 로직에 변경이 있을 경우 응답객체의 생성방식도 변경해야 한다.\n3. 더불어 Service에서 응답객체를 만들기 때문에 Controller의 역할이 희미해진다 (싱크홀 안티패턴의 가능성)\n\n## 두번째 시도, ResponseStatusException\n\n```java\nprivate void validatePassword(String origin, String input) {  \n    if(!origin.equals(input)) {  \n        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"[ERROR] 패스워드가 다릅니다\");\n    }  \n}\n```\nSpring에서 제공하는 `ResponseStatusException`을 이용해 보았다. \n파라미터로 HttpStatus와 String의 메시지를 넣을 수 있으니 500 상태코드 대신 내가 원하는 코드와 메시지를 전달할 수 있다.\n\n하지만 위의 방법으로는 내가 직접 예외처리 코드를 작성하지 않은 다른 예외는 처리할 수 없다. \n\n(내 의견으로는) 500 상태 코드는 정말 서버내부에서 크리티컬한 문제가 났을 때만 보여줘야한다고 생각한다. \n\n즉, 내가 해당방법으로 하나하나 예외처리 해준 케이스 이외에 사용자의 잘못된 요청으로 예외가 발생하면 여전히 500 상태코드가 보여진다. \n\n## 세번째 시도, @ExceptionHandler\n\n```java\n@ExceptionHandler(RuntimeException.class)  \npublic ResponseEntity<String> handleException() {  \n    //..  \n    return ResponseEntity.badRequest().body(\"[ERROR] 잘못된 입력입니다\");  \n}\n```\n해당 코드를 @Controller에 적용했다.\n\n@ExceptionHandler에 예외클래스를 명시한 후 @Controller에서 지정된 예외 클래스 하위의 예외가 발생시 어노테이션이 붙은 메서드를 실행하게 했다. \n\n이를 통해 직접 예외처리한 로직 이외에도 예외처리를 할 수 있게 되었고\n무엇보다도 500상태코드를 반환할 예외를 직접 지정할수 있게되었다. \n\n이 코드를 좀 더 확장성있게 쓸수 있지 않을까? \n\n## 확장하기, @ContollerAdvice\n\n```java\n@ControllerAdvice  \npublic class ControllerAdvice {  \n    @ExceptionHandler  \n    public ResponseEntity<String> handleException(Exception e) {  \n        return ResponseEntity.internalServerError().body(e.getMessage());  \n    }  \n@ExceptionHandler(IllegalArgumentException.class)  \n    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException e) {  \n        return ResponseEntity.badRequest().body(e.getMessage());  \n    }  \n}\n```\n\n@ControllerAdvice를 어노테이션으로 가지는 새로운 클래스를 작성했다.\n\n해당 어노테이션은 AOP(Aspect Oriented Programming)의 방식으로 예외처리를 많은 컨트롤러에서 `공통`으로 처리해야할 요소로 보고 @Controller어노테이션을 가진 모든 컨트롤러에서 발생하는 예외에 앞서 적용한 @ExceptionHandler의 예외처리 로직을 적용해 준다.\n\n코드를 보면 알수 있듯이 여러가지 Exception에 대해 어떤 응답을 보내줄지 메서드를 추가해서 확장할 수 있으므로 우리는 Java코드를 작성하는 것처럼 예외처리를 할 수 있게 되었고, 커스텀예외를 추가하는 것도 물론 가능하다. \n\n\n---\n참고\n\nhttps://mangkyu.tistory.com/204\n\nhttps://tecoble.techcourse.co.kr/post/2020-07-28-global-exception-handler/ \n\n"},{"excerpt":"의존성 주입(DI)포스팅에서 이어지는 내용입니다. Inversion of Control (제어의 역전) 이란? 객체의 컨트롤이나 프로그램의 일정부분을 프레임워크의 컨테이너으로 옮기는 소프트웨어 설계의 원리를 뜻한다. \n이 원리는 여러가지 디자인 패턴(전략 패턴, 서비스 로케이터 패턴, 팩토리 패턴)으로 실현될 수 있고 특히 의존성 주입(DI)로 가장 두드…","fields":{"slug":"/ioc_container/"},"frontmatter":{"date":"January 20, 2024","title":"IoC와 스프링 컨테이너","tags":["spring","ioc","container"]},"rawMarkdownBody":"\n의존성 주입(DI)[포스팅](https://jinkshower.github.io/dependency_injection/)에서 이어지는 내용입니다.\n\n## Inversion of Control (제어의 역전) 이란?\n\n객체의 컨트롤이나 프로그램의 일정부분을 프레임워크의 컨테이너으로 옮기는 소프트웨어 설계의 원리를 뜻한다. \n이 원리는 여러가지 디자인 패턴(전략 패턴, 서비스 로케이터 패턴, 팩토리 패턴)으로 실현될 수 있고 특히 의존성 주입(DI)로 가장 두드러지게 나타낼 수 있다.\n\n## 자바로 보는 제어의 역전\n\n```java\npublic class House {  \n    private Tv tv = new Tv();  \n    public House() {  \n    }  \n}\n```\n\n위 코드에서 House는 Tv클래스에 대한 제어권을 가지고 있다\n즉,  House는 `tv`라는 참조변수에 어떤 Tv가 들어올지 스스로가 정하고 있다고 볼 수 있다. \n\n여기에 DI를 적용해보자 \n```java\npublic class House {  \n    private Tv tv;  \n    public House(Tv tv) {  \n        this.tv = tv;  \n    }  \n}\n```\n\nHouse가 가지고 있던 제어권이 외부로 넘어갔다.\n즉, tv 객체를 생성하고 참조변수로 이어주는 역할을 더 이상 House가 하고 있지 않다.\n\n이렇게 House 객체는 객체를 생성하는 책임에서 벗어나게 되었고, 자신의 비즈니스 로직만 알아서 잘 실행하는 바람직한 객체가 되었다. \n\n하지만 이렇게 외부로 넘어간 제어권은 어디에 있을까? \nTv를 가지는 House를 만들기 위해서 우리의 코드 어디선가는 반드시\n`House house = new House(new Tv());`\n로 새로운 House를 만드는 호출을 해주어야만 한다. \n\n즉, 위 코드가 적힌 곳이 Main 이든, HouseFactory든 계속 제어권을 외부로 옮기는 것을 반복하다보면 어느 객체는 그 넘겨진 제어권을 실행해야 하는 것이다.\n\n## 의존성을 주입하는 객체 만들기\n\n그렇다면 의존성을 모두 한 곳에서 주입, 즉 제어권을 한 객체가 가지고 있다면 유지보수하기가 훨씬 쉬워지지 않을까? \n\n```java\npublic class AppConfig {  \n    public House house() {  \n        return new House(tv());  \n    }  \n    public Tv tv() {  \n//        return new Tv();  \n        return new SmartTv(): //tv interface를 가정\n    }\n}\n```\n\nAppConfig라는 객체를 생성하고, 여기에 모든 의존성 주입하는 코드를 작성했다. \n\n의존성 주입의 모든 장점을 유지하면서 제어권을 한 객체가 가지게 했기 때문에 이제 우리는 새로운 tv를 가진 House를 만들고 싶을 때 이 한 파일에 있는 코드 한 줄만 수정하면 된다. \n\n이렇게 어떤 객체가 어떻게 생성될 지, 프로그램을 구성하는 역할을 비즈니스 로직을 실행하는 객체들로부터 분리시킴으로써 우리는 해당 프로그램을 유지보수하는데에 엄청난 이점을 갖게 되었다.  \n\n하지만 여전히 의문이 든다.\n그럼 AppConfig는 어디서 생성하나?\nAppConfig 안의 house()를 호출하는 객체가 여전히 제어권을 가지고 있는 것 아닐까? \n\n## 스프링 컨테이너\n\n풀리지 않는 이 연쇄를 프레임워크로 넘김으로써 해결할 수 있다. \nIoC 컨테이너를 가지고 있는 프레임워크는 객체를 생성하고, 구성하고, 의존관계에 맞게 주입해주는 기능을 가지고 있다. \n\nSpring은 `ApplicationContext` interface로 IoC컨테이너 기능을 수행하고 있고, 구현체들은 다양한 설정 메타데이터(xml, java code, annotation)를 읽고, 이를 `Bean`이라는 객체로 만들어 준다. \n\n## \b스프링 컨테이너 사용하기\n\n```java\n@Configuration  \npublic class AppConfig {  \n    @Bean  \n    public House house() {  \n        return new House(tv());  \n    }  \n    @Bean  \n    public Tv tv() {  \n//        return new Tv();  \n        return new SmartTv():  \n    }  \n}\n```\n\n```xml\n<bean id=\"tv\" class=\"{class path}\" /> \n<bean id=\"house\" class=\"{class path}\"> \n    <constructor-arg name=\"tv\" ref=\"tv\" /> \n</bean>\n```\n\nAnnotation을 사용하거나, xml 파일로 객체 구성정보를 메타데이터화 할 수 있다. \n\nAnnotation이나 xml모두 각각의 장단점을 가지고 있는데\nAnnotation은 물론 편리하고 간단한것이 큰 장점이며 xml은  소스코드를 건드리지 않고, 컴파일을 하지도 않으면서도 메타데이터를 변경할 수 있다.\n\n위와 같이 메타데이터를 작성하면 \n스프링이 대신 객체를 각각 `Bean`으로 등록함은 물론 House에 Tv를 넣어서 생성하는 것과 같은 의존관계 설정도 자동으로 해주며 객체 라이프사이클관리도 해준다.\n\n즉, 우리는 아래와 같은 코드를 작성할 필요 없어지고 \n```java\nAppConfig appConfig = new AppConfig();\nHouse house = appConfig.house();\n```\n\n*객체 생성, 관리에 대한 제어권이 프로그래머에서 역전(Inverse) 되어 프레임워크가 맡게 된다.*\n\n---\n\n참고 \n\nhttps://www.baeldung.com/inversion-control-and-dependency-injection-in-spring\n\nhttps://docs.spring.io/spring-framework/reference/core/beans/basics.html\n\nhttps://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8"},{"excerpt":"Preface 혼자 개발 공부를 하다 처음으로 팀으로 개발을 해보는 경험을 하게 되었다. \n자바로 캠프 관리 커맨드라인 프로그램을 만드는 Tiny, Tiny 프로젝트였지만 이 과정에서 개발을 같이 한다는 것이 무엇인지 많은 것을 깨닫게 되어서 글로 기록하고 싶어졌다.  의견 모으기 팀원들도 협업으로 개발을 해본 경험이 없었기 때문에 리더인 나의 역할이 막…","fields":{"slug":"/first_team_assignment/"},"frontmatter":{"date":"January 17, 2024","title":"첫 팀 과제 회고","tags":["team assignment","retrospective"]},"rawMarkdownBody":"\n## Preface\n\n혼자 개발 공부를 하다 처음으로 팀으로 개발을 해보는 경험을 하게 되었다. \n자바로 캠프 관리 커맨드라인 프로그램을 만드는 Tiny, Tiny 프로젝트였지만 이 과정에서 개발을 같이 한다는 것이 무엇인지 많은 것을 깨닫게 되어서 글로 기록하고 싶어졌다. \n\n## 의견 모으기\n\n팀원들도 협업으로 개발을 해본 경험이 없었기 때문에 리더인 나의 역할이 막중하다는 것을 느끼게 되었다. \n어떻게 설계를 할지, 어떻게 구현할 기능을 나눌지, 그리고 그 코드들을 어떻게 합칠지 모두 백지상태에서 정해야 했다.\n\n다행히도 우리 팀은 1주정도의 시간을 통해 모두 각자의 의견을 내고 그 의견에 대해 경청하고 고민하는 팀문화를 빌딩해왔었고 설계부터 제출까지 모든 과정을 같이 의견을 모으며 하나하나 해결해나갔다. \n\n아래는 각 과정에서 우리 팀이 어떤 문제를 마주쳤고, 어떻게 해결해 나갔는지의 기록이다\n\n## 설계\n\n팀 과제를 하기 전 개인과제를 통해 `설계에 대한 고민`이 충분히 필요하다는 것이 팀의 공통의견이었고 설계를 어떻게 해야 할지에 대해 두가지 의견으로 나뉘어졌다. \n\n1. 다 같이 기능명세서를 작성하고 그를 바탕으로 설계도를 만들기  \n2. 각자 4장의 기능명세서와 설계도를 작성한 후 합친다\n\n토의 끝에 2번으로 결정했고 그 이유는 다음과 같다\n\n1. 각자가 기능명세서를 작성함으로써 팀원 모두 해결해야할 문제점에 대해 깊이 생각할 시간을 가질 수 있다.\n2.  4장의 설계도를 가지고 더 나은 설계를 고를 수 있다 \n\n### 문제점 \n\n이후, 각자 기능명세와 설계도를 합칠 때 문제점이 발생했다.\n\n누군가는 MarkDown으로 기능명세를 작성하고 클래스 다이어그램을 그려오고, 누군가는 머릿속에서 정리하고, 클래스 다이어그램에 모든 것을 그린 사람도 있는 등 각자가 제각기의 방식으로 기능명세와 설계도를 완성했기에 이를 합치는데 많이 시간과 비용이 소요되었다.\n\n정리하자면\n1. 기능명세, 설계도에 대한 공통의 마인드 모델이 없었고 \n2. 각자를 만들어내는 툴이 일치하지 않았다.\n\n### 해결\n\n툴을 확정하고 기능명세와 설계도를 팀내에서 나름대로 정의를 내렸다.\n\n선택된 툴   \n`기능명세` : MarkDown   \n`설계도` : Draw.io\n\n정의   \n`기능명세` : 조사, 수식여구등을 생략하고 구현해야할 모든 기능을 최대한 구체화한 글   \n`설계도` : 클래스 명과 필드명으로 한 객체를 표현하고 연관관계만 선으로 표현한 다이어그램 \n\n으로 결정하여 해당 문제를 해결했다 \n\n## 구현\n\n기능명세와 설계도를 완성한 후, 이 둘을 바탕으로 클래스 다이어그램에서 정한 클래스명, 필드명을 다 같이 몹 프로그래밍으로 구현했다.\n\n이 후 구현할 기능을 각자의 희망대로 분배했고 다행히 희망사항이 겹치지 않아 각자 비슷한 분량의 기능을 구현하게 되었다. \n\n내가 맡은 기능은 `수강생 점수 등록` 이었다.\n\n### 문제점\n\n구현 과정에서 많은 문제점이 발생했다.\n\n개인적인 문제점은 내가 기능을 만들기 위해서는 미리 구현되어야할 `수강생 등록`을 다른 팀원이 구현 중이었기 때문에 팀원이 구현할 기능에 대해 짐작만 하고 코드를 작성할 수 밖에 없었다. \n이는 결국 개인적으로 만족스럽지 못한 코드로 이어지게 되었다.\n\n팀적인 문제점은 몹 프로그래밍으로 작성한 초기 코드를 각자 로컬로 받으면서 발생했는데, \n1. JDK 버전이 통일되지 않았고, `.gitignore`이 모두 달라 초기 환경설정에서 막히는 팀원들이 발생했다.\n2. git에 대한 이해도가 모두 달라서 프로젝트 진행이 불가한 팀원들이 발생했다.\n\n### 해결\n\n모든 해결 과정을 화면공유로 팀원 모두가 참여한 상태에서 함께 해결했다.\n\n1. JDK버전을 17로 통일했다.\n2. `idea` 폴더를 `.gitignore`에 포함시킨 후 브랜치를 다시 배포했다\n3.  git 관련 아티클을 재공유했고 문제가 생긴 팀원의 화면을 같이 보며 git 명령어를 재숙지했다.\n\n## 합치기\n\n위 과정을 해결한 후 각자 동일한 환경설정으로 맡은 기능을 구현할 수 있게 되었다.\n이후 시간을 정해 기능을 각자 완성하고 함께 모여 코드를 합치기로 하였다.\n\n1. `main`- `dev`-`feature` 로 브랜치를 나누었다\n2. `main`은 제출용 브랜치로 완성된 코드만 가지도록 하였다\n3. `dev`에 `feature`를 Pull Request로 Merge하였다\n\nMerge는 몹 프로그래밍으로 모두 합의를 통해 진행했다\n\n### 문제점\n\n합치기 과정에서 가장 큰 문제가 발생했다 \n\n내가 처음으로 pull request 를 Merge하고, conflict를 해결하는 과정을 화면으로 공유했고 차례대로 다른 팀원들의 Pull Request를 Merge하는 과정에서 발생한 문제점이다.\n\n1.   각자 기능을 4분할로 나누고 하나의 Pull Request를 합치니 하나의 PR 코드양이 너무 많았다\n2.  깃 가이드라인을 팀내에서 문서화 하지 않아 합의했던 브랜치 전략을 놓친 팀원이 발생했다 \n3.  코드 컨벤션을 팀내에서 문서화 하지 않아 서로의 코드를 이해하기 쉽지 않았다\n4.  1번과 3번이 겹쳐져 수많은 Conflict가 발생했고 이를 수습하는 식으로 Merge가 진행됐다\n\n### 해결\n\n합치기에서의 `문제점`이 너무 치명적이라 팀내에서 긴급하게 다음 방향을 토의했다. \n처음부터 다시하기 혹은 지금 디버깅하며 코드를 조금씩 고쳐나가기, 두 가지 의견이 나왔고 \n제출일이 당장 다음날이라 디버깅하며 코드를 조금씩 고쳐나가기로 결정했다 \n\n나와 팀원 한분이 번갈아 드라이버를 잡고 몹프로그래밍으로 디버깅을 했고 해당 과정이 많이 어려웠다. \n몇 백줄이 되는 익숙치 않은 변수, 메서드명, 코드 구조를 따라가야 했고, 테스트 코드도 작성하지 않았기 때문에 일일히 출력하고 Main을 돌려가며 디버깅을 진행했다.\n\n다행히도 각자가 기능을 잘 완성해주어서 해결해야할 문제가 그리 크지는 않았다.\n합치기를 마치고 이후 시간이 남을 정도였고, 추가 구현 기능은 `합치기` 과정에서 느낀 점을 토대로 페어프로그래밍으로 코드리뷰를 상세히 하여 Merge하였고 \n결과적으로 만족스러운 코드를 제출할 수 있게 되었다.\n\n완성 레포지토리\nhttps://github.com/jinkshower/CampManagement\n\n## 첫 협업이 나에게 남긴 것\n\n`합치기`를 `해결`하면서, 지금까지 왜 지켜야 하는지 와닿지 않았던\n`코드 컨벤션`, `커밋 컨벤션`, `깃 브랜치 전략` 들을 문서화하고 팀원 모두가 지키는 것에 대한 필요성을 뼈저리게 느끼게 되었다. \n\n또한 왜 모든 개발교육과정에서 `소통` 과 `공유`를 강조하는지를 이해할 수 있었다.\n우리 팀이 마지막에 그나마 만족스러운 결과를 낼 수 있었던 이유는 서로 의견을 가감없이 말하고 그에 대해 진중히 고민하고, 장단점을 살펴 대안을 고르는 `팀 문화`를 빌딩해왔기 때문이라고 생각한다\n\n개인적으로는 나의 `커뮤니케이션 방식`을 되돌아보는 계기가 되었다.\n나는 건의사항이 있으면 언제나 말해야 하고, 내가 생각할 때 불합리하거나 비효율적인 일은 언제나 토의를 통해 개선할 수 있다고 생각한다. \n\n하지만 그러한 의견을 내면서 `쿠션어`를 사용하는 등 이른바 `둥글게 말하기`는 연습이 필요한 부분인 것 같다. \n\n마지막으로 딱딱하게 글을 적었지만 혹시나 이 글을 볼지도 모르는 나의 첫 개발팀원분들에게 감사를 전한다. \n"},{"excerpt":"Algorithms 강의를 들으며 공부한 기록 Union Find 두 원소가 같은 집합내에 있는지 확인할때 사용하는 알고리즘이다.\nDynamic connectiviy의 자료구조 중 그래프에 edge가 추가되기만 하는 구조(Incremental connectivity) 에서 사용할 수 있다.   로 p와 q를 같은 집합으로 만들고\n로 p의 루트를 찾거나 로…","fields":{"slug":"/union_find/"},"frontmatter":{"date":"January 14, 2024","title":"Union Find","tags":["algorithms","union_find"]},"rawMarkdownBody":"\n\nAlgorithms 강의를 들으며 공부한 기록\n\n## Union Find\n\n두 원소가 같은 집합내에 있는지 확인할때 사용하는 알고리즘이다.\nDynamic connectiviy의 자료구조 중 그래프에 edge가 추가되기만 하는 구조(Incremental connectivity) 에서 사용할 수 있다. \n\n`union(int p, int q)` 로 p와 q를 같은 집합으로 만들고\n`find(int p)`로 p의 루트를 찾거나 `connected(int p, int q)`로 두 요소가 연결되었는가를 확인하는 알고리즘이다. \n\n```java\npublic interface UF {  \n    void union(int p, int q);  \n    boolean connected(int p, int q);  \n}\n```\n\n## Quick-find\n\n가장 기본적인 방법으로 id array에 각 요소를 매핑하고 `union(int p, int q)`가 호출되면 모든 id array를 loop로 돌며 p의 id와 같은 id를 q의 id로 변경하는 방법이다\n\n```java\npublic class QuickFindUF implements UF {  \n    private int[] id;  \n    public QuickFindUF(int N) {  \n        id = new int[N];  \n        for (int i = 0; i < N; i++) {  \n            id[i] = i; // id 배열 매핑\n        }  \n    } \n    @Override  \n    public boolean connected(int p, int q) {  \n        return id[p] == id[q];  // id 확인\n    }  \n    @Override  \n    public void union(int p, int q) {  \n        int pid = id[p];  \n        int qid = id[q];  \n        for (int i = 0; i < id.length; i++) {  \n            if (id[i] == pid) {  \n                id[i] = qid;  \n            }  \n        }  // p와 id가 같은 모든 id를 q의 id로 바꾼다 \n    }  \n}\n```\n\n- initialize : n\n- union : n\n- find : n\n\nn개의 요소에 n의 union은 n^2의 시간이 걸린다 \n\n## Quick-Union\n\nid array를 쓰는 것은 비슷하지만 이번에는 i의 부모를 id array에 매핑한다. 즉 `union(int p, int q)`를 호출하면 p의 부모의 id를 q의 부모의 id로 바꾼다. \n\n```java\npublic class QuickUnionUF implements UF {  \n    private int[] id; \n    public QuickUnionUF(int N) {  \n        id = new int[N];  \n        for (int i = 0; i < N; i++) {  \n            id[i] = i;  \n        }  \n    }  \n    private int root(int i) {        \n        while (i != id[i]) {  \n            i = id[i];  \n        }  \n        return i;  // 부모 루트를 최상단까지 찾는다 \n    }  \n    @Override  \n    public void union(int p, int q) {        \n        int i = root(p);  \n        int j = root(q);  \n        id[i] = j;  //p의 루트를 q의 루트로 바꾼다\n    }   \n    @Override  \n    public boolean connected(int p, int q) {  \n        return root(p) == root(q);  \n    }  \n}\n```\n- initialize : n\n- union : n (root 찾는 비용 포함)\n- find : n\n\nQuick-Find 보다 더 빠른 실행을 보이는 케이스도 있지만 알고리즘은 항상 최악의 경우를 상정해야 하므로 트리구조가 엄청나게 길거나 길이가 N이 될때 Quick-Find와 비슷하게 n^2의 실행시간을 가지게 된다\n\n## Quick Union 개선하기 \n\n### Weighting\n\n현재 Quick Union은 트리의 크기와 상관없이 무조건 p를 q의 루트에 갖다 \n붙이기 때문에 트리의 길이가 엄청나게 길어지는 문제점을 가지고 있다. \n\n하지만 union을 실행할때 트리의 사이즈를 비교하고 작은 트리를 보다 큰 트리에 연결하면 트리의 깊이를 짧게 유지할 수 있다\n\n```java\npublic class QuickUnionUF implements UF {  \n    private int[] id; \n    public QuickUnionUF(int N) {  \n        id = new int[N];  \n        for (int i = 0; i < N; i++) {  \n            id[i] = i;\n            sizes[i] = i; // size도 같이 매핑한다\n        }  \n    }  \n    private int root(int i) {        \n        while (i != id[i]) {  \n            i = id[i];  \n        }  \n        return i;\n    }  \n    @Override  \n    public void union(int p, int q) {        \n        int i = root(p);  \n        int j = root(q);  \n        if (i == j) {\n\t        return; //루트가 같으면 early return\n        }\n        if (size[i] < size[j]) {\n\t        id[i] = j;\n\t        size[j] += size[i]; \n        }\n        else {\n\t        id[j] = i;\n\t        size[i] += size[j]; //사이즈 비교 후 작은 트리를 큰 트리에 병합한다\n        }\n    }   \n    @Override  \n    public boolean connected(int p, int q) {  \n        return root(p) == root(q);  \n    }  \n}\n```\n\n- initialize : n\n- union : lg n(root 찾기 까지 포함)\n- find : lg n\n\n`왜 lg n의 비용으로 줄어들었을까?` \n\nT1의 크기가 3이고  T2의 크기가 5일때 T1에 있는 a를 T2에 있는 b에 연결시킨다고 가정해보자. \n\n이때 T1은 T2에 병합되고 a의 깊이는 1이 증가하게 된다. union을 호출할때 a의 깊이는 1이 증가하는데에 비해 a가 속한 트리의 크기는 3에서 8로 최소 2배이상이 증가하게 된다.\n\n이를 계속 실행하면 \n\n| a의 깊이 | 0 | 1 | 2 | 3 | ... | lg N |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| a가 속한 트리의 크기 | 1 | 2 | 4 | 8 |  | N |\n\n이 되기 때문에 find의 비용이 절감하게 된다\n\n### Path-Compressing\n\n위의 알고리즘을 Path-Compressing으로 더 개선할 수 있다   \n\n현재는 `root()`를 while문으로 모든 깊이의 노드를 반복하여 검색하고 있다.\n\n이 때 이 기능이 호출될때마다 각 호출된 노드의 id를 루트의 id로 바꿔주는 작업을 하면 트리의 깊이를 더 평탄하게 바꾸어 줄 수 있다.\n\n위의 코드의 root를 \n```java\n    private int root(int i) {        \n        while (i != id[i]) {  \n\t        id[i] = id[id[i]] // i의 루트를 부모 루트로!\n            i = id[i];  \n        }  \n        return i;\n    }  \n```\n이렇게 바꿔주기만 해도 트리의 깊이가 계속 평탄화 되면서 root를 호출하는 모든 기능의 비용이 절감된다. \n\n\n\n참고\nhttps://www.coursera.org/learn/algorithms-part1"},{"excerpt":"의존성이란 객체 지향 언어에서 A 객체가 B객체를 이용할때 A는 B를  고 표현한다.  A가 생성될 때 B가 필요할 수도 있고, A의 메서드의 파라미터로 B가 있을 수도 있다.  House객체가 Tv객체를 이용하는 예시를 들어보자 더이상 House객체가 변하지 않으면 위 코드는 문제가 없다.  하지만 House가 새로운 를 가져야 한다면? House를 테…","fields":{"slug":"/dependency_injection/"},"frontmatter":{"date":"January 11, 2024","title":"의존성 주입(Dependency Injection)","tags":["dependency_injection","java"]},"rawMarkdownBody":"\n## 의존성이란\n\n객체 지향 언어에서 A 객체가 B객체를 이용할때 A는 B를 `의존한다` 고 표현한다.  A가 생성될 때 B가 필요할 수도 있고, A의 메서드의 파라미터로 B가 있을 수도 있다. \n\nHouse객체가 Tv객체를 이용하는 예시를 들어보자\n\n```java\npublic class House {\n\tprivate Tv tv = new Tv(); // House는 Tv에 의존한다\n\t\n\tpublic House() {\n\t}\n}\n```\n\n더이상 House객체가 변하지 않으면 위 코드는 문제가 없다. \n\n하지만 House가 새로운 `SmartTv`를 가져야 한다면? House를 테스트할 때 다른 Tv 종류를 넣어보고 싶다면?\n\nTv를 인터페이스화 해서 다른 Tv를 넣을 수는 있지만 임시방편일 뿐이다. \n\n```java\npublic class House {\n\t//Tv tv = new Tv(); \n\tprivate Tv tv = new SmartTv(); //tv에 다른 구현체를 넣었지만..\n\t\n\tpublic House() {\n\t}\n}\n\npublic interface Tv {\n\tvoid turnOn();\n}\n\npublic class SmartTv implements Tv {\n\t// some logic\n}\n```\n\n이렇게 객체가 다른 객체에 강한 의존성을 지니면 코드를 재사용하거나 확장하는데에 문제점이 생긴다.\n\n## 의존성을 주입하자 \n\nHouse가 여러 Tv를 사용하는 것에 제약이 생긴 이유는 House가 어떠한 종류의 Tv를 자신의 상태로 가질지 미리 알고 있었기 때문이다 .\n\nDependency Injection은 객체 간의 의존관계를 느슨하게 설정해놓고 Compile Time이 아닌 Runtime에 객체가 의존하고 있는 객체를 생성 후 넣어주는 방식을 의미한다.\n\n\n- 생성자를 이용하는 방식\n\n```java\npublic class House {\n\tprivate Tv tv; //House는 어떤 Tv를 가질지 모른다\n\t\n\tpublic House(Tv tv) {\n\t\tthis.tv = tv; //외부에서 이미 생성된 tv를 주입받는다\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tHouse house = new House(new Tv()); //주입\n\t}\n}\n```\n\n- setter를 이용하는 방식\n\n```java\npublic class House {\n\tprivate Tv tv; //House는 어떤 Tv를 가질지 모른다\n\t\n\tpublic void setTv(Tv tv) {\n\t\tthis.tv = tv; //외부에서 이미 생성된 tv를 주입받는다\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tHouse house = new House();\n\t\thouse.setTv(new Tv()); //주입\n\t}\n}\n```\n\n## 의존성 주입의 장점\n\n1.  A가 B의 변경을 알 필요가 없어진다\n\nTv를 생성할때 리모컨, 버튼, 안테나 등 다양한 요소가 필요하다고 해보자. 의존성이 강할 때 Tv가 변경되면 House도 같이 변경되어야 했다. \n하지만 의존성을 주입하면 Tv가 어떻게 변경되어도 House객체 내의 코드는 수정할 필요가 없어진다. \n\n2.  A를 테스트하기 쉬워진다\n\nA와 B의 의존관계가 느슨해졌기 때문에 A와 B를 독립적으로 테스트 하는 것이 쉬워졌고 \nA에 interface화한 Tv의 여러 구현체를 주입시키는 테스트도 가능해진다. \n\n```java\n@Test  \nvoid test() {  \n    House house1 = new House(new Tv());  \n    House house2 = new House(new SmartTv());  \n}\n```\n\n\n3.  A의 public API가 명시적이게 된다\n\n의존성을 주입하기 전 House의 API를 보자\n```java\npublic class House()\n```\nHouse의 코드를 열어보지 않는 한 House가 Tv를 가지고 있는지 알 길이 없다. \n\n의존성을 주입한다면 \n```java\npublic class House(Tv tv);\n```\n가 될 것이고 House를 사용하고자 하는 다른 개발자들은 누구나 House가 Tv를 의존하는 객체임을 알 수 있다.\n"},{"excerpt":"개인 과제에서 을 적용해 코드를 개선한 기록 Builder Pattern? Effective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다.  Builder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객…","fields":{"slug":"/builder_pattern/"},"frontmatter":{"date":"January 09, 2024","title":"Builder Pattern으로 코드 개선하기","tags":["builder_pattern","java"]},"rawMarkdownBody":"\n개인 과제에서 `Builder Pattern`을 적용해 코드를 개선한 기록\n\n---\n## Builder Pattern?\n\nEffective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다. \n\nBuilder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객체를 생성하는 기법이다. \n\n## Menu\n\n```\npublic class Menu {    \n    private final String name;  \n    private final String description;  \n    private final double price;  \n    private final List<Option> options;\n}\n```\n와 같은 네 개의 멤버 변수를 가진 Menu 클래스를 만드려 한다. \n`name`과 `price`는 필수적으로 포함되어야 하지만 `description`과 `options`는 메뉴에 따라 있을 수도, 없을 수도 있는 선택 매개변수이다.\n\n## 첫 번째 시도, public 생성자\n\n```\npublic Menu(String name, String description, double price, List<Option> options) {\n\tthis.name = name;\n\tthis.description = description;\n\tthis.price = price;\n\tthis.options = options\n}\n```\n가장 기본적인 public 생성자이다. \n얼핏 보면 아무 문제도 없어보이지만 `Menu`를 인스턴스화하며 코드에서 사용하려 해보자\n```\nnew Menu(\"Shack Burger\", \"너무 맛있는 쉑버거\", 6.5, List.of(new   Option(\"Regular\", 0),  \n        new Option(\"Large\", 0.9))\n```\n이 코드는\n\n1.  같은 String타입의 `name`과 `descripton`이 정확한 순서로 쓰여져야 하고\n2.  `description`, `options`가 필요없는 경우를 대처할 수 없기 때문에\n\nMenu를 인스턴스화 할때마다 Menu의 생성자를 매번 확인해야 한다.  \n\n## 두번째 시도 Telescoping Constructor (점층적 생성자) \n\n위의 코드를 조금 개선해보자.\n```\npublic Menu(String name, String description, double price, List<Option> options) {  \n    this.name = name;  \n    this.description = description;  \n    this.price = price;  \n    this.options = new ArrayList<>(options);  \n}  \n  \npublic Menu(String name, double price) {  \n    this(name, \"\", price, new ArrayList<>());  \n}  \n  \npublic Menu(String name, String description, double price) {  \n    this(name, description, price, new ArrayList<>());  \n}\n\npublic Menu(String name, double price, List<Options> options) {\n\tthis(name, \"\", price, options);\n}\n```\n\n점층적 생성자를 이용해 `description`, `options`모두 없는 경우, 하나만 없는 경우의 조합을 상정하고 순서대로 `this()`를 호출하며 생성시 주어지지 않은 파라미터는 default 값을 이용하도록 해보았다.\n\n점층적 생성자를 이용해 이제 \n\n```\nnew Menu(\"Burger\", 1000)\n```\n\n위와 같은 Menu의 생성도 가능해지게 되었다.\n\n하지만 점층적 생성자 또한\n\n1. 순서를 기억하기 어렵고, \n2. Menu가 더 많은 파라미터를 요구하게 될 시의 조합을 가진 생성자를 더 생성해야 하기 때문에\n\n유지보수가 어렵다는 문제가 여전히 남아 있다. \n\n## 세번째 시도, Builder Pattern\n\n이러한 Menu 클래스를 Builder Pattern을 이용하여 리팩토링 해보았다.\n```\npublic static class Builder {  \n  \n    private final String name;  \n    private final double price;  \n  \n    private String description = \"\";  \n    private List<Option> options = new ArrayList<>();  \n  \n    public Builder(String name, double price) {  \n        this.name = name;  \n        this.price = price;  \n    }  \n  \n    public Builder description(String description) {  \n        this.description = description;  \n        return this;    }  \n  \n    public Builder options(List<Option> options) {  \n        this.options = new ArrayList<>(options);  \n        return this;    }  \n  \n    public Menu build() {  \n        return new Menu(this);  \n    }  \n}\n\nprivate Menu(Builder builder) {  \n    this.name = builder.name;  \n    this.description = builder.description;  \n    this.price = builder.price;  \n    this.options = builder.options;  \n}\n```\n\nMenu 클래스 생성자의 접근제어자를 `private`으로 두고 내부 클래스로 Builder를 만들었다.  `private`생성자는 `Builder`가 가져다준 매개변수를 저장한다. \n\nBuilder는 기본적으로 필수적인 매개변수인 `name`과 `price`를 생성자의 파라미터로 받고 선택적인 매개변수인 `description` 과 `options`를 초기화를 해주었다.\n\n필수 매개변수만 받고 나머지는 메서드 체이닝을 통해 setter와 같은 역할을 하며 마지막으로 `build()`메서드로만 Menu를 인스턴스화 할 수 있게 했다. \n\n이를 통해 \n```\nnew Menu.Builder(\"Shack Burger\", 6.5)  \n        .description(\"너무 맛있는 쉑버거\")  \n        .options(List.of(new Option(\"Single\", 0),  \n                new Option(\"Double\", 3.6)))  \n        .build()\n```\nMenu를 위와 같이 인스턴스화 할 수 있게 되었다. \n\n그리하여\n1. 생성자에 대한 컨트롤   \n정해진 방식으로만 객체가 생성될 수 있게 했고 \n\n2. 가독성    \n생성자 파라미터에 메서드 명을 붙임으로써 객체 생성시의 실수가 줄어든다. \n같은 타입의 멤버 변수를 파라미터로 받아 들일 시 순서가 헷갈리거나 잘못된 값을 저장할 수 있는 문제도 메서드 명을 지정해야 하므로 방지 할 수 있다.  \n\n3. 확장성  \n메서드를 추가하면 되기 때문에 4개 그 이상의 파라미터 확장 혹은 파라미터에 대한 검증 추가에 더 유연하게 대처할 수 있다 \n\n## 내가 느낀 Builder Pattern의 단점\n\n빌더 패턴을 사용하며 느낀 단점은\n\n1.  바로바로 생성할 수 있는 public 생성자와 달리 코드를 작성하는데 비용이 든다.\n2.  매개변수가 적은 경우 오히려 객체가 무거워진다 \n\n정도다. 하지만 테스트 코드 작성같이 다른 객체에서 Menu를 인스턴스화 할때 객체 생성에 실수가 줄어들고 이미 생성하고 있는 Menu 코드에 새로운 option을 추가한다거나 설명을 바꿀 때 편리함을 느껴서 매개변수가 많을 때는 Builder Pattern을 많이 사용할 것 같다."},{"excerpt":"'모든 개발자를 위한 HTTP'강의를 수강한 학습 기록 캐시란? 컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다\nCPU에서 캐시메모리는 CPU, 메모리 사이에 위치하여 자주 쓰이는 데이터를 임시로 저장하여 둘 사이의 거리에 따른 접근시간을 줄이는데 사용된다.  캐시는 다양한 종류가 있지만 웹에서의 캐시도 CPU의 캐시 메모리와 비슷하…","fields":{"slug":"/http_cache/"},"frontmatter":{"date":"January 03, 2024","title":"웹 서비스 캐시","tags":["http","cache"]},"rawMarkdownBody":"\n'모든 개발자를 위한 HTTP'강의를 수강한 학습 기록\n\n## 캐시란?\n\n컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다\nCPU에서 캐시메모리는 CPU, 메모리 사이에 위치하여 자주 쓰이는 데이터를 임시로 저장하여 둘 사이의 거리에 따른 접근시간을 줄이는데 사용된다. \n\n캐시는 다양한 종류가 있지만 웹에서의 캐시도 CPU의 캐시 메모리와 비슷하게 `자주 쓰이는 데이터를 가까운 곳에 저장하여 데이터 접근 시간을 줄인다` 는 원리를 가진다.\n\n## 웹 브라우저 캐시\n\n클라이언트에서 서버에 요청하여 10mb의 코끼리 이미지를 다운로드 받는다고 생각해보자.    \n\n캐시가 없다면 첫번째 요청에서는 10mb의 데이터를 전송받아야하지만 같은 사이트에 몇번이고 방문한다면 여러번의 요청마다 10mb의 데이터를 매번 다운로드 받아야 한다. 이러면 웹페이지의 로딩 속도는 매우 느려지고 좋지 않은 사용자 경험을 선사한다.\n\n반면 웹 브라우저를 사용하는 사용자의 로컬 환경에 캐시데이터를 저장하고 사용자가 같은 요청(코끼리 그림을 브라우저에 그려주세요)을 할 때는 서버에서 다운로드를 다시 받지 않고 캐시데이터를 바로 사용한다면 웹 페이지의 로딩 속도는 비약적으로 상승할 것이다. \n\n### 웹 브라우저 캐시 적용\n\n웹 브라우저에서 서버로 코끼리 그림을 최초로 요청하면 서버는 이에 대해`cache-control: max-age` 헤더를 포함한 응답을 준다.\n\n간단한 응답예시\n```\nHTTP/1.1 200 OK\nContent-Type:image/jpeg\nCache-Control: max-age=60\nContent-Length: 10295\n\n//\n{elephant image data}\n//\n```\n\n이때 `max-age` 에 해당하는 숫자는 이 캐시가 유효한 초단위를 의미한다.\n\n즉 이 코끼리 그림은 로컬의 캐시 저장소에서 60초간 유효하며 이 시간안에 클라이언트가 코끼리 그림을 다시 요청하면 서버에서 다시 코끼리 그림 데이터를 다운받는 게 아니라 캐시 저장소에 있는 복사된 데이터를 브라우저에서 렌더링 하게 되는 것이다.\n\n### 캐시 유효기간 \n\n당연히 캐시 유효기간이 지난 데이터의 경우 서버에 재요청을 하여 다시 다운로드 받아야 한다. 이 때 유효기간이 지난 캐시를 Stale하다라고 표현한다.    \n\n하지만 캐시 유효 기간이 지났지만 서버의 원본 데이터가 변경되지 않은 경우, 같은 데이터인데도 다시 다운로드 받아야 하면 이는 굉장히 비효율적이다. 이를 위해 캐시와 원본이 같은 데이터인지 검증하고, 같은 데이터라면 캐시를 사용하는 절차가 필요하다.\n\n## 캐시 유효성검증(Validation)과 조건부 요청(Conditional Request)\n\n캐시 데이터가 원본 데이터와 같은지 검증하기 위해 크게 두가지 방법을 사용한다\n\n### Last-Modified / If-Modified-Since\n\n첫 번재 방법은 원본 데이터가 마지막으로 수정된 시간을 응답 메시지 헤더로 추가하는 방법이다. \n\n```\nHTTP/1.1 200 OK\nContent-Type:image/jpeg\nCache-Control: max-age=60\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added\nContent-Length: 10295\n\n//\n{elephant image data}\n//\n```\n이제 캐시 저장소에 코끼리 그림과 이 원본 데이터가 마지막으로 수정된 시각까지 저장을 하게 된다. 이제 클라이언트는 요청을 할때 \n```\nGET /elephant.jpg\nif-modified-since: Wed, 21 Oct 2015 07:28:00 GMT\n```\n'이 이후로 원본이 수정되었으면' 이라는  조건부 요청을 보내고 서버에서는 이러한 조건부 요청에 따라    \n조건이 만족하면(수정 되었으면) 200 OK로 다시 10mb의 코끼리 그림을 전송하고 조건을 불만족하면(수정 되지 않았다면 )\n```\nHTTP/1.1 304 Not Modified\nContent-Type:image/jpeg\nCache-Control: max-age=60\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added\nContent-Length: 10295\n\n//\n\n//\n```\n10mb의 message body가 생략된 304 Not Modified의 응답 메시지를 보낸다. \n\n위 방법은 합리적으로 보이지만 단점도 가지고 있다\n1. 1초 미만 단위로 캐시 조정이 불가능하고\n2.  A->B->A 처럼 원본데이터가 수정되었지만 수정 전과 같은 데이터 일때\n3. 스페이스, 주석 변경처럼 크게 영향이 없는 경우\n에도 모두 재다운로드가 발생하기 때문이다.\n\n\n### ETag / If-None-Match\n\n\n위의 단점을 보완하고 캐시 로직을 서버에서 관리하고 싶을 때 ETag(Entity Tag)를 이용하게 된다 .\nETag는 각각의 캐시될 원본 데이터에 해쉬코드를 달아준다고 생각하면 된다. 데이터가 변경되고 이 데이터가 클라이언트에서 다시 다운로드 받아야 된다고 판단될 때 ETag를 변경해주면 된다. \n\n서버는 최초 응답 메시지에 코끼리 데이터와 함께 ETag를 제공한다.\n```\nHTTP/1.1 200 OK\nContent-Type:image/jpeg\nCache-Control: max-age=60\nETag: \"aaaaaaa\" //added\nContent-Length: 10295\n\n//\n{elephant image data}\n//\n```\n캐시 저장소는 이제 코끼리 그림 데이터를 ETag와 함께 저장하고 \n\n재요청시 조건부 요청을 보내게 된다.\n```\nGET /elephant.jpg\nif-none-match: \"aaaaaaa\"\n```\n위와 마찬가지로 조건을 불만족하면(수정 되지 않았다면 ) 서버는 304 상태코드와 메시지 바디가 없는 응답 메시지를 보내고 클라이언트는 캐시 저장소에 있는 코끼리 그림을 웹 브라우저에 렌더링한다.\n\n## 캐시 지시어\n\n캐시를 제어하는 방법은 위의 방법만 있는 게 아니다. 항상 최신이 되어야 하는 데이터나 개인정보 처럼 캐시를 해서는 안되는 데이터도 있기 때문이다.\n\nCache-directive(캐시 지시어)로 해당 데이터의 캐시가 어떻게 적용될지 설정할 수 있다. \n\n###  Cache-Control: no-cache\n\n데이터를 캐시해도 되지만 항상 Origin서버에 검증하고 사용되어야 하는 데이터다. 즉, 항상 최신의 데이터를 가지게 하고 싶을 때 사용한다\n\n### Cache-Control: no-store\n\n민감한 정보가 포함된 데이터이므로 캐시해서는 안된다.\n\n### Cache-Control: must-revalidate\n\n캐시 만료 후 최초조회시 Origin서버에 검증해야한다\nOrigin 서버 접근 실패시 반드시 오류가 발생해야한다.\n\n### Cache-Control: public\n\n응답이 public 캐시에 저장되어도 된다 (프록시 서버에 저장되어도 된다)\n\n### Cache-Control: private\n\n응답이 해당 사용자 만을 위한 것 private 캐시에 저장해야함(기본값)\n\n"},{"excerpt":"'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB Process Control Block 모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.…","fields":{"slug":"/process_thread/"},"frontmatter":{"date":"December 28, 2023","title":"프로세스와 스레드","tags":["process","thread","operating_system"]},"rawMarkdownBody":"\n'혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용\n## 프로세스 \n\n### Process? Program?   \n우리는 흔히 `프로그램을 실행한다` 라고 말한다.\n이는 '보조기억장치에 있는 데이터 뭉치'인 `프로그램`을  '메모리에 적재하고 cpu가 실행'하여 `프로세스`화 한다와 같은 말이다. \n\n### PCB Process Control Block    \n모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.\n그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 `PCB`라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.\n\n>[PCB에 저장되는 정보]   \n>PID(Process ID) : 프로세스 고유의 번호\n>Registers: 레지스터의 중간값   \n>Process state: 대기,준비, 실행 등의 프로세스 상태  \n>CPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보   \n>Memory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블    \n>List of Open files : 입출력장치 정보\n\n### 이 PCB로 어떻게 관리하나?\nCPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. \n\n이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. \n\n이 중간 정보는 `문맥Context`으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 `문맥 교환 Context Switching` 이라고 한다. \n(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)\n\n>[동시에 실행되는 것 '처럼' 보인다]   \n>프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.   \n>정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.\n\n## 프로세스의 구성\n\n`정적 할당 영역`   \n코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only\n\n데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터 \nex) 전역변수, 상수\n\n`동적 할당 영역`   \n힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간 \nex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) \n\n스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터 \nex)매개변수, 지역변수 \n\n*즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다*\n\n## 프로세스의 상태\n\n프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다. \n입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다. \n그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. \n\n- 생성 상태(new)\n- 준비 상태(ready)\n- 대기상태(blocked) \n- 실행상태(running)\n- 종료상태(terminated)\n\n`준비상태 vs 대기상태`   \n준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다. \n준비상태에서 실행상태가 되는 것을 **dispatch**라고 한다 \n\n대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 **준비상태**가 된다. \n\n## 스레드\n\n### 프로세스와 스레드\n\n스레드는 `프로세스를 구성하는 실행 단위`를 의미한다 \n스레드는 **프로세스의 자원**을 공유하며 여러개가 존재 할 수 있다. \n스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. \n\n### 멀티스레드\n\n멀티프로세스와 비슷하게 스레드 또한 문맥교환을 하며 동시성을 가지고 처리된다. \n\n멀티스레드는 한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.\n\n하지만 자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다\n\n### 프로세스와 스레드의 동기화 문제 \n\n```java\npublic class Calculator {  \n    static int count = 0;  \n  \n    public static void main(String[] args) {  \n        int max = 10;  \n  \n        for (int i = 0; i < maxCount; i++) {  \n            new Thread(() -> {  \n                count++;  \n                System.out.println(count);  \n            }).start();  \n        }  \n    }  \n}\n```\n위 코드는 얼핏 보면 문제가 없어보이지만 \n```\n1\n3\n4\n2\n5\n6\n```\n실행결과는 뒤죽박죽인채로 나온다.   \n이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 때 이 멀티 스레드는 '`Synchronization Issue`를 가진다'라고 한다.\n\n### 프로세스 동기화 문제? 스레드 동기화 문제?\n\n둘 다 동기화 문제를 가질 수 있다.   \n위 예시에서는 스레드의 동기화를 사용했지만 `실행의 흐름`을 가지는 모든 것들이 동기화 문제를 내재하고 있다.   \n\n예를 들어 `Book.txt`를 쓰는 프로세스 A와 같은 파일을 읽는 프로세스 B가 있다면 두 프로세스가 공유자원에 접근할 수 있다는 것이고 `A->B`의 정해진 순서대로 실행되어야 하기 때문이다. "},{"excerpt":"Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은  과  이다.  처음에는 로 웹사이트를 만들었지만 몇 가지 고치고 싶은…","fields":{"slug":"/gatsby_website/"},"frontmatter":{"date":"December 26, 2023","title":"Gatsby와 Github Pages로 개인 블로그 만들기","tags":["gatsby","github_pages"]},"rawMarkdownBody":"\n## Gatsby로 Github pages 개인 블로그 만들기\n\nTIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 `Jekyll` 과 `Gatsby` 이다. \n\n처음에는 `Jekyll`로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 `Gatsby`로 프레임워크를 바꾸게 되었다.\n\n나는 미리 만들어진 [테마](https://github.com/devHudi/gatsby-starter-hoodie) 를 사용했다.(감사합니다)\n\n## Gatsby 설치 와 웹사이트 설정\n\nGatsby cli를 설치해준다 \n```\nnpm install -g gatsby-cli\n```\n\n`Gatsby Starter Library`에서 마음에 드는 테마를 선택할 수 있다.\n원하는 테마를 고른 뒤\n\n```\nnpx gatsby new {local-folder-name} {theme-name}\n```\n을 실행해 로컬에 Gatsby 템플레이트를  만든다.\n\n```\ncd {local-folder-name}\ngatsby develop\n```\n을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 `http://localhost:8000`이다. \n\n## Github Repository연결\n\nGithub의 새 리포지토리를 생성한다.\n나는 `{username}.github.io`로 이름을 지정했다. \n다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면 \n[Gatsby 공식문서](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/) 를 참고하길 바란다\n\n리포지토리를 생성했다면\n```\ngit remote add origin {github-https-address}\n```\n를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.\n\n그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 \n```\ngit add .\ngit commit -m \"{commit-name}\"\ngit push origin main\n```\n위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.\n\n## 배포 방법 정하기\n\n배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다\n\n1. Netlify\nGithub과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.\n[A Step-by-Step Guide: Gatsby on Netlify](https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/) 공식문서\n2. Github pages\nGithub pages에서 제공하는 `gh-pages`를 이용하여 배포할 수 있다\n[How Gatsby Works with GitHub Pages](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/)공식 문서\n\n나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 `{smt}.netflify.app`를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 `{smt}.github.io` 도메인이 마음에 들어서다(...)\n\n\n## Github Pages로 배포하기 \n\n배포용 브랜치 설정\ngh-pages는 배포용 브랜치가 따로 있어야 한다.   \n우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 `.gitignore`에서 public을 푸쉬하지 않게 설정되어 있다.\n\n현 상태에서 배포용 브랜치를 하나 만들어 둔다.\n```\ngit branch deploy\n```\n\n이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다. \n`gh-pages`패키지를 설치하자.\n\n```\nnpm install gh-pages\n```\n\n>[Trouble Shooting]   \n나는 npm install 과중에서 dependency conflict가 발생했다.   \nnode 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다\n\n>-> 위의 install 커맨드에 `--force` 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 `--legacy-peer-deps`로 자동설치를 막는 방법이 있다. 나는 `--force`로 설치했다.\n\n\n다음은 `package.json` 에 배포에 사용할 스크립트를 추가해주면 된다.\n```\n\"scripts\": {\n    \"deploy\": \"gatsby build && gh-pages -d public -b deploy\"\n}\n```\n\n그리고\n```\nnpm run deploy \n```\n를 실행한다.   \n   \n>[Trouble Shooting]   \n>위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 `npm run clean`으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.\n\n이후\nGithub repository의 Settings-Pages\n`Build and deployment`에서 배포용 브랜치로 전환해준다.\n\n이렇게 까지 하면 `Actions`에서 웹사이트를 배포해주고 브라우저에서\n```\nhttps://{user-name}.github.io/\n```\n 주소로 접속이 가능해진다. \n\n"},{"excerpt":"정적 팩토리 메서드란? Java에서는   연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에  메서드를 사용하여 인스턴스를 반환 받는 기법이 있다. 간단한 예시로 사용방법을 알아 보자.  이  클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에  를 추가함으로써 인스턴스를 반환 받는 다른  를  생성하는 기법이라고 할 수 있다.  정적팩토리 …","fields":{"slug":"/staticfactorymethod/"},"frontmatter":{"date":"December 24, 2023","title":"정적 팩토리 메서드, 언제 쓸까?","tags":["java","staticfactorymethod"]},"rawMarkdownBody":"## 정적 팩토리 메서드란?\n\nJava에서는 `new`  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 `static` 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.\n\n간단한 예시로 사용방법을 알아 보자. \n```java\nclass Car {  \n    String name;  \n  \n    Car(String name) {   \n        this.name = name;  \n    }  \n}\n```\n\n이 `Car` 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에\n```java\nstatic Car from(String name) {  \n    return new Car(name);  \n}\n```\n\n`정적 팩토리 메서드` 를 추가함으로써 인스턴스를 반환 받는 다른 `통로` 를  생성하는 기법이라고 할 수 있다. \n\n## 정적팩토리 메서드, 왜 쓰나?\n\n`Effective Java`는 1장에서 `생성자 대신 정적 팩토리 메서드를 고려하라` 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 [링크](https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/)   \n이 포스트에서는 내가  **개인적으로** 언제 이 기법을 사용하는지 서술해 보려고 한다.\n\n### 이름이 있는 것이 나은 경우\n\n위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자\n\n```java\npublic void createCar(String input) {  \n    Car car1 = new Car(input);  \n    Car car2 = Car.from(input);  \n}\n```\n\n위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다. \n`new` 연산자는 `이 Car는 input을 멤버 변수로 가지는군` 이라면\n`from` 은 `이 input은 객체 내에서 특정한 로직으로 변환되겠군` 이라는 멘탈 모델을 제공한다. \n\n`이름을 가질 수 있다` 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.\n\n### 한 가지 방법으로만 객체가 생성되게 하고 싶을 때\n\n우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.\n\n```java\nclass User {  \n    int id;  \n  \n    private User(int id) {  \n        this.id = id;  \n    }  \n  \n    static User from(int id) {  \n        if (isInvalidId(id)) {  \n            return null;  \n        }  \n        return new User(id);  \n    }  \n}\n```\n\n따라서 이 때는 `private` 으로 `new`연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.\n이는 `싱글톤패턴` 의 사용과도 일맥상통한다\n\n### 같은 객체가 여러번 쓰여야할 때\n\n같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에*만*  객체를 생성해 메모리를 아낄 수 있다.\n```java \nclass CarFactory {  \n  \n    static final Map<String, Car> cars = new HashMap<>();  \n  \n    static {  \n        cars.put(\"a\", new Car(\"a\"));  \n        cars.put(\"b\", new Car(\"b\"));  \n        cars.put(\"c\", new Car(\"c\"));  \n    }  \n\t  //if cache doesn't contains key, only then instantiate new car\n    static Car from(String text) {  \n        if (cars.containsKey(text)) {  \n            return cars.get(text);  \n        }  \n        return new Car(text);  \n    }  \n}\n```\n\n\n>[정리]   \n 1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우   \n 2.지정된 경우 이외의 객체 생성을 막고 싶은 경우   \n 3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 \n\n이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.\n\n## private으로 생성자 막기\n\n`Effective Java` 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 `Composition`을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. \n\n```java\nclass CarSet {  \n    private final Map<Car, String> cars;  \n    \n    public CarSet(Map<Car, String> cars) {  \n        this.coins = new HashMap<>(cars);  \n    }  \n  \n    public static CarSet from(String text) {  \n        //Complicated Logic..   \n        //..  \n        return new CarSet(cars);  \n    }  \n}\n```\n하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다\ntext를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 `재사용성` 이 늘어날 수 있기 때문이다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}