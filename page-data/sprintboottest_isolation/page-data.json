{"componentChunkName":"component---src-templates-post-jsx","path":"/sprintboottest_isolation/","result":{"data":{"site":{"siteMetadata":{"title":"Hiyen"}},"markdownRemark":{"id":"7e50230d-e72f-5a04-acf7-7fe60fd8536e","excerpt":"완성된 코드는 링크에서 볼 수 있습니다. (글의 코드와 조금 다른 면이 있을 수 있습니다) @SpringBootTest와 @Transactional @Transactional을 어노테이션 자체에서 포함하고 있는 @DataJpaTest와 달리 @SpringBootTest는 @Transactional을 가지고 있지 않다. 따라서 트랜잭션-롤백 환경을 @Spr…","html":"<p>완성된 코드는 <a href=\"https://github.com/jinkshower/Todo-management\">링크</a>에서 볼 수 있습니다. (글의 코드와 조금 다른 면이 있을 수 있습니다)</p>\n<h2>@SpringBootTest와 @Transactional</h2>\n<p>@Transactional을 어노테이션 자체에서 포함하고 있는 @DataJpaTest와 달리 @SpringBootTest는 @Transactional을 가지고 있지 않다.</p>\n<p>따라서 트랜잭션-롤백 환경을 @SprintBootTest에서 만들기 위해서는 </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@SpringBootTest</span>  \n<span class=\"token annotation punctuation\">@Transactional</span>  \n<span class=\"token annotation punctuation\">@Rollback</span>  \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ControllerTest</span> <span class=\"token punctuation\">{</span>   \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드처럼 test 클래스에 @Transactional과 @Rollback을 명시해줘야 한다</p>\n<h2>RandomPort를 사용할때의 @SpringBootTest</h2>\n<p>하지만 RestAssured와 같은 프레임워크를 사용하는 인수테스트에서는 어노테이션으로 Port를 지정하게 되는데 이 때 HTTP 클라이언트와 서버는 각각 다른 스레드에서 실행된다.</p>\n<p>즉 @Transactional로 트랜잭션 설정을 해도 다른 스레드에서 커밋을 해버리기 때문에 테스트 격리가 되지 않는다. </p>\n<p><img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/b3265dbe-be08-44fb-892a-555a71f56e72\" alt=\"Pasted image 20240304114747\"></p>\n<p>각 테스트는 따로 실행했을 때 제대로 통과하는 테스트지만 같이 실행되었을 때 줄줄이 실패하는 모습을 볼 수 있다.</p>\n<h2>해결책 1. @DirtiesContext</h2>\n<p>가장 간단하게 테스트를 격리할 수 있는 방법이 있다.</p>\n<p><code class=\"language-text\">@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)</code>\n를 테스트 클래스 어노테이션으로 선언하여  각 테스트 메서드가 실행될 때마다 컨텍스트를 새로 로드함을 명시한다.</p>\n<p>즉, 테스트 메서드마다 다른 컨텍스트를 사용하기 때문에 트랜잭션 외부에서 데이터를 커밋하여 변경하는 테스트에 영향받지 않고 각 메서드마다 db의 테이블을 새롭게 만들 수 있다.</p>\n<p><img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/a32fed4a-4ded-4428-a449-cc9a7e093af3\" alt=\"Pasted image 20240304115424\"></p>\n<p>적용 이후 모든 테스트가 통과함을 확인할 수 있다.</p>\n<h3>@DirtiesContext의 문제점</h3>\n<p>이렇게 편한 어노테이션이지만 치명적인 단점이 있으니 바로 속도가 많이 느리다는 것이다. </p>\n<p>원래 @SpringBootTest는 테스트 클래스에서 컨텍스트를 한 번 로드하고 이미 컨텍스트가 있다면 캐싱해서 사용하기 때문에 매번 컨텍스트를 다시 로드하는 @DirtiesContext는 필연적으로 속도가 느릴 수 밖에 없다.</p>\n<h2>해결책2. 매 테스트마다 테이블을 Truncate하기</h2>\n<p>위의 문제를 좀더 빠르게 해결할 수 없는 지 방법을 계속 찾아봤다.</p>\n<p>일단 가장 먼저 @AfterEach에 테스트에서 사용하는 repository의 deleteAll() 메서드를 호출하는 방식을 적용해봤다. </p>\n<p>하지만 deleteAll()은 특정 엔티티에 대한 레코드를 삭제하므로 연관관계가 맺어져 있는 엔티티에 대한 삭제가 제대로 이루어지지 않았다.</p>\n<p>따라서 테이블 데이터를 모두 삭제하는 truncate를 사용하게 되었다.</p>\n<h3>h2의 truncate</h3>\n<p>테스트 db로 h2를 사용하고 있기 때문에 truncate 쿼리를 사용하기 위해서는 테이블의 제약조건을 무효화하고 실행해야 한다</p>\n<p>따라서 </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token constant\">SET</span> <span class=\"token constant\">REFERENTIAL_INTEGRITY</span> <span class=\"token constant\">FALSE</span>\n<span class=\"token constant\">TRUNCATE</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token constant\">SET</span> <span class=\"token constant\">REFERENTIAL_INTEGRITY</span> <span class=\"token constant\">TRUE</span></code></pre></div>\n<p>로 truncate 이후 다시 제약조건을 걸어주는 쿼리를 작성해야 했다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@AfterEach</span>  \n<span class=\"token keyword\">void</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SET REFERENTIAL_INTEGRITY FALSE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TRUNCATE TABLE users\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TRUNCATE TABLE todos\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SET REFERENTIAL_INTEGRITY TRUE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>테스트 클래스 내에서 jdbcTemplate를 사용해 쿼리를 작성해서 실행 시켜 줬다.</p>\n<p><img src=\"https://github.com/jinkshower/jinkshower.github.io/assets/135244018/8d152e82-5e91-4699-afa0-7a5bade9685a\" alt=\"Pasted image 20240304122429\"></p>\n<p>@DirtiesContext사용 보다 총 테스트 시간이 절반으로 줄어든 모습</p>\n<h3>아쉬운 점</h3>\n<p>이렇게 빠른 테스트 속도와 격리를 얻어냈지만 아쉬움이 남았다.\n매번 @AfterEach에 위의 코드를 작성해야 한다는 점, 테이블이 늘어나면 그만큼 쿼리문도 늘어나는 단점을 여전히 가지고 있다.</p>\n<h2>관심사 분리</h2>\n<p>관심사를 분리하여 @AfterEach에 있는 데이터베이스 초기화 코드를 다른 클래스로 분리하면 매번 테이블을 확인할 필요도 없고, 다른 테스트 클래스에도 재사용할 수 있지 않을까?</p>\n<p>테스트마다 생성된 테이블의 이름을 얻어내 각각을 truncate쿼리를 자동으로 만든다면 가능할 것 같다.</p>\n<h3>테이블 이름 얻기</h3>\n<p>대부분의 관계형 데이터베이스는 생성된 테이블들의 메타정보를 가지고 있는 정보성 테이블이 존재한다. </p>\n<p>h2는 information_schema라는 테이블에 메타정보를 저장하는데, 해당 테이블에 있는 모든 메타정보는 <a href=\"https://www.h2database.com/html/systemtables.html\">공식문서</a>를 참고하면 될 것같다.</p>\n<p>내가 관심있는건 테이블이름들이니</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token constant\">SELECT</span> <span class=\"token constant\">TABLE_NAME</span> <span class=\"token constant\">FROM</span> <span class=\"token constant\">INFORMATION_SCHEMA</span><span class=\"token punctuation\">.</span><span class=\"token constant\">TABLES</span> <span class=\"token class-name\">WHERE</span> <span class=\"token constant\">TABLE_SCHEMA</span> <span class=\"token operator\">=</span> <span class=\"token char\">'PUBLIC'</span></code></pre></div>\n<p>라는 쿼리를 작성하면 될 것같다. </p>\n<h3>truncate 쿼리 작성</h3>\n<p>이렇게 얻은 테이블 이름을 자료구조에 저장하고 각 테이블이름마다 반복하여</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token constant\">TRUNCATE</span> <span class=\"token constant\">TABLE</span> <span class=\"token string\">\" + tableName + \"</span> <span class=\"token constant\">RESTART</span> <span class=\"token constant\">IDENTITY</span></code></pre></div>\n<p>를 실행하면 직접 일일히 입력해주지 않아도 쿼리문이 실행될 것이다.</p>\n<p>작성한 코드</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TableCleaner</span> <span class=\"token punctuation\">{</span>  \n  \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> tableNames<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">JdbcTemplate</span> jdbcTemplate<span class=\"token punctuation\">;</span>  \n  \n    <span class=\"token annotation punctuation\">@Autowired</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TableCleaner</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DataSource</span> dataSource<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>jdbcTemplate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JdbcTemplate</span><span class=\"token punctuation\">(</span>dataSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n  \n    <span class=\"token annotation punctuation\">@Transactional</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">tableClear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token class-name\">String</span> query <span class=\"token operator\">=</span> <span class=\"token string\">\"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC'\"</span><span class=\"token punctuation\">;</span>  \n        tableNames <span class=\"token operator\">=</span> jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">queryForList</span><span class=\"token punctuation\">(</span>query<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  \n        jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SET REFERENTIAL_INTEGRITY FALSE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> tableName <span class=\"token operator\">:</span> tableNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TRUNCATE TABLE \"</span> <span class=\"token operator\">+</span> tableName <span class=\"token operator\">+</span> <span class=\"token string\">\" RESTART IDENTITY \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n        jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SET REFERENTIAL_INTEGRITY TRUE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 작성한 클래스를 컴포넌트로 등록해줘서 테스트 실행시 컴포넌트 스캔에 잡히게 해주면 해당 클래스를 빈으로 사용할 수 있고, </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>  \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestSupporter</span> <span class=\"token punctuation\">{</span>  \n  \n    <span class=\"token annotation punctuation\">@Autowired</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">TableCleaner</span> tableCleaner<span class=\"token punctuation\">;</span>  \n  \n    <span class=\"token annotation punctuation\">@AfterEach</span>  \n    <span class=\"token keyword\">void</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        tableCleaner<span class=\"token punctuation\">.</span><span class=\"token function\">tableClear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>해당 클래스로 주입받은 뒤 데이터베이스 초기화가 필요한 테스트에 상속받아 사용하면 테스트 생명주기에 맞춰 @AfterEach가 실행되며 자동으로 데이터베이스가 초기화되어, 테스트 격리가 될 것이다.</p>\n<p><em>틀린 부분이나 부족한 부분에 대한 피드백은 언제나 환영합니다</em></p>\n<hr>\n<p>참고</p>\n<p><a href=\"https://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/\">https://tecoble.techcourse.co.kr/post/2020-09-15-test-isolation/</a></p>","frontmatter":{"title":"@SpringBootTest와 테스트격리","date":"March 04, 2024","update":"March 10, 2024","tags":["spring","testing","testisolation"],"series":"hiyen"},"fields":{"slug":"/sprintboottest_isolation/","readingTime":{"minutes":7.705}}},"seriesList":{"edges":[{"node":{"id":"7e50230d-e72f-5a04-acf7-7fe60fd8536e","fields":{"slug":"/sprintboottest_isolation/"},"frontmatter":{"title":"@SpringBootTest와 테스트격리"}}},{"node":{"id":"e4729e9e-f445-5bf8-9d94-22806aeed103","fields":{"slug":"/pagination_fetchjoin/"},"frontmatter":{"title":"Spring Data JPA의 페이징처리와 fetch join시의 문제점"}}},{"node":{"id":"78a00267-c3db-5594-a5f3-621906fc030d","fields":{"slug":"/ticket_reservation_concurrency/"},"frontmatter":{"title":"'이미 선택된 좌석입니다' 티켓 예매시 중복예매생성 문제"}}},{"node":{"id":"ff98243f-757c-5a9c-a838-c8efb698054e","fields":{"slug":"/domain_refactoring/"},"frontmatter":{"title":"리팩토링을 통해 유연한 도메인을 만들자!"}}},{"node":{"id":"8ff84894-52cd-5648-be4d-4ae81514bfbb","fields":{"slug":"/api_performance_improvment/"},"frontmatter":{"title":"조회 API 성능 개선"}}},{"node":{"id":"ca9fbb61-c38d-5470-9356-76fec2e7afd2","fields":{"slug":"/technology_free_code/"},"frontmatter":{"title":"기술변경에 확장성을 가진 리팩토링"}}},{"node":{"id":"e1cceb09-6833-5331-9222-47f6dfc45dc4","fields":{"slug":"/thread_test_transation/"},"frontmatter":{"title":"스레드테스트와 트랜잭션 전파"}}},{"node":{"id":"68b7f04a-a5cc-509a-a7a5-6fe7a2883037","fields":{"slug":"/java_bytecode/"},"frontmatter":{"title":"바이트코드와 함께 알아 보는 자바 실행과정"}}},{"node":{"id":"91584fd5-bec1-56d5-b867-97896aca40b6","fields":{"slug":"/distributed_information/"},"frontmatter":{"title":"분산시스템에서 데이터를 전달하는 방법"}}},{"node":{"id":"a7cd67d4-5503-5ae9-8281-75d74bd84bbe","fields":{"slug":"/galmanhae_first/"},"frontmatter":{"title":"외부 API 호출과 데이터 처리"}}},{"node":{"id":"e5dea1c1-c406-50f3-a2e0-a3fdfd73a11a","fields":{"slug":"/bottleneck_chasing/"},"frontmatter":{"title":"서버 병목현상 추적기"}}}]},"previous":{"fields":{"slug":"/githubaction_automated_test/"},"frontmatter":{"title":"Github Actions 를 통한 테스트 자동화 구축"}},"next":{"fields":{"slug":"/querydsl_nplusone/"},"frontmatter":{"title":"Querydsl과 JPA에서의 N+1문제"}}},"pageContext":{"id":"7e50230d-e72f-5a04-acf7-7fe60fd8536e","series":"hiyen","previousPostId":"dd58a1e4-3b4a-53be-965c-56708ad62636","nextPostId":"2b7705f1-0a51-5e3c-9789-fb167354e34a"}},"staticQueryHashes":[],"slicesMap":{}}