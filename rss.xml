<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of Hiyen]]></title><description><![CDATA[Hello :) I'm Hiyen, a backend developer!]]></description><link>https://jinkshower.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 29 Dec 2023 03:14:04 GMT</lastBuildDate><item><title><![CDATA[프로세스와 스레드]]></title><description><![CDATA['혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.
이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB…]]></description><link>https://jinkshower.github.io/process_thread/</link><guid isPermaLink="false">https://jinkshower.github.io/process_thread/</guid><pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&apos;혼자 공부하는 시스템구조&amp;#x26;운영체제&apos;를 읽고 공부한 내용&lt;/p&gt;
&lt;h2&gt;프로세스&lt;/h2&gt;
&lt;h3&gt;Process? Program?&lt;/h3&gt;
&lt;p&gt;우리는 흔히 &lt;code class=&quot;language-text&quot;&gt;프로그램을 실행한다&lt;/code&gt; 라고 말한다.
이는 &apos;보조기억장치에 있는 데이터 뭉치&apos;인 &lt;code class=&quot;language-text&quot;&gt;프로그램&lt;/code&gt;을  &apos;메모리에 적재하고 cpu가 실행&apos;하여 &lt;code class=&quot;language-text&quot;&gt;프로세스&lt;/code&gt;화 한다와 같은 말이다. &lt;/p&gt;
&lt;h3&gt;PCB Process Control Block&lt;/h3&gt;
&lt;p&gt;모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.
그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 &lt;code class=&quot;language-text&quot;&gt;PCB&lt;/code&gt;라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[PCB에 저장되는 정보]&lt;br&gt;
PID(Process ID) : 프로세스 고유의 번호
Registers: 레지스터의 중간값&lt;br&gt;
Process state: 대기,준비, 실행 등의 프로세스 상태&lt;br&gt;
CPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보&lt;br&gt;
Memory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블&lt;br&gt;
List of Open files : 입출력장치 정보&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;이 PCB로 어떻게 관리하나?&lt;/h3&gt;
&lt;p&gt;CPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. &lt;/p&gt;
&lt;p&gt;이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. &lt;/p&gt;
&lt;p&gt;이 중간 정보는 &lt;code class=&quot;language-text&quot;&gt;문맥Context&lt;/code&gt;으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 &lt;code class=&quot;language-text&quot;&gt;문맥 교환 Context Switching&lt;/code&gt; 이라고 한다.
(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[동시에 실행되는 것 &apos;처럼&apos; 보인다]&lt;br&gt;
프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.&lt;br&gt;
정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;프로세스의 구성&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 할당 영역&lt;/code&gt;&lt;br&gt;
코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only&lt;/p&gt;
&lt;p&gt;데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터
ex) 전역변수, 상수&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;동적 할당 영역&lt;/code&gt;&lt;br&gt;
힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간
ex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) &lt;/p&gt;
&lt;p&gt;스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터
ex)매개변수, 지역변수 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;프로세스의 상태&lt;/h2&gt;
&lt;p&gt;프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다.
입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다.
그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생성 상태(new)&lt;/li&gt;
&lt;li&gt;준비 상태(ready)&lt;/li&gt;
&lt;li&gt;대기상태(blocked) &lt;/li&gt;
&lt;li&gt;실행상태(running)&lt;/li&gt;
&lt;li&gt;종료상태(terminated)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;준비상태 vs 대기상태&lt;/code&gt;&lt;br&gt;
준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다.
준비상태에서 실행상태가 되는 것을 &lt;strong&gt;dispatch&lt;/strong&gt;라고 한다 &lt;/p&gt;
&lt;p&gt;대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 &lt;strong&gt;준비상태&lt;/strong&gt;가 된다. &lt;/p&gt;
&lt;h2&gt;스레드&lt;/h2&gt;
&lt;h3&gt;프로세스와 스레드&lt;/h3&gt;
&lt;p&gt;스레드는 &lt;code class=&quot;language-text&quot;&gt;프로세스를 구성하는 실행 단위&lt;/code&gt;를 의미한다
스레드는 &lt;strong&gt;프로세스의 자원&lt;/strong&gt;을 공유하며 여러개가 존재 할 수 있다.
스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. &lt;/p&gt;
&lt;h3&gt;멀티스레드&lt;/h3&gt;
&lt;p&gt;멀티스레드는 &lt;code class=&quot;language-text&quot;&gt;문맥 교환&lt;/code&gt;으로 동시성을 획득하는 멀티프로세스와 다르게&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;병렬성을 가지고 실제로 동시에 수행될 수 있다. &lt;/li&gt;
&lt;li&gt;한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;하지만 이러한 장점들은 단점이 될 수도 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;동시에 수행될 수 있다는 것은 동기화 문제를 내재한다&lt;/li&gt;
&lt;li&gt;자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이중 첫번째 단점을 조금 더 자세히 서술하겠다.&lt;/p&gt;
&lt;h3&gt;멀티 스레드의 동기화 문제&lt;/h3&gt;
&lt;p&gt;운영체제는 여러개의 프로세스의 실행을 관리한다고 말했는데, 이는 운영체제에 &lt;code class=&quot;language-text&quot;&gt;CPU 스케쥴링&lt;/code&gt; 알고리즘이 존재한다는 것을 의미한다.
그러나 멀티스레드는 A,B 스레드 중 어떤 스레드가 먼저 실행될지 결정 되어 있지 않다.
간단한 예제로 알아보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; max &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; maxCount&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
                count&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
                &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;얼핏 보면 문제가 없어보이지만 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;1
3
4
2
5
6&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;실행 결과는 이렇게 뒤죽박죽인채로 출력된다.
이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 문제를 &lt;code class=&quot;language-text&quot;&gt;Synchronization Issue&lt;/code&gt; 라고 한다. &lt;/p&gt;
&lt;p&gt;-&gt; 이를 해결하기 위한 다양한 방법이 있는데 자세한 내용은 다른 글에서 다룰 예정이다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby와 Github Pages로 개인 블로그 만들기]]></title><description><![CDATA[Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG…]]></description><link>https://jinkshower.github.io/gatsby_website/</link><guid isPermaLink="false">https://jinkshower.github.io/gatsby_website/</guid><pubDate>Tue, 26 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Gatsby로 Github pages 개인 블로그 만들기&lt;/h2&gt;
&lt;p&gt;TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 &lt;code class=&quot;language-text&quot;&gt;Jekyll&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt; 이다. &lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;Jekyll&lt;/code&gt;로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 &lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt;로 프레임워크를 바꾸게 되었다.&lt;/p&gt;
&lt;p&gt;나는 미리 만들어진 &lt;a href=&quot;https://github.com/devHudi/gatsby-starter-hoodie&quot;&gt;테마&lt;/a&gt; 를 사용했다.(감사합니다)&lt;/p&gt;
&lt;h2&gt;Gatsby 설치 와 웹사이트 설정&lt;/h2&gt;
&lt;p&gt;Gatsby cli를 설치해준다 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g gatsby-cli&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Gatsby Starter Library&lt;/code&gt;에서 마음에 드는 테마를 선택할 수 있다.
원하는 테마를 고른 뒤&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npx gatsby new {local-folder-name} {theme-name}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행해 로컬에 Gatsby 템플레이트를  만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd {local-folder-name}
gatsby develop&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 &lt;code class=&quot;language-text&quot;&gt;http://localhost:8000&lt;/code&gt;이다. &lt;/p&gt;
&lt;h2&gt;Github Repository연결&lt;/h2&gt;
&lt;p&gt;Github의 새 리포지토리를 생성한다.
나는 &lt;code class=&quot;language-text&quot;&gt;{username}.github.io&lt;/code&gt;로 이름을 지정했다.
다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면
&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;Gatsby 공식문서&lt;/a&gt; 를 참고하길 바란다&lt;/p&gt;
&lt;p&gt;리포지토리를 생성했다면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git remote add origin {github-https-address}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.&lt;/p&gt;
&lt;p&gt;그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git add .
git commit -m &quot;{commit-name}&quot;
git push origin main&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.&lt;/p&gt;
&lt;h2&gt;배포 방법 정하기&lt;/h2&gt;
&lt;p&gt;배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Netlify
Github과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.
&lt;a href=&quot;https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/&quot;&gt;A Step-by-Step Guide: Gatsby on Netlify&lt;/a&gt; 공식문서&lt;/li&gt;
&lt;li&gt;Github pages
Github pages에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;를 이용하여 배포할 수 있다
&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;How Gatsby Works with GitHub Pages&lt;/a&gt;공식 문서&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 &lt;code class=&quot;language-text&quot;&gt;{smt}.netflify.app&lt;/code&gt;를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 &lt;code class=&quot;language-text&quot;&gt;{smt}.github.io&lt;/code&gt; 도메인이 마음에 들어서다(...)&lt;/p&gt;
&lt;h2&gt;Github Pages로 배포하기&lt;/h2&gt;
&lt;p&gt;배포용 브랜치 설정
gh-pages는 배포용 브랜치가 따로 있어야 한다.&lt;br&gt;
우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 &lt;code class=&quot;language-text&quot;&gt;.gitignore&lt;/code&gt;에서 public을 푸쉬하지 않게 설정되어 있다.&lt;/p&gt;
&lt;p&gt;현 상태에서 배포용 브랜치를 하나 만들어 둔다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git branch deploy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다.
&lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;패키지를 설치하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install gh-pages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[Trouble Shooting]&lt;br&gt;
나는 npm install 과중에서 dependency conflict가 발생했다.&lt;br&gt;
node 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;-&gt; 위의 install 커맨드에 &lt;code class=&quot;language-text&quot;&gt;--force&lt;/code&gt; 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 &lt;code class=&quot;language-text&quot;&gt;--legacy-peer-deps&lt;/code&gt;로 자동설치를 막는 방법이 있다. 나는 &lt;code class=&quot;language-text&quot;&gt;--force&lt;/code&gt;로 설치했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다음은 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 에 배포에 사용할 스크립트를 추가해주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&quot;scripts&quot;: {
    &quot;deploy&quot;: &quot;gatsby build &amp;amp;&amp;amp; gh-pages -d public -b deploy&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm run deploy &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행한다.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[Trouble Shooting]&lt;br&gt;
위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 &lt;code class=&quot;language-text&quot;&gt;npm run clean&lt;/code&gt;으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이후
Github repository의 Settings-Pages
&lt;code class=&quot;language-text&quot;&gt;Build and deployment&lt;/code&gt;에서 배포용 브랜치로 전환해준다.&lt;/p&gt;
&lt;p&gt;이렇게 까지 하면 &lt;code class=&quot;language-text&quot;&gt;Actions&lt;/code&gt;에서 웹사이트를 배포해주고 브라우저에서&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;https://{user-name}.github.io/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 주소로 접속이 가능해진다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[정적 팩토리 메서드, 언제 쓸까?]]></title><description><![CDATA[정적 팩토리 메서드란? Java…]]></description><link>https://jinkshower.github.io/staticfactorymethod/</link><guid isPermaLink="false">https://jinkshower.github.io/staticfactorymethod/</guid><pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;정적 팩토리 메서드란?&lt;/h2&gt;
&lt;p&gt;Java에서는 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 &lt;code class=&quot;language-text&quot;&gt;static&lt;/code&gt; 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.&lt;/p&gt;
&lt;p&gt;간단한 예시로 사용방법을 알아 보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;   
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;Car&lt;/code&gt; 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 팩토리 메서드&lt;/code&gt; 를 추가함으로써 인스턴스를 반환 받는 다른 &lt;code class=&quot;language-text&quot;&gt;통로&lt;/code&gt; 를  생성하는 기법이라고 할 수 있다. &lt;/p&gt;
&lt;h2&gt;정적팩토리 메서드, 왜 쓰나?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Effective Java&lt;/code&gt;는 1장에서 &lt;code class=&quot;language-text&quot;&gt;생성자 대신 정적 팩토리 메서드를 고려하라&lt;/code&gt; 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 &lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/&quot;&gt;링크&lt;/a&gt;&lt;br&gt;
이 포스트에서는 내가  &lt;strong&gt;개인적으로&lt;/strong&gt; 언제 이 기법을 사용하는지 서술해 보려고 한다.&lt;/p&gt;
&lt;h3&gt;이름이 있는 것이 나은 경우&lt;/h3&gt;
&lt;p&gt;위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; car1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; car2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다.
&lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt; 연산자는 &lt;code class=&quot;language-text&quot;&gt;이 Car는 input을 멤버 변수로 가지는군&lt;/code&gt; 이라면
&lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;이 input은 객체 내에서 특정한 로직으로 변환되겠군&lt;/code&gt; 이라는 멘탈 모델을 제공한다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;이름을 가질 수 있다&lt;/code&gt; 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.&lt;/p&gt;
&lt;h3&gt;한 가지 방법으로만 객체가 생성되게 하고 싶을 때&lt;/h3&gt;
&lt;p&gt;우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isInvalidId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서 이 때는 &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; 으로 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.
이는 &lt;code class=&quot;language-text&quot;&gt;싱글톤패턴&lt;/code&gt; 의 사용과도 일맥상통한다&lt;/p&gt;
&lt;h3&gt;같은 객체가 여러번 쓰여야할 때&lt;/h3&gt;
&lt;p&gt;같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에&lt;em&gt;만&lt;/em&gt;  객체를 생성해 메모리를 아낄 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarFactory&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
	  &lt;span class=&quot;token comment&quot;&gt;//if cache doesn&apos;t contains key, only then instantiate new car&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[정리]&lt;br&gt;
1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우&lt;br&gt;
2.지정된 경우 이외의 객체 생성을 막고 싶은 경우&lt;br&gt;
3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.&lt;/p&gt;
&lt;h2&gt;private으로 생성자 막기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Effective Java&lt;/code&gt; 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 &lt;code class=&quot;language-text&quot;&gt;Composition&lt;/code&gt;을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;coins &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token comment&quot;&gt;//Complicated Logic..   &lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;//..  &lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다
text를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 &lt;code class=&quot;language-text&quot;&gt;재사용성&lt;/code&gt; 이 늘어날 수 있기 때문이다.&lt;/p&gt;</content:encoded></item></channel></rss>