<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of Hiyen]]></title><description><![CDATA[Hello :) I'm Hiyen, a backend developer!]]></description><link>https://jinkshower.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 09 Jan 2024 10:18:21 GMT</lastBuildDate><item><title><![CDATA[Builder Pattern으로 코드 개선하기]]></title><link>https://jinkshower.github.io/builder_pattern/</link><guid isPermaLink="false">https://jinkshower.github.io/builder_pattern/</guid><pubDate>Tue, 09 Jan 2024 00:00:00 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[웹 서비스 캐시]]></title><description><![CDATA['모든 개발자를 위한 HTTP'강의를 수강한 학습 기록 캐시란? 컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다
CPU에서 캐시메모리는 CPU…]]></description><link>https://jinkshower.github.io/http_cache/</link><guid isPermaLink="false">https://jinkshower.github.io/http_cache/</guid><pubDate>Wed, 03 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&apos;모든 개발자를 위한 HTTP&apos;강의를 수강한 학습 기록&lt;/p&gt;
&lt;h2&gt;캐시란?&lt;/h2&gt;
&lt;p&gt;컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다
CPU에서 캐시메모리는 CPU, 메모리 사이에 위치하여 자주 쓰이는 데이터를 임시로 저장하여 둘 사이의 거리에 따른 접근시간을 줄이는데 사용된다. &lt;/p&gt;
&lt;p&gt;캐시는 다양한 종류가 있지만 웹에서의 캐시도 CPU의 캐시 메모리와 비슷하게 &lt;code class=&quot;language-text&quot;&gt;자주 쓰이는 데이터를 가까운 곳에 저장하여 데이터 접근 시간을 줄인다&lt;/code&gt; 는 원리를 가진다.&lt;/p&gt;
&lt;h2&gt;웹 브라우저 캐시&lt;/h2&gt;
&lt;p&gt;클라이언트에서 서버에 요청하여 10mb의 코끼리 이미지를 다운로드 받는다고 생각해보자.    &lt;/p&gt;
&lt;p&gt;캐시가 없다면 첫번째 요청에서는 10mb의 데이터를 전송받아야하지만 같은 사이트에 몇번이고 방문한다면 여러번의 요청마다 10mb의 데이터를 매번 다운로드 받아야 한다. 이러면 웹페이지의 로딩 속도는 매우 느려지고 좋지 않은 사용자 경험을 선사한다.&lt;/p&gt;
&lt;p&gt;반면 웹 브라우저를 사용하는 사용자의 로컬 환경에 캐시데이터를 저장하고 사용자가 같은 요청(코끼리 그림을 브라우저에 그려주세요)을 할 때는 서버에서 다운로드를 다시 받지 않고 캐시데이터를 바로 사용한다면 웹 페이지의 로딩 속도는 비약적으로 상승할 것이다. &lt;/p&gt;
&lt;h3&gt;웹 브라우저 캐시 적용&lt;/h3&gt;
&lt;p&gt;웹 브라우저에서 서버로 코끼리 그림을 최초로 요청하면 서버는 이에 대해&lt;code class=&quot;language-text&quot;&gt;cache-control: max-age&lt;/code&gt; 헤더를 포함한 응답을 준다.&lt;/p&gt;
&lt;p&gt;간단한 응답예시&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 200 OK
Content-Type:image/jpeg
Cache-Control: max-age=60
Content-Length: 10295

//
{elephant image data}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이때 &lt;code class=&quot;language-text&quot;&gt;max-age&lt;/code&gt; 에 해당하는 숫자는 이 캐시가 유효한 초단위를 의미한다.&lt;/p&gt;
&lt;p&gt;즉 이 코끼리 그림은 로컬의 캐시 저장소에서 60초간 유효하며 이 시간안에 클라이언트가 코끼리 그림을 다시 요청하면 서버에서 다시 코끼리 그림 데이터를 다운받는 게 아니라 캐시 저장소에 있는 복사된 데이터를 브라우저에서 렌더링 하게 되는 것이다.&lt;/p&gt;
&lt;h3&gt;캐시 유효기간&lt;/h3&gt;
&lt;p&gt;당연히 캐시 유효기간이 지난 데이터의 경우 서버에 재요청을 하여 다시 다운로드 받아야 한다. 이 때 유효기간이 지난 캐시를 Stale하다라고 표현한다.    &lt;/p&gt;
&lt;p&gt;하지만 캐시 유효 기간이 지났지만 서버의 원본 데이터가 변경되지 않은 경우, 같은 데이터인데도 다시 다운로드 받아야 하면 이는 굉장히 비효율적이다. 이를 위해 캐시와 원본이 같은 데이터인지 검증하고, 같은 데이터라면 캐시를 사용하는 절차가 필요하다.&lt;/p&gt;
&lt;h2&gt;캐시 유효성검증(Validation)과 조건부 요청(Conditional Request)&lt;/h2&gt;
&lt;p&gt;캐시 데이터가 원본 데이터와 같은지 검증하기 위해 크게 두가지 방법을 사용한다&lt;/p&gt;
&lt;h3&gt;Last-Modified / If-Modified-Since&lt;/h3&gt;
&lt;p&gt;첫 번재 방법은 원본 데이터가 마지막으로 수정된 시간을 응답 메시지 헤더로 추가하는 방법이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 200 OK
Content-Type:image/jpeg
Cache-Control: max-age=60
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added
Content-Length: 10295

//
{elephant image data}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 캐시 저장소에 코끼리 그림과 이 원본 데이터가 마지막으로 수정된 시각까지 저장을 하게 된다. 이제 클라이언트는 요청을 할때 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GET /elephant.jpg
if-modified-since: Wed, 21 Oct 2015 07:28:00 GMT&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&apos;이 이후로 원본이 수정되었으면&apos; 이라는  조건부 요청을 보내고 서버에서는 이러한 조건부 요청에 따라&lt;br&gt;
조건이 만족하면(수정 되었으면) 200 OK로 다시 10mb의 코끼리 그림을 전송하고 조건을 불만족하면(수정 되지 않았다면 )&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 304 Not Modified
Content-Type:image/jpeg
Cache-Control: max-age=60
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added
Content-Length: 10295

//

//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10mb의 message body가 생략된 304 Not Modified의 응답 메시지를 보낸다. &lt;/p&gt;
&lt;p&gt;위 방법은 합리적으로 보이지만 단점도 가지고 있다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1초 미만 단위로 캐시 조정이 불가능하고&lt;/li&gt;
&lt;li&gt;A-&gt;B-&gt;A 처럼 원본데이터가 수정되었지만 수정 전과 같은 데이터 일때&lt;/li&gt;
&lt;li&gt;스페이스, 주석 변경처럼 크게 영향이 없는 경우
에도 모두 재다운로드가 발생하기 때문이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;ETag / If-None-Match&lt;/h3&gt;
&lt;p&gt;위의 단점을 보완하고 캐시 로직을 서버에서 관리하고 싶을 때 ETag(Entity Tag)를 이용하게 된다 .
ETag는 각각의 캐시될 원본 데이터에 해쉬코드를 달아준다고 생각하면 된다. 데이터가 변경되고 이 데이터가 클라이언트에서 다시 다운로드 받아야 된다고 판단될 때 ETag를 변경해주면 된다. &lt;/p&gt;
&lt;p&gt;서버는 최초 응답 메시지에 코끼리 데이터와 함께 ETag를 제공한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 200 OK
Content-Type:image/jpeg
Cache-Control: max-age=60
ETag: &quot;aaaaaaa&quot; //added
Content-Length: 10295

//
{elephant image data}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;캐시 저장소는 이제 코끼리 그림 데이터를 ETag와 함께 저장하고 &lt;/p&gt;
&lt;p&gt;재요청시 조건부 요청을 보내게 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GET /elephant.jpg
if-none-match: &quot;aaaaaaa&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 마찬가지로 조건을 불만족하면(수정 되지 않았다면 ) 서버는 304 상태코드와 메시지 바디가 없는 응답 메시지를 보내고 클라이언트는 캐시 저장소에 있는 코끼리 그림을 웹 브라우저에 렌더링한다.&lt;/p&gt;
&lt;h2&gt;캐시 지시어&lt;/h2&gt;
&lt;p&gt;캐시를 제어하는 방법은 위의 방법만 있는 게 아니다. 항상 최신이 되어야 하는 데이터나 개인정보 처럼 캐시를 해서는 안되는 데이터도 있기 때문이다.&lt;/p&gt;
&lt;p&gt;Cache-directive(캐시 지시어)로 해당 데이터의 캐시가 어떻게 적용될지 설정할 수 있다. &lt;/p&gt;
&lt;h3&gt;Cache-Control: no-cache&lt;/h3&gt;
&lt;p&gt;데이터를 캐시해도 되지만 항상 Origin서버에 검증하고 사용되어야 하는 데이터다. 즉, 항상 최신의 데이터를 가지게 하고 싶을 때 사용한다&lt;/p&gt;
&lt;h3&gt;Cache-Control: no-store&lt;/h3&gt;
&lt;p&gt;민감한 정보가 포함된 데이터이므로 캐시해서는 안된다.&lt;/p&gt;
&lt;h3&gt;Cache-Control: must-revalidate&lt;/h3&gt;
&lt;p&gt;캐시 만료 후 최초조회시 Origin서버에 검증해야한다
Origin 서버 접근 실패시 반드시 오류가 발생해야한다.&lt;/p&gt;
&lt;h3&gt;Cache-Control: public&lt;/h3&gt;
&lt;p&gt;응답이 public 캐시에 저장되어도 된다 (프록시 서버에 저장되어도 된다)&lt;/p&gt;
&lt;h3&gt;Cache-Control: private&lt;/h3&gt;
&lt;p&gt;응답이 해당 사용자 만을 위한 것 private 캐시에 저장해야함(기본값)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로세스와 스레드]]></title><description><![CDATA['혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.
이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB…]]></description><link>https://jinkshower.github.io/process_thread/</link><guid isPermaLink="false">https://jinkshower.github.io/process_thread/</guid><pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&apos;혼자 공부하는 시스템구조&amp;#x26;운영체제&apos;를 읽고 공부한 내용&lt;/p&gt;
&lt;h2&gt;프로세스&lt;/h2&gt;
&lt;h3&gt;Process? Program?&lt;/h3&gt;
&lt;p&gt;우리는 흔히 &lt;code class=&quot;language-text&quot;&gt;프로그램을 실행한다&lt;/code&gt; 라고 말한다.
이는 &apos;보조기억장치에 있는 데이터 뭉치&apos;인 &lt;code class=&quot;language-text&quot;&gt;프로그램&lt;/code&gt;을  &apos;메모리에 적재하고 cpu가 실행&apos;하여 &lt;code class=&quot;language-text&quot;&gt;프로세스&lt;/code&gt;화 한다와 같은 말이다. &lt;/p&gt;
&lt;h3&gt;PCB Process Control Block&lt;/h3&gt;
&lt;p&gt;모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.
그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 &lt;code class=&quot;language-text&quot;&gt;PCB&lt;/code&gt;라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[PCB에 저장되는 정보]&lt;br&gt;
PID(Process ID) : 프로세스 고유의 번호
Registers: 레지스터의 중간값&lt;br&gt;
Process state: 대기,준비, 실행 등의 프로세스 상태&lt;br&gt;
CPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보&lt;br&gt;
Memory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블&lt;br&gt;
List of Open files : 입출력장치 정보&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;이 PCB로 어떻게 관리하나?&lt;/h3&gt;
&lt;p&gt;CPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. &lt;/p&gt;
&lt;p&gt;이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. &lt;/p&gt;
&lt;p&gt;이 중간 정보는 &lt;code class=&quot;language-text&quot;&gt;문맥Context&lt;/code&gt;으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 &lt;code class=&quot;language-text&quot;&gt;문맥 교환 Context Switching&lt;/code&gt; 이라고 한다.
(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[동시에 실행되는 것 &apos;처럼&apos; 보인다]&lt;br&gt;
프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.&lt;br&gt;
정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;프로세스의 구성&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 할당 영역&lt;/code&gt;&lt;br&gt;
코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only&lt;/p&gt;
&lt;p&gt;데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터
ex) 전역변수, 상수&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;동적 할당 영역&lt;/code&gt;&lt;br&gt;
힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간
ex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) &lt;/p&gt;
&lt;p&gt;스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터
ex)매개변수, 지역변수 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;프로세스의 상태&lt;/h2&gt;
&lt;p&gt;프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다.
입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다.
그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생성 상태(new)&lt;/li&gt;
&lt;li&gt;준비 상태(ready)&lt;/li&gt;
&lt;li&gt;대기상태(blocked) &lt;/li&gt;
&lt;li&gt;실행상태(running)&lt;/li&gt;
&lt;li&gt;종료상태(terminated)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;준비상태 vs 대기상태&lt;/code&gt;&lt;br&gt;
준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다.
준비상태에서 실행상태가 되는 것을 &lt;strong&gt;dispatch&lt;/strong&gt;라고 한다 &lt;/p&gt;
&lt;p&gt;대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 &lt;strong&gt;준비상태&lt;/strong&gt;가 된다. &lt;/p&gt;
&lt;h2&gt;스레드&lt;/h2&gt;
&lt;h3&gt;프로세스와 스레드&lt;/h3&gt;
&lt;p&gt;스레드는 &lt;code class=&quot;language-text&quot;&gt;프로세스를 구성하는 실행 단위&lt;/code&gt;를 의미한다
스레드는 &lt;strong&gt;프로세스의 자원&lt;/strong&gt;을 공유하며 여러개가 존재 할 수 있다.
스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. &lt;/p&gt;
&lt;h3&gt;멀티스레드&lt;/h3&gt;
&lt;p&gt;멀티프로세스와 비슷하게 스레드 또한 문맥교환을 하며 동시성을 가지고 처리된다. &lt;/p&gt;
&lt;p&gt;멀티스레드는 한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다&lt;/p&gt;
&lt;h3&gt;프로세스와 스레드의 동기화 문제&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; max &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; maxCount&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
                count&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
                &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 얼핏 보면 문제가 없어보이지만 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;1
3
4
2
5
6&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;실행결과는 뒤죽박죽인채로 나온다.&lt;br&gt;
이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 때 이 멀티 스레드는 &apos;&lt;code class=&quot;language-text&quot;&gt;Synchronization Issue&lt;/code&gt;를 가진다&apos;라고 한다.&lt;/p&gt;
&lt;h3&gt;프로세스 동기화 문제? 스레드 동기화 문제?&lt;/h3&gt;
&lt;p&gt;둘 다 동기화 문제를 가질 수 있다.&lt;br&gt;
위 예시에서는 스레드의 동기화를 사용했지만 &lt;code class=&quot;language-text&quot;&gt;실행의 흐름&lt;/code&gt;을 가지는 모든 것들이 동기화 문제를 내재하고 있다.   &lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code class=&quot;language-text&quot;&gt;Book.txt&lt;/code&gt;를 쓰는 프로세스 A와 같은 파일을 읽는 프로세스 B가 있다면 두 프로세스가 공유자원에 접근할 수 있다는 것이고 &lt;code class=&quot;language-text&quot;&gt;A-&gt;B&lt;/code&gt;의 정해진 순서대로 실행되어야 하기 때문이다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby와 Github Pages로 개인 블로그 만들기]]></title><description><![CDATA[Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG…]]></description><link>https://jinkshower.github.io/gatsby_website/</link><guid isPermaLink="false">https://jinkshower.github.io/gatsby_website/</guid><pubDate>Tue, 26 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Gatsby로 Github pages 개인 블로그 만들기&lt;/h2&gt;
&lt;p&gt;TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 &lt;code class=&quot;language-text&quot;&gt;Jekyll&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt; 이다. &lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;Jekyll&lt;/code&gt;로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 &lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt;로 프레임워크를 바꾸게 되었다.&lt;/p&gt;
&lt;p&gt;나는 미리 만들어진 &lt;a href=&quot;https://github.com/devHudi/gatsby-starter-hoodie&quot;&gt;테마&lt;/a&gt; 를 사용했다.(감사합니다)&lt;/p&gt;
&lt;h2&gt;Gatsby 설치 와 웹사이트 설정&lt;/h2&gt;
&lt;p&gt;Gatsby cli를 설치해준다 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g gatsby-cli&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Gatsby Starter Library&lt;/code&gt;에서 마음에 드는 테마를 선택할 수 있다.
원하는 테마를 고른 뒤&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npx gatsby new {local-folder-name} {theme-name}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행해 로컬에 Gatsby 템플레이트를  만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd {local-folder-name}
gatsby develop&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 &lt;code class=&quot;language-text&quot;&gt;http://localhost:8000&lt;/code&gt;이다. &lt;/p&gt;
&lt;h2&gt;Github Repository연결&lt;/h2&gt;
&lt;p&gt;Github의 새 리포지토리를 생성한다.
나는 &lt;code class=&quot;language-text&quot;&gt;{username}.github.io&lt;/code&gt;로 이름을 지정했다.
다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면
&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;Gatsby 공식문서&lt;/a&gt; 를 참고하길 바란다&lt;/p&gt;
&lt;p&gt;리포지토리를 생성했다면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git remote add origin {github-https-address}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.&lt;/p&gt;
&lt;p&gt;그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git add .
git commit -m &quot;{commit-name}&quot;
git push origin main&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.&lt;/p&gt;
&lt;h2&gt;배포 방법 정하기&lt;/h2&gt;
&lt;p&gt;배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Netlify
Github과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.
&lt;a href=&quot;https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/&quot;&gt;A Step-by-Step Guide: Gatsby on Netlify&lt;/a&gt; 공식문서&lt;/li&gt;
&lt;li&gt;Github pages
Github pages에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;를 이용하여 배포할 수 있다
&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;How Gatsby Works with GitHub Pages&lt;/a&gt;공식 문서&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 &lt;code class=&quot;language-text&quot;&gt;{smt}.netflify.app&lt;/code&gt;를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 &lt;code class=&quot;language-text&quot;&gt;{smt}.github.io&lt;/code&gt; 도메인이 마음에 들어서다(...)&lt;/p&gt;
&lt;h2&gt;Github Pages로 배포하기&lt;/h2&gt;
&lt;p&gt;배포용 브랜치 설정
gh-pages는 배포용 브랜치가 따로 있어야 한다.&lt;br&gt;
우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 &lt;code class=&quot;language-text&quot;&gt;.gitignore&lt;/code&gt;에서 public을 푸쉬하지 않게 설정되어 있다.&lt;/p&gt;
&lt;p&gt;현 상태에서 배포용 브랜치를 하나 만들어 둔다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git branch deploy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다.
&lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;패키지를 설치하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install gh-pages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[Trouble Shooting]&lt;br&gt;
나는 npm install 과중에서 dependency conflict가 발생했다.&lt;br&gt;
node 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;-&gt; 위의 install 커맨드에 &lt;code class=&quot;language-text&quot;&gt;--force&lt;/code&gt; 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 &lt;code class=&quot;language-text&quot;&gt;--legacy-peer-deps&lt;/code&gt;로 자동설치를 막는 방법이 있다. 나는 &lt;code class=&quot;language-text&quot;&gt;--force&lt;/code&gt;로 설치했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다음은 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 에 배포에 사용할 스크립트를 추가해주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&quot;scripts&quot;: {
    &quot;deploy&quot;: &quot;gatsby build &amp;amp;&amp;amp; gh-pages -d public -b deploy&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm run deploy &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행한다.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[Trouble Shooting]&lt;br&gt;
위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 &lt;code class=&quot;language-text&quot;&gt;npm run clean&lt;/code&gt;으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이후
Github repository의 Settings-Pages
&lt;code class=&quot;language-text&quot;&gt;Build and deployment&lt;/code&gt;에서 배포용 브랜치로 전환해준다.&lt;/p&gt;
&lt;p&gt;이렇게 까지 하면 &lt;code class=&quot;language-text&quot;&gt;Actions&lt;/code&gt;에서 웹사이트를 배포해주고 브라우저에서&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;https://{user-name}.github.io/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 주소로 접속이 가능해진다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[정적 팩토리 메서드, 언제 쓸까?]]></title><description><![CDATA[정적 팩토리 메서드란? Java…]]></description><link>https://jinkshower.github.io/staticfactorymethod/</link><guid isPermaLink="false">https://jinkshower.github.io/staticfactorymethod/</guid><pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;정적 팩토리 메서드란?&lt;/h2&gt;
&lt;p&gt;Java에서는 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 &lt;code class=&quot;language-text&quot;&gt;static&lt;/code&gt; 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.&lt;/p&gt;
&lt;p&gt;간단한 예시로 사용방법을 알아 보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;   
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;Car&lt;/code&gt; 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 팩토리 메서드&lt;/code&gt; 를 추가함으로써 인스턴스를 반환 받는 다른 &lt;code class=&quot;language-text&quot;&gt;통로&lt;/code&gt; 를  생성하는 기법이라고 할 수 있다. &lt;/p&gt;
&lt;h2&gt;정적팩토리 메서드, 왜 쓰나?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Effective Java&lt;/code&gt;는 1장에서 &lt;code class=&quot;language-text&quot;&gt;생성자 대신 정적 팩토리 메서드를 고려하라&lt;/code&gt; 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 &lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/&quot;&gt;링크&lt;/a&gt;&lt;br&gt;
이 포스트에서는 내가  &lt;strong&gt;개인적으로&lt;/strong&gt; 언제 이 기법을 사용하는지 서술해 보려고 한다.&lt;/p&gt;
&lt;h3&gt;이름이 있는 것이 나은 경우&lt;/h3&gt;
&lt;p&gt;위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; car1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; car2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다.
&lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt; 연산자는 &lt;code class=&quot;language-text&quot;&gt;이 Car는 input을 멤버 변수로 가지는군&lt;/code&gt; 이라면
&lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;이 input은 객체 내에서 특정한 로직으로 변환되겠군&lt;/code&gt; 이라는 멘탈 모델을 제공한다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;이름을 가질 수 있다&lt;/code&gt; 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.&lt;/p&gt;
&lt;h3&gt;한 가지 방법으로만 객체가 생성되게 하고 싶을 때&lt;/h3&gt;
&lt;p&gt;우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isInvalidId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서 이 때는 &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; 으로 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.
이는 &lt;code class=&quot;language-text&quot;&gt;싱글톤패턴&lt;/code&gt; 의 사용과도 일맥상통한다&lt;/p&gt;
&lt;h3&gt;같은 객체가 여러번 쓰여야할 때&lt;/h3&gt;
&lt;p&gt;같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에&lt;em&gt;만&lt;/em&gt;  객체를 생성해 메모리를 아낄 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarFactory&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
	  &lt;span class=&quot;token comment&quot;&gt;//if cache doesn&apos;t contains key, only then instantiate new car&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[정리]&lt;br&gt;
1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우&lt;br&gt;
2.지정된 경우 이외의 객체 생성을 막고 싶은 경우&lt;br&gt;
3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.&lt;/p&gt;
&lt;h2&gt;private으로 생성자 막기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Effective Java&lt;/code&gt; 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 &lt;code class=&quot;language-text&quot;&gt;Composition&lt;/code&gt;을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;coins &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token comment&quot;&gt;//Complicated Logic..   &lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;//..  &lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다
text를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 &lt;code class=&quot;language-text&quot;&gt;재사용성&lt;/code&gt; 이 늘어날 수 있기 때문이다.&lt;/p&gt;</content:encoded></item></channel></rss>