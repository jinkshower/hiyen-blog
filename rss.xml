<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of Hiyen]]></title><description><![CDATA[Always want to write sometimes]]></description><link>https://jinkshower.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 20 Jan 2024 11:40:14 GMT</lastBuildDate><item><title><![CDATA[IoC와 스프링 컨테이너]]></title><description><![CDATA[의존성 주입(DI)포스팅에서 이어지는 내용입니다. Inversion of Control…]]></description><link>https://jinkshower.github.io/ioc_container/</link><guid isPermaLink="false">https://jinkshower.github.io/ioc_container/</guid><pubDate>Sat, 20 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;의존성 주입(DI)&lt;a href=&quot;https://jinkshower.github.io/dependency_injection/%22&quot;&gt;포스팅&lt;/a&gt;에서 이어지는 내용입니다.&lt;/p&gt;
&lt;h2&gt;Inversion of Control (제어의 역전) 이란?&lt;/h2&gt;
&lt;p&gt;객체의 컨트롤이나 프로그램의 일정부분을 프레임워크의 컨테이너으로 옮기는 소프트웨어 설계의 원리를 뜻한다.
이 원리는 여러가지 디자인 패턴(전략 패턴, 서비스 로케이터 패턴, 팩토리 패턴)으로 실현될 수 있고 특히 의존성 주입(DI)로 가장 두드러지게 나타낼 수 있다.&lt;/p&gt;
&lt;h2&gt;자바로 보는 제어의 역전&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 House는 Tv클래스에 대한 제어권을 가지고 있다
즉,  House는 &lt;code class=&quot;language-text&quot;&gt;tv&lt;/code&gt;라는 참조변수에 어떤 Tv가 들어올지 스스로가 정하고 있다고 볼 수 있다. &lt;/p&gt;
&lt;p&gt;여기에 DI를 적용해보자 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;House가 가지고 있던 제어권이 외부로 넘어갔다.
즉, tv 객체를 생성하고 참조변수로 이어주는 역할을 더 이상 House가 하고 있지 않다.&lt;/p&gt;
&lt;p&gt;이렇게 House 객체는 객체를 생성하는 책임에서 벗어나게 되었고, 자신의 비즈니스 로직만 알아서 잘 실행하는 바람직한 객체가 되었다. &lt;/p&gt;
&lt;p&gt;하지만 이렇게 외부로 넘어간 제어권은 어디에 있을까?
Tv를 가지는 House를 만들기 위해서 우리의 코드 어디선가는 반드시
&lt;code class=&quot;language-text&quot;&gt;House house = new House(new Tv());&lt;/code&gt;
로 새로운 House를 만드는 호출을 해주어야만 한다. &lt;/p&gt;
&lt;p&gt;즉, 위 코드가 적힌 곳이 Main 이든, HouseFactory든 계속 제어권을 외부로 옮기는 것을 반복하다보면 어느 객체는 그 넘겨진 제어권을 실행해야 하는 것이다.&lt;/p&gt;
&lt;h2&gt;의존성을 주입하는 객체 만들기&lt;/h2&gt;
&lt;p&gt;그렇다면 의존성을 모두 한 곳에서 주입, 즉 제어권을 한 객체가 가지고 있다면 유지보수하기가 훨씬 쉬워지지 않을까? &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;house&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
&lt;span class=&quot;token comment&quot;&gt;//        return new Tv();  &lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartTv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//tv interface를 가정&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AppConfig라는 객체를 생성하고, 여기에 모든 의존성 주입하는 코드를 작성했다. &lt;/p&gt;
&lt;p&gt;의존성 주입의 모든 장점을 유지하면서 제어권을 한 객체가 가지게 했기 때문에 이제 우리는 새로운 tv를 가진 House를 만들고 싶을 때 이 한 파일에 있는 코드 한 줄만 수정하면 된다. &lt;/p&gt;
&lt;p&gt;이렇게 어떤 객체가 어떻게 생성될 지, 프로그램을 구성하는 역할을 비즈니스 로직을 실행하는 객체들로부터 분리시킴으로써 우리는 해당 프로그램을 유지보수하는데에 엄청난 이점을 갖게 되었다.  &lt;/p&gt;
&lt;p&gt;하지만 여전히 의문이 든다.
그럼 AppConfig는 어디서 생성하나?
AppConfig 안의 house()를 호출하는 객체가 여전히 제어권을 가지고 있는 것 아닐까? &lt;/p&gt;
&lt;h2&gt;스프링 컨테이너&lt;/h2&gt;
&lt;p&gt;풀리지 않는 이 연쇄를 프레임워크로 넘김으로써 해결할 수 있다.
IoC 컨테이너를 가지고 있는 프레임워크는 객체를 생성하고, 구성하고, 의존관계에 맞게 주입해주는 기능을 가지고 있다. &lt;/p&gt;
&lt;p&gt;Spring은 &lt;code class=&quot;language-text&quot;&gt;ApplicationContext&lt;/code&gt; interface로 IoC컨테이너 기능을 수행하고 있고, 구현체들은 다양한 설정 메타데이터(xml, java code, annotation)를 읽고, 이를 &lt;code class=&quot;language-text&quot;&gt;Bean&lt;/code&gt;이라는 객체로 만들어 준다. &lt;/p&gt;
&lt;h2&gt;스프링 컨테이너 사용하기&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;house&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
&lt;span class=&quot;token comment&quot;&gt;//        return new Tv();  &lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartTv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;xml&quot;&gt;&lt;pre class=&quot;language-xml&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;bean&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;tv&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;{class path}&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt; 
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;bean&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;house&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;{class path}&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; 
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;constructor-arg&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;tv&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;tv&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt; 
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;bean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Annotation을 사용하거나, xml 파일로 객체 구성정보를 메타데이터화 할 수 있다. &lt;/p&gt;
&lt;p&gt;Annotation이나 xml모두 각각의 장단점을 가지고 있는데
Annotation은 물론 편리하고 간단한것이 큰 장점이며 xml은  소스코드를 건드리지 않고, 컴파일을 하지도 않으면서도 메타데이터를 변경할 수 있다.&lt;/p&gt;
&lt;p&gt;위와 같이 메타데이터를 작성하면
스프링이 대신 객체를 각각 &lt;code class=&quot;language-text&quot;&gt;Bean&lt;/code&gt;으로 등록함은 물론 House에 Tv를 넣어서 생성하는 것과 같은 의존관계 설정도 자동으로 해주며 객체 라이프사이클관리도 해준다.&lt;/p&gt;
&lt;p&gt;즉, 우리는 아래와 같은 코드를 작성할 필요 없어지고 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;AppConfig&lt;/span&gt; appConfig &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; house &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; appConfig&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;house&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;객체 생성, 관리에 대한 제어권이 프로그래머에서 역전(Inverse) 되어 프레임워크가 맡게 된다.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;참고 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring&quot;&gt;https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/reference/core/beans/basics.html&quot;&gt;https://docs.spring.io/spring-framework/reference/core/beans/basics.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8&quot;&gt;https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫 팀 과제 회고]]></title><description><![CDATA[Preface 혼자 개발 공부를 하다 처음으로 팀으로 개발을 해보는 경험을 하게 되었다. 
자바로 캠프 관리 커맨드라인 프로그램을 만드는 Tiny, Tiny…]]></description><link>https://jinkshower.github.io/first_team_assignment/</link><guid isPermaLink="false">https://jinkshower.github.io/first_team_assignment/</guid><pubDate>Wed, 17 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Preface&lt;/h2&gt;
&lt;p&gt;혼자 개발 공부를 하다 처음으로 팀으로 개발을 해보는 경험을 하게 되었다.
자바로 캠프 관리 커맨드라인 프로그램을 만드는 Tiny, Tiny 프로젝트였지만 이 과정에서 개발을 같이 한다는 것이 무엇인지 많은 것을 깨닫게 되어서 글로 기록하고 싶어졌다. &lt;/p&gt;
&lt;h2&gt;의견 모으기&lt;/h2&gt;
&lt;p&gt;팀원들도 협업으로 개발을 해본 경험이 없었기 때문에 리더인 나의 역할이 막중하다는 것을 느끼게 되었다.
어떻게 설계를 할지, 어떻게 구현할 기능을 나눌지, 그리고 그 코드들을 어떻게 합칠지 모두 백지상태에서 정해야 했다.&lt;/p&gt;
&lt;p&gt;다행히도 우리 팀은 1주정도의 시간을 통해 모두 각자의 의견을 내고 그 의견에 대해 경청하고 고민하는 팀문화를 빌딩해왔었고 설계부터 제출까지 모든 과정을 같이 의견을 모으며 하나하나 해결해나갔다. &lt;/p&gt;
&lt;p&gt;아래는 각 과정에서 우리 팀이 어떤 문제를 마주쳤고, 어떻게 해결해 나갔는지의 기록이다&lt;/p&gt;
&lt;h2&gt;설계&lt;/h2&gt;
&lt;p&gt;팀 과제를 하기 전 개인과제를 통해 &lt;code class=&quot;language-text&quot;&gt;설계에 대한 고민&lt;/code&gt;이 충분히 필요하다는 것이 팀의 공통의견이었고 설계를 어떻게 해야 할지에 대해 두가지 의견으로 나뉘어졌다. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;다 같이 기능명세서를 작성하고 그를 바탕으로 설계도를 만들기  &lt;/li&gt;
&lt;li&gt;각자 4장의 기능명세서와 설계도를 작성한 후 합친다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;토의 끝에 2번으로 결정했고 그 이유는 다음과 같다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각자가 기능명세서를 작성함으로써 팀원 모두 해결해야할 문제점에 대해 깊이 생각할 시간을 가질 수 있다.&lt;/li&gt;
&lt;li&gt;4장의 설계도를 가지고 더 나은 설계를 고를 수 있다 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;문제점&lt;/h3&gt;
&lt;p&gt;이후, 각자 기능명세와 설계도를 합칠 때 문제점이 발생했다.&lt;/p&gt;
&lt;p&gt;누군가는 MarkDown으로 기능명세를 작성하고 클래스 다이어그램을 그려오고, 누군가는 머릿속에서 정리하고, 클래스 다이어그램에 모든 것을 그린 사람도 있는 등 각자가 제각기의 방식으로 기능명세와 설계도를 완성했기에 이를 합치는데 많이 시간과 비용이 소요되었다.&lt;/p&gt;
&lt;p&gt;정리하자면&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;기능명세, 설계도에 대한 공통의 마인드 모델이 없었고 &lt;/li&gt;
&lt;li&gt;각자를 만들어내는 툴이 일치하지 않았다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;해결&lt;/h3&gt;
&lt;p&gt;툴을 확정하고 기능명세와 설계도를 팀내에서 나름대로 정의를 내렸다.&lt;/p&gt;
&lt;p&gt;선택된 툴&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;기능명세&lt;/code&gt; : MarkDown&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;설계도&lt;/code&gt; : Draw.io&lt;/p&gt;
&lt;p&gt;정의&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;기능명세&lt;/code&gt; : 조사, 수식여구등을 생략하고 구현해야할 모든 기능을 최대한 구체화한 글&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;설계도&lt;/code&gt; : 클래스 명과 필드명으로 한 객체를 표현하고 연관관계만 선으로 표현한 다이어그램 &lt;/p&gt;
&lt;p&gt;으로 결정하여 해당 문제를 해결했다 &lt;/p&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;p&gt;기능명세와 설계도를 완성한 후, 이 둘을 바탕으로 클래스 다이어그램에서 정한 클래스명, 필드명을 다 같이 몹 프로그래밍으로 구현했다.&lt;/p&gt;
&lt;p&gt;이 후 구현할 기능을 각자의 희망대로 분배했고 다행히 희망사항이 겹치지 않아 각자 비슷한 분량의 기능을 구현하게 되었다. &lt;/p&gt;
&lt;p&gt;내가 맡은 기능은 &lt;code class=&quot;language-text&quot;&gt;수강생 점수 등록&lt;/code&gt; 이었다.&lt;/p&gt;
&lt;h3&gt;문제점&lt;/h3&gt;
&lt;p&gt;구현 과정에서 많은 문제점이 발생했다.&lt;/p&gt;
&lt;p&gt;개인적인 문제점은 내가 기능을 만들기 위해서는 미리 구현되어야할 &lt;code class=&quot;language-text&quot;&gt;수강생 등록&lt;/code&gt;을 다른 팀원이 구현 중이었기 때문에 팀원이 구현할 기능에 대해 짐작만 하고 코드를 작성할 수 밖에 없었다.
이는 결국 개인적으로 만족스럽지 못한 코드로 이어지게 되었다.&lt;/p&gt;
&lt;p&gt;팀적인 문제점은 몹 프로그래밍으로 작성한 초기 코드를 각자 로컬로 받으면서 발생했는데, &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDK 버전이 통일되지 않았고, &lt;code class=&quot;language-text&quot;&gt;.gitignore&lt;/code&gt;이 모두 달라 초기 환경설정에서 막히는 팀원들이 발생했다.&lt;/li&gt;
&lt;li&gt;git에 대한 이해도가 모두 달라서 프로젝트 진행이 불가한 팀원들이 발생했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;해결&lt;/h3&gt;
&lt;p&gt;모든 해결 과정을 화면공유로 팀원 모두가 참여한 상태에서 함께 해결했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDK버전을 17로 통일했다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;idea&lt;/code&gt; 폴더를 &lt;code class=&quot;language-text&quot;&gt;.gitignore&lt;/code&gt;에 포함시킨 후 브랜치를 다시 배포했다&lt;/li&gt;
&lt;li&gt;git 관련 아티클을 재공유했고 문제가 생긴 팀원의 화면을 같이 보며 git 명령어를 재숙지했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;합치기&lt;/h2&gt;
&lt;p&gt;위 과정을 해결한 후 각자 동일한 환경설정으로 맡은 기능을 구현할 수 있게 되었다.
이후 시간을 정해 기능을 각자 완성하고 함께 모여 코드를 합치기로 하였다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt;- &lt;code class=&quot;language-text&quot;&gt;dev&lt;/code&gt;-&lt;code class=&quot;language-text&quot;&gt;feature&lt;/code&gt; 로 브랜치를 나누었다&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt;은 제출용 브랜치로 완성된 코드만 가지도록 하였다&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;dev&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;feature&lt;/code&gt;를 Pull Request로 Merge하였다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Merge는 몹 프로그래밍으로 모두 합의를 통해 진행했다&lt;/p&gt;
&lt;h3&gt;문제점&lt;/h3&gt;
&lt;p&gt;합치기 과정에서 가장 큰 문제가 발생했다 &lt;/p&gt;
&lt;p&gt;내가 처음으로 pull request 를 Merge하고, conflict를 해결하는 과정을 화면으로 공유했고 차례대로 다른 팀원들의 Pull Request를 Merge하는 과정에서 발생한 문제점이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각자 기능을 4분할로 나누고 하나의 Pull Request를 합치니 하나의 PR 코드양이 너무 많았다&lt;/li&gt;
&lt;li&gt;깃 가이드라인을 팀내에서 문서화 하지 않아 합의했던 브랜치 전략을 놓친 팀원이 발생했다 &lt;/li&gt;
&lt;li&gt;코드 컨벤션을 팀내에서 문서화 하지 않아 서로의 코드를 이해하기 쉽지 않았다&lt;/li&gt;
&lt;li&gt;1번과 3번이 겹쳐져 수많은 Conflict가 발생했고 이를 수습하는 식으로 Merge가 진행됐다&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;해결&lt;/h3&gt;
&lt;p&gt;합치기에서의 &lt;code class=&quot;language-text&quot;&gt;문제점&lt;/code&gt;이 너무 치명적이라 팀내에서 긴급하게 다음 방향을 토의했다.
처음부터 다시하기 혹은 지금 디버깅하며 코드를 조금씩 고쳐나가기, 두 가지 의견이 나왔고
제출일이 당장 다음날이라 디버깅하며 코드를 조금씩 고쳐나가기로 결정했다 &lt;/p&gt;
&lt;p&gt;나와 팀원 한분이 번갈아 드라이버를 잡고 몹프로그래밍으로 디버깅을 했고 해당 과정이 많이 어려웠다.
몇 백줄이 되는 익숙치 않은 변수, 메서드명, 코드 구조를 따라가야 했고, 테스트 코드도 작성하지 않았기 때문에 일일히 출력하고 Main을 돌려가며 디버깅을 진행했다.&lt;/p&gt;
&lt;p&gt;다행히도 각자가 기능을 잘 완성해주어서 해결해야할 문제가 그리 크지는 않았다.
합치기를 마치고 이후 시간이 남을 정도였고, 추가 구현 기능은 &lt;code class=&quot;language-text&quot;&gt;합치기&lt;/code&gt; 과정에서 느낀 점을 토대로 페어프로그래밍으로 코드리뷰를 상세히 하여 Merge하였고
결과적으로 만족스러운 코드를 제출할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;완성 레포지토리
&lt;a href=&quot;https://github.com/jinkshower/CampManagement&quot;&gt;https://github.com/jinkshower/CampManagement&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;첫 협업이 나에게 남긴 것&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;합치기&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;해결&lt;/code&gt;하면서, 지금까지 왜 지켜야 하는지 와닿지 않았던
&lt;code class=&quot;language-text&quot;&gt;코드 컨벤션&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;커밋 컨벤션&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;깃 브랜치 전략&lt;/code&gt; 들을 문서화하고 팀원 모두가 지키는 것에 대한 필요성을 뼈저리게 느끼게 되었다. &lt;/p&gt;
&lt;p&gt;또한 왜 모든 개발교육과정에서 &lt;code class=&quot;language-text&quot;&gt;소통&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;공유&lt;/code&gt;를 강조하는지를 이해할 수 있었다.
우리 팀이 마지막에 그나마 만족스러운 결과를 낼 수 있었던 이유는 서로 의견을 가감없이 말하고 그에 대해 진중히 고민하고, 장단점을 살펴 대안을 고르는 &lt;code class=&quot;language-text&quot;&gt;팀 문화&lt;/code&gt;를 빌딩해왔기 때문이라고 생각한다&lt;/p&gt;
&lt;p&gt;개인적으로는 나의 &lt;code class=&quot;language-text&quot;&gt;커뮤니케이션 방식&lt;/code&gt;을 되돌아보는 계기가 되었다.
나는 건의사항이 있으면 언제나 말해야 하고, 내가 생각할 때 불합리하거나 비효율적인 일은 언제나 토의를 통해 개선할 수 있다고 생각한다. &lt;/p&gt;
&lt;p&gt;하지만 그러한 의견을 내면서 &lt;code class=&quot;language-text&quot;&gt;쿠션어&lt;/code&gt;를 사용하는 등 이른바 &lt;code class=&quot;language-text&quot;&gt;둥글게 말하기&lt;/code&gt;는 연습이 필요한 부분인 것 같다. &lt;/p&gt;
&lt;p&gt;마지막으로 딱딱하게 글을 적었지만 혹시나 이 글을 볼지도 모르는 나의 첫 개발팀원분들에게 감사를 전한다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Union Find]]></title><description><![CDATA[Algorithms 강의를 들으며 공부한 기록 Union Find 두 원소가 같은 집합내에 있는지 확인할때 사용하는 알고리즘이다.
Dynamic connectiviy의 자료구조 중 그래프에 edge가 추가되기만 하는 구조(Incremental…]]></description><link>https://jinkshower.github.io/union_find/</link><guid isPermaLink="false">https://jinkshower.github.io/union_find/</guid><pubDate>Sun, 14 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Algorithms 강의를 들으며 공부한 기록&lt;/p&gt;
&lt;h2&gt;Union Find&lt;/h2&gt;
&lt;p&gt;두 원소가 같은 집합내에 있는지 확인할때 사용하는 알고리즘이다.
Dynamic connectiviy의 자료구조 중 그래프에 edge가 추가되기만 하는 구조(Incremental connectivity) 에서 사용할 수 있다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;union(int p, int q)&lt;/code&gt; 로 p와 q를 같은 집합으로 만들고
&lt;code class=&quot;language-text&quot;&gt;find(int p)&lt;/code&gt;로 p의 루트를 찾거나 &lt;code class=&quot;language-text&quot;&gt;connected(int p, int q)&lt;/code&gt;로 두 요소가 연결되었는가를 확인하는 알고리즘이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UF&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Quick-find&lt;/h2&gt;
&lt;p&gt;가장 기본적인 방법으로 id array에 각 요소를 매핑하고 &lt;code class=&quot;language-text&quot;&gt;union(int p, int q)&lt;/code&gt;가 호출되면 모든 id array를 loop로 돌며 p의 id와 같은 id를 q의 id로 변경하는 방법이다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;QuickFindUF&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UF&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;QuickFindUF&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// id 배열 매핑&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; 
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// id 확인&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; pid &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; qid &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; pid&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
                id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; qid&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// p와 id가 같은 모든 id를 q의 id로 바꾼다 &lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;initialize : n&lt;/li&gt;
&lt;li&gt;union : n&lt;/li&gt;
&lt;li&gt;find : n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;n개의 요소에 n의 union은 n^2의 시간이 걸린다 &lt;/p&gt;
&lt;h2&gt;Quick-Union&lt;/h2&gt;
&lt;p&gt;id array를 쓰는 것은 비슷하지만 이번에는 i의 부모를 id array에 매핑한다. 즉 &lt;code class=&quot;language-text&quot;&gt;union(int p, int q)&lt;/code&gt;를 호출하면 p의 부모의 id를 q의 부모의 id로 바꾼다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;QuickUnionUF&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UF&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;QuickUnionUF&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;        
        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;// 부모 루트를 최상단까지 찾는다 &lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;        
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; j &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; j&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;//p의 루트를 q의 루트로 바꾼다&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;   
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;initialize : n&lt;/li&gt;
&lt;li&gt;union : n (root 찾는 비용 포함)&lt;/li&gt;
&lt;li&gt;find : n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quick-Find 보다 더 빠른 실행을 보이는 케이스도 있지만 알고리즘은 항상 최악의 경우를 상정해야 하므로 트리구조가 엄청나게 길거나 길이가 N이 될때 Quick-Find와 비슷하게 n^2의 실행시간을 가지게 된다&lt;/p&gt;
&lt;h2&gt;Quick Union 개선하기&lt;/h2&gt;
&lt;h3&gt;Weighting&lt;/h3&gt;
&lt;p&gt;현재 Quick Union은 트리의 크기와 상관없이 무조건 p를 q의 루트에 갖다
붙이기 때문에 트리의 길이가 엄청나게 길어지는 문제점을 가지고 있다. &lt;/p&gt;
&lt;p&gt;하지만 union을 실행할때 트리의 사이즈를 비교하고 작은 트리를 보다 큰 트리에 연결하면 트리의 깊이를 짧게 유지할 수 있다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;QuickUnionUF&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UF&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;QuickUnionUF&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            sizes&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// size도 같이 매핑한다&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;        
        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;        
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; j &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; j&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//루트가 같으면 early return&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;size&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; size&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	        id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; j&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	        size&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; size&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	        id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	        size&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; size&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;j&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//사이즈 비교 후 작은 트리를 큰 트리에 병합한다&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;   
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; p&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;initialize : n&lt;/li&gt;
&lt;li&gt;union : lg n(root 찾기 까지 포함)&lt;/li&gt;
&lt;li&gt;find : lg n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;왜 lg n의 비용으로 줄어들었을까?&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;T1의 크기가 3이고  T2의 크기가 5일때 T1에 있는 a를 T2에 있는 b에 연결시킨다고 가정해보자. &lt;/p&gt;
&lt;p&gt;이때 T1은 T2에 병합되고 a의 깊이는 1이 증가하게 된다. union을 호출할때 a의 깊이는 1이 증가하는데에 비해 a가 속한 트리의 크기는 3에서 8로 최소 2배이상이 증가하게 된다.&lt;/p&gt;
&lt;p&gt;이를 계속 실행하면 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a의 깊이&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;th&gt;lg N&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a가 속한 트리의 크기&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;이 되기 때문에 find의 비용이 절감하게 된다&lt;/p&gt;
&lt;h3&gt;Path-Compressing&lt;/h3&gt;
&lt;p&gt;위의 알고리즘을 Path-Compressing으로 더 개선할 수 있다   &lt;/p&gt;
&lt;p&gt;현재는 &lt;code class=&quot;language-text&quot;&gt;root()&lt;/code&gt;를 while문으로 모든 깊이의 노드를 반복하여 검색하고 있다.&lt;/p&gt;
&lt;p&gt;이 때 이 기능이 호출될때마다 각 호출된 노드의 id를 루트의 id로 바꿔주는 작업을 하면 트리의 깊이를 더 평탄하게 바꾸어 줄 수 있다.&lt;/p&gt;
&lt;p&gt;위의 코드의 root를 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;        
        &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
	        id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// i의 루트를 부모 루트로!&lt;/span&gt;
            i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 바꿔주기만 해도 트리의 깊이가 계속 평탄화 되면서 root를 호출하는 모든 기능의 비용이 절감된다. &lt;/p&gt;
&lt;p&gt;참고
&lt;a href=&quot;https://www.coursera.org/learn/algorithms-part1&quot;&gt;https://www.coursera.org/learn/algorithms-part1&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[의존성 주입(Dependency Injection)]]></title><description><![CDATA[의존성이란 객체 지향 언어에서 A 객체가 B객체를 이용할때 A는 B를  고 표현한다.  A가 생성될 때 B가 필요할 수도 있고, A의 메서드의 파라미터로 B가 있을 수도 있다.  House객체가 Tv객체를 이용하는 예시를 들어보자 더이상 House…]]></description><link>https://jinkshower.github.io/dependency_injection/</link><guid isPermaLink="false">https://jinkshower.github.io/dependency_injection/</guid><pubDate>Thu, 11 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;의존성이란&lt;/h2&gt;
&lt;p&gt;객체 지향 언어에서 A 객체가 B객체를 이용할때 A는 B를 &lt;code class=&quot;language-text&quot;&gt;의존한다&lt;/code&gt; 고 표현한다.  A가 생성될 때 B가 필요할 수도 있고, A의 메서드의 파라미터로 B가 있을 수도 있다. &lt;/p&gt;
&lt;p&gt;House객체가 Tv객체를 이용하는 예시를 들어보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// House는 Tv에 의존한다&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;더이상 House객체가 변하지 않으면 위 코드는 문제가 없다. &lt;/p&gt;
&lt;p&gt;하지만 House가 새로운 &lt;code class=&quot;language-text&quot;&gt;SmartTv&lt;/code&gt;를 가져야 한다면? House를 테스트할 때 다른 Tv 종류를 넣어보고 싶다면?&lt;/p&gt;
&lt;p&gt;Tv를 인터페이스화 해서 다른 Tv를 넣을 수는 있지만 임시방편일 뿐이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;//Tv tv = new Tv(); &lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartTv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//tv에 다른 구현체를 넣었지만..&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;turnOn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartTv&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;// some logic&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 객체가 다른 객체에 강한 의존성을 지니면 코드를 재사용하거나 확장하는데에 문제점이 생긴다.&lt;/p&gt;
&lt;h2&gt;의존성을 주입하자&lt;/h2&gt;
&lt;p&gt;House가 여러 Tv를 사용하는 것에 제약이 생긴 이유는 House가 어떠한 종류의 Tv를 자신의 상태로 가질지 미리 알고 있었기 때문이다 .&lt;/p&gt;
&lt;p&gt;Dependency Injection은 객체 간의 의존관계를 느슨하게 설정해놓고 Compile Time이 아닌 Runtime에 객체가 의존하고 있는 객체를 생성 후 넣어주는 방식을 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생성자를 이용하는 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//House는 어떤 Tv를 가질지 모른다&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//외부에서 이미 생성된 tv를 주입받는다&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; house &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//주입&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;setter를 이용하는 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//House는 어떤 Tv를 가질지 모른다&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setTv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tv &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//외부에서 이미 생성된 tv를 주입받는다&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; house &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
		house&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setTv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//주입&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;의존성 주입의 장점&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;A가 B의 변경을 알 필요가 없어진다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Tv를 생성할때 리모컨, 버튼, 안테나 등 다양한 요소가 필요하다고 해보자. 의존성이 강할 때 Tv가 변경되면 House도 같이 변경되어야 했다.
하지만 의존성을 주입하면 Tv가 어떻게 변경되어도 House객체 내의 코드는 수정할 필요가 없어진다. &lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;A를 테스트하기 쉬워진다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A와 B의 의존관계가 느슨해졌기 때문에 A와 B를 독립적으로 테스트 하는 것이 쉬워졌고
A에 interface화한 Tv의 여러 구현체를 주입시키는 테스트도 가능해진다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Test&lt;/span&gt;  
&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; house1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt; house2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SmartTv&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;A의 public API가 명시적이게 된다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;의존성을 주입하기 전 House의 API를 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;House의 코드를 열어보지 않는 한 House가 Tv를 가지고 있는지 알 길이 없다. &lt;/p&gt;
&lt;p&gt;의존성을 주입한다면 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;House&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Tv&lt;/span&gt; tv&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;가 될 것이고 House를 사용하고자 하는 다른 개발자들은 누구나 House가 Tv를 의존하는 객체임을 알 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Builder Pattern으로 코드 개선하기]]></title><description><![CDATA[개인 과제에서 을 적용해 코드를 개선한 기록 Builder Pattern? Effective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다.  Builder Pattern…]]></description><link>https://jinkshower.github.io/builder_pattern/</link><guid isPermaLink="false">https://jinkshower.github.io/builder_pattern/</guid><pubDate>Tue, 09 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;개인 과제에서 &lt;code class=&quot;language-text&quot;&gt;Builder Pattern&lt;/code&gt;을 적용해 코드를 개선한 기록&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Builder Pattern?&lt;/h2&gt;
&lt;p&gt;Effective Java는 많은 생성자 파라미터를 다루어야 할 경우 Builder Pattern을 고려하라고 말한다. &lt;/p&gt;
&lt;p&gt;Builder Pattern은 원하는 객체를 바로 생성하는 것이 아니라, 클래스 내에 Builder라는 내부 클래스를 만든 후 Builder 클래스를 이용해 객체를 생성하는 기법이다. &lt;/p&gt;
&lt;h2&gt;Menu&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public class Menu {    
    private final String name;  
    private final String description;  
    private final double price;  
    private final List&amp;lt;Option&gt; options;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;와 같은 네 개의 멤버 변수를 가진 Menu 클래스를 만드려 한다.
&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;price&lt;/code&gt;는 필수적으로 포함되어야 하지만 &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;options&lt;/code&gt;는 메뉴에 따라 있을 수도, 없을 수도 있는 선택 매개변수이다.&lt;/p&gt;
&lt;h2&gt;첫 번째 시도, public 생성자&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public Menu(String name, String description, double price, List&amp;lt;Option&gt; options) {
	this.name = name;
	this.description = description;
	this.price = price;
	this.options = options
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;가장 기본적인 public 생성자이다.
얼핏 보면 아무 문제도 없어보이지만 &lt;code class=&quot;language-text&quot;&gt;Menu&lt;/code&gt;를 인스턴스화하며 코드에서 사용하려 해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Menu(&quot;Shack Burger&quot;, &quot;너무 맛있는 쉑버거&quot;, 6.5, List.of(new   Option(&quot;Regular&quot;, 0),  
        new Option(&quot;Large&quot;, 0.9))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드는&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;같은 String타입의 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;descripton&lt;/code&gt;이 정확한 순서로 쓰여져야 하고&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;options&lt;/code&gt;가 필요없는 경우를 대처할 수 없기 때문에&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Menu를 인스턴스화 할때마다 Menu의 생성자를 매번 확인해야 한다.  &lt;/p&gt;
&lt;h2&gt;두번째 시도 Telescoping Constructor (점층적 생성자)&lt;/h2&gt;
&lt;p&gt;위의 코드를 조금 개선해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public Menu(String name, String description, double price, List&amp;lt;Option&gt; options) {  
    this.name = name;  
    this.description = description;  
    this.price = price;  
    this.options = new ArrayList&amp;lt;&gt;(options);  
}  
  
public Menu(String name, double price) {  
    this(name, &quot;&quot;, price, new ArrayList&amp;lt;&gt;());  
}  
  
public Menu(String name, String description, double price) {  
    this(name, description, price, new ArrayList&amp;lt;&gt;());  
}

public Menu(String name, double price, List&amp;lt;Options&gt; options) {
	this(name, &quot;&quot;, price, options);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;점층적 생성자를 이용해 &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;options&lt;/code&gt;모두 없는 경우, 하나만 없는 경우의 조합을 상정하고 순서대로 &lt;code class=&quot;language-text&quot;&gt;this()&lt;/code&gt;를 호출하며 생성시 주어지지 않은 파라미터는 default 값을 이용하도록 해보았다.&lt;/p&gt;
&lt;p&gt;점층적 생성자를 이용해 이제 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Menu(&quot;Burger&quot;, 1000)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 Menu의 생성도 가능해지게 되었다.&lt;/p&gt;
&lt;p&gt;하지만 점층적 생성자 또한&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;순서를 기억하기 어렵고, &lt;/li&gt;
&lt;li&gt;Menu가 더 많은 파라미터를 요구하게 될 시의 조합을 가진 생성자를 더 생성해야 하기 때문에&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;유지보수가 어렵다는 문제가 여전히 남아 있다. &lt;/p&gt;
&lt;h2&gt;세번째 시도, Builder Pattern&lt;/h2&gt;
&lt;p&gt;이러한 Menu 클래스를 Builder Pattern을 이용하여 리팩토링 해보았다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;public static class Builder {  
  
    private final String name;  
    private final double price;  
  
    private String description = &quot;&quot;;  
    private List&amp;lt;Option&gt; options = new ArrayList&amp;lt;&gt;();  
  
    public Builder(String name, double price) {  
        this.name = name;  
        this.price = price;  
    }  
  
    public Builder description(String description) {  
        this.description = description;  
        return this;    }  
  
    public Builder options(List&amp;lt;Option&gt; options) {  
        this.options = new ArrayList&amp;lt;&gt;(options);  
        return this;    }  
  
    public Menu build() {  
        return new Menu(this);  
    }  
}

private Menu(Builder builder) {  
    this.name = builder.name;  
    this.description = builder.description;  
    this.price = builder.price;  
    this.options = builder.options;  
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Menu 클래스 생성자의 접근제어자를 &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt;으로 두고 내부 클래스로 Builder를 만들었다.  &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt;생성자는 &lt;code class=&quot;language-text&quot;&gt;Builder&lt;/code&gt;가 가져다준 매개변수를 저장한다. &lt;/p&gt;
&lt;p&gt;Builder는 기본적으로 필수적인 매개변수인 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;price&lt;/code&gt;를 생성자의 파라미터로 받고 선택적인 매개변수인 &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;options&lt;/code&gt;를 초기화를 해주었다.&lt;/p&gt;
&lt;p&gt;필수 매개변수만 받고 나머지는 메서드 체이닝을 통해 setter와 같은 역할을 하며 마지막으로 &lt;code class=&quot;language-text&quot;&gt;build()&lt;/code&gt;메서드로만 Menu를 인스턴스화 할 수 있게 했다. &lt;/p&gt;
&lt;p&gt;이를 통해 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Menu.Builder(&quot;Shack Burger&quot;, 6.5)  
        .description(&quot;너무 맛있는 쉑버거&quot;)  
        .options(List.of(new Option(&quot;Single&quot;, 0),  
                new Option(&quot;Double&quot;, 3.6)))  
        .build()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Menu를 위와 같이 인스턴스화 할 수 있게 되었다. &lt;/p&gt;
&lt;p&gt;그리하여&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;생성자에 대한 컨트롤&lt;br&gt;
정해진 방식으로만 객체가 생성될 수 있게 했고 &lt;/li&gt;
&lt;li&gt;가독성&lt;br&gt;
생성자 파라미터에 메서드 명을 붙임으로써 객체 생성시의 실수가 줄어든다.
같은 타입의 멤버 변수를 파라미터로 받아 들일 시 순서가 헷갈리거나 잘못된 값을 저장할 수 있는 문제도 메서드 명을 지정해야 하므로 방지 할 수 있다.  &lt;/li&gt;
&lt;li&gt;확장성&lt;br&gt;
메서드를 추가하면 되기 때문에 4개 그 이상의 파라미터 확장 혹은 파라미터에 대한 검증 추가에 더 유연하게 대처할 수 있다 &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;내가 느낀 Builder Pattern의 단점&lt;/h2&gt;
&lt;p&gt;빌더 패턴을 사용하며 느낀 단점은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;바로바로 생성할 수 있는 public 생성자와 달리 코드를 작성하는데 비용이 든다.&lt;/li&gt;
&lt;li&gt;매개변수가 적은 경우 오히려 객체가 무거워진다 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;정도다. 하지만 테스트 코드 작성같이 다른 객체에서 Menu를 인스턴스화 할때 객체 생성에 실수가 줄어들고 이미 생성하고 있는 Menu 코드에 새로운 option을 추가한다거나 설명을 바꿀 때 편리함을 느껴서 매개변수가 많을 때는 Builder Pattern을 많이 사용할 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[웹 서비스 캐시]]></title><description><![CDATA['모든 개발자를 위한 HTTP'강의를 수강한 학습 기록 캐시란? 컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다
CPU에서 캐시메모리는 CPU…]]></description><link>https://jinkshower.github.io/http_cache/</link><guid isPermaLink="false">https://jinkshower.github.io/http_cache/</guid><pubDate>Wed, 03 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&apos;모든 개발자를 위한 HTTP&apos;강의를 수강한 학습 기록&lt;/p&gt;
&lt;h2&gt;캐시란?&lt;/h2&gt;
&lt;p&gt;컴퓨터과학분야에서 데이터나 값을 미리 복사해 놓는 임시장소를 의미한다
CPU에서 캐시메모리는 CPU, 메모리 사이에 위치하여 자주 쓰이는 데이터를 임시로 저장하여 둘 사이의 거리에 따른 접근시간을 줄이는데 사용된다. &lt;/p&gt;
&lt;p&gt;캐시는 다양한 종류가 있지만 웹에서의 캐시도 CPU의 캐시 메모리와 비슷하게 &lt;code class=&quot;language-text&quot;&gt;자주 쓰이는 데이터를 가까운 곳에 저장하여 데이터 접근 시간을 줄인다&lt;/code&gt; 는 원리를 가진다.&lt;/p&gt;
&lt;h2&gt;웹 브라우저 캐시&lt;/h2&gt;
&lt;p&gt;클라이언트에서 서버에 요청하여 10mb의 코끼리 이미지를 다운로드 받는다고 생각해보자.    &lt;/p&gt;
&lt;p&gt;캐시가 없다면 첫번째 요청에서는 10mb의 데이터를 전송받아야하지만 같은 사이트에 몇번이고 방문한다면 여러번의 요청마다 10mb의 데이터를 매번 다운로드 받아야 한다. 이러면 웹페이지의 로딩 속도는 매우 느려지고 좋지 않은 사용자 경험을 선사한다.&lt;/p&gt;
&lt;p&gt;반면 웹 브라우저를 사용하는 사용자의 로컬 환경에 캐시데이터를 저장하고 사용자가 같은 요청(코끼리 그림을 브라우저에 그려주세요)을 할 때는 서버에서 다운로드를 다시 받지 않고 캐시데이터를 바로 사용한다면 웹 페이지의 로딩 속도는 비약적으로 상승할 것이다. &lt;/p&gt;
&lt;h3&gt;웹 브라우저 캐시 적용&lt;/h3&gt;
&lt;p&gt;웹 브라우저에서 서버로 코끼리 그림을 최초로 요청하면 서버는 이에 대해&lt;code class=&quot;language-text&quot;&gt;cache-control: max-age&lt;/code&gt; 헤더를 포함한 응답을 준다.&lt;/p&gt;
&lt;p&gt;간단한 응답예시&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 200 OK
Content-Type:image/jpeg
Cache-Control: max-age=60
Content-Length: 10295

//
{elephant image data}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이때 &lt;code class=&quot;language-text&quot;&gt;max-age&lt;/code&gt; 에 해당하는 숫자는 이 캐시가 유효한 초단위를 의미한다.&lt;/p&gt;
&lt;p&gt;즉 이 코끼리 그림은 로컬의 캐시 저장소에서 60초간 유효하며 이 시간안에 클라이언트가 코끼리 그림을 다시 요청하면 서버에서 다시 코끼리 그림 데이터를 다운받는 게 아니라 캐시 저장소에 있는 복사된 데이터를 브라우저에서 렌더링 하게 되는 것이다.&lt;/p&gt;
&lt;h3&gt;캐시 유효기간&lt;/h3&gt;
&lt;p&gt;당연히 캐시 유효기간이 지난 데이터의 경우 서버에 재요청을 하여 다시 다운로드 받아야 한다. 이 때 유효기간이 지난 캐시를 Stale하다라고 표현한다.    &lt;/p&gt;
&lt;p&gt;하지만 캐시 유효 기간이 지났지만 서버의 원본 데이터가 변경되지 않은 경우, 같은 데이터인데도 다시 다운로드 받아야 하면 이는 굉장히 비효율적이다. 이를 위해 캐시와 원본이 같은 데이터인지 검증하고, 같은 데이터라면 캐시를 사용하는 절차가 필요하다.&lt;/p&gt;
&lt;h2&gt;캐시 유효성검증(Validation)과 조건부 요청(Conditional Request)&lt;/h2&gt;
&lt;p&gt;캐시 데이터가 원본 데이터와 같은지 검증하기 위해 크게 두가지 방법을 사용한다&lt;/p&gt;
&lt;h3&gt;Last-Modified / If-Modified-Since&lt;/h3&gt;
&lt;p&gt;첫 번재 방법은 원본 데이터가 마지막으로 수정된 시간을 응답 메시지 헤더로 추가하는 방법이다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 200 OK
Content-Type:image/jpeg
Cache-Control: max-age=60
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added
Content-Length: 10295

//
{elephant image data}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 캐시 저장소에 코끼리 그림과 이 원본 데이터가 마지막으로 수정된 시각까지 저장을 하게 된다. 이제 클라이언트는 요청을 할때 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GET /elephant.jpg
if-modified-since: Wed, 21 Oct 2015 07:28:00 GMT&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&apos;이 이후로 원본이 수정되었으면&apos; 이라는  조건부 요청을 보내고 서버에서는 이러한 조건부 요청에 따라&lt;br&gt;
조건이 만족하면(수정 되었으면) 200 OK로 다시 10mb의 코끼리 그림을 전송하고 조건을 불만족하면(수정 되지 않았다면 )&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 304 Not Modified
Content-Type:image/jpeg
Cache-Control: max-age=60
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT //added
Content-Length: 10295

//

//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10mb의 message body가 생략된 304 Not Modified의 응답 메시지를 보낸다. &lt;/p&gt;
&lt;p&gt;위 방법은 합리적으로 보이지만 단점도 가지고 있다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1초 미만 단위로 캐시 조정이 불가능하고&lt;/li&gt;
&lt;li&gt;A-&gt;B-&gt;A 처럼 원본데이터가 수정되었지만 수정 전과 같은 데이터 일때&lt;/li&gt;
&lt;li&gt;스페이스, 주석 변경처럼 크게 영향이 없는 경우
에도 모두 재다운로드가 발생하기 때문이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;ETag / If-None-Match&lt;/h3&gt;
&lt;p&gt;위의 단점을 보완하고 캐시 로직을 서버에서 관리하고 싶을 때 ETag(Entity Tag)를 이용하게 된다 .
ETag는 각각의 캐시될 원본 데이터에 해쉬코드를 달아준다고 생각하면 된다. 데이터가 변경되고 이 데이터가 클라이언트에서 다시 다운로드 받아야 된다고 판단될 때 ETag를 변경해주면 된다. &lt;/p&gt;
&lt;p&gt;서버는 최초 응답 메시지에 코끼리 데이터와 함께 ETag를 제공한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/1.1 200 OK
Content-Type:image/jpeg
Cache-Control: max-age=60
ETag: &quot;aaaaaaa&quot; //added
Content-Length: 10295

//
{elephant image data}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;캐시 저장소는 이제 코끼리 그림 데이터를 ETag와 함께 저장하고 &lt;/p&gt;
&lt;p&gt;재요청시 조건부 요청을 보내게 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GET /elephant.jpg
if-none-match: &quot;aaaaaaa&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 마찬가지로 조건을 불만족하면(수정 되지 않았다면 ) 서버는 304 상태코드와 메시지 바디가 없는 응답 메시지를 보내고 클라이언트는 캐시 저장소에 있는 코끼리 그림을 웹 브라우저에 렌더링한다.&lt;/p&gt;
&lt;h2&gt;캐시 지시어&lt;/h2&gt;
&lt;p&gt;캐시를 제어하는 방법은 위의 방법만 있는 게 아니다. 항상 최신이 되어야 하는 데이터나 개인정보 처럼 캐시를 해서는 안되는 데이터도 있기 때문이다.&lt;/p&gt;
&lt;p&gt;Cache-directive(캐시 지시어)로 해당 데이터의 캐시가 어떻게 적용될지 설정할 수 있다. &lt;/p&gt;
&lt;h3&gt;Cache-Control: no-cache&lt;/h3&gt;
&lt;p&gt;데이터를 캐시해도 되지만 항상 Origin서버에 검증하고 사용되어야 하는 데이터다. 즉, 항상 최신의 데이터를 가지게 하고 싶을 때 사용한다&lt;/p&gt;
&lt;h3&gt;Cache-Control: no-store&lt;/h3&gt;
&lt;p&gt;민감한 정보가 포함된 데이터이므로 캐시해서는 안된다.&lt;/p&gt;
&lt;h3&gt;Cache-Control: must-revalidate&lt;/h3&gt;
&lt;p&gt;캐시 만료 후 최초조회시 Origin서버에 검증해야한다
Origin 서버 접근 실패시 반드시 오류가 발생해야한다.&lt;/p&gt;
&lt;h3&gt;Cache-Control: public&lt;/h3&gt;
&lt;p&gt;응답이 public 캐시에 저장되어도 된다 (프록시 서버에 저장되어도 된다)&lt;/p&gt;
&lt;h3&gt;Cache-Control: private&lt;/h3&gt;
&lt;p&gt;응답이 해당 사용자 만을 위한 것 private 캐시에 저장해야함(기본값)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로세스와 스레드]]></title><description><![CDATA['혼자 공부하는 시스템구조&운영체제'를 읽고 공부한 내용 프로세스 Process? Program? 우리는 흔히  라고 말한다.
이는 '보조기억장치에 있는 데이터 뭉치'인 을  '메모리에 적재하고 cpu가 실행'하여 화 한다와 같은 말이다.  PCB…]]></description><link>https://jinkshower.github.io/process_thread/</link><guid isPermaLink="false">https://jinkshower.github.io/process_thread/</guid><pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&apos;혼자 공부하는 시스템구조&amp;#x26;운영체제&apos;를 읽고 공부한 내용&lt;/p&gt;
&lt;h2&gt;프로세스&lt;/h2&gt;
&lt;h3&gt;Process? Program?&lt;/h3&gt;
&lt;p&gt;우리는 흔히 &lt;code class=&quot;language-text&quot;&gt;프로그램을 실행한다&lt;/code&gt; 라고 말한다.
이는 &apos;보조기억장치에 있는 데이터 뭉치&apos;인 &lt;code class=&quot;language-text&quot;&gt;프로그램&lt;/code&gt;을  &apos;메모리에 적재하고 cpu가 실행&apos;하여 &lt;code class=&quot;language-text&quot;&gt;프로세스&lt;/code&gt;화 한다와 같은 말이다. &lt;/p&gt;
&lt;h3&gt;PCB Process Control Block&lt;/h3&gt;
&lt;p&gt;모든 프로세스는 CPU를 사용해야 하지만 CPU의 자원은 한정적이다.
그래서 프로세스의 실행 순서와 자원관리를 위해 프로세스마다 &lt;code class=&quot;language-text&quot;&gt;PCB&lt;/code&gt;라는 부가 정보를 Kernel 영역에 프로세스과 함께 저장한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[PCB에 저장되는 정보]&lt;br&gt;
PID(Process ID) : 프로세스 고유의 번호
Registers: 레지스터의 중간값&lt;br&gt;
Process state: 대기,준비, 실행 등의 프로세스 상태&lt;br&gt;
CPU scheduling information : 언제, 어떤 순서로 cpu 할당 받을지의 정보&lt;br&gt;
Memory: 프로세스의 메모리 적재 주소, 베이스 레지스터, 한계 레지스터, 페이지 테이블&lt;br&gt;
List of Open files : 입출력장치 정보&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;이 PCB로 어떻게 관리하나?&lt;/h3&gt;
&lt;p&gt;CPU는 하나의 프로세스를 처음부터 끝까지 실행하고 다음 프로세스로 넘어가는 게 아니라 여러개의 프로세스를 일부씩 실행한다. &lt;/p&gt;
&lt;p&gt;이 때 한 프로세스의 작업을 멈추고 그 작업까지의 중간 값(프로그램 카운터, 각종 레지스터 값 등)을 필수적으로 저장해야 하는데 이것을 PCB에 저장하는 것이다. &lt;/p&gt;
&lt;p&gt;이 중간 정보는 &lt;code class=&quot;language-text&quot;&gt;문맥Context&lt;/code&gt;으로 추상화하여 표현되고 기존 프로세스의 문맥을 백업하고 다음 프로세스의 문맥을 읽어서 실행하는 것을 &lt;code class=&quot;language-text&quot;&gt;문맥 교환 Context Switching&lt;/code&gt; 이라고 한다.
(이 문맥 교환의 속도가 빨라지면 프로세스들은 동시에 실행되는 것처럼 보인다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[동시에 실행되는 것 &apos;처럼&apos; 보인다]&lt;br&gt;
프로세스간의 문맥교환으로 동시에 실행되는 것처럼 보인다는 것은 동시성(Concurrency)를 의미한다.&lt;br&gt;
정말 동시에 실행되는 것은  CPU의 다수 코어에 의한 병렬성(Parallelism)을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;프로세스의 구성&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 할당 영역&lt;/code&gt;&lt;br&gt;
코드 영역Code Segment : 기계어로 이루어진 명령어. Read-Only&lt;/p&gt;
&lt;p&gt;데이터 영역 Data Segment : 프로그램 실행 동안 유지되는 데이터
ex) 전역변수, 상수&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;동적 할당 영역&lt;/code&gt;&lt;br&gt;
힙 영역 Heap Segment : 프로그래머가 직접 할당할 수 있는 저장 공간
ex)생성자, 인스턴스 (C에서 malloc()과 free()로 관리하는 영역) &lt;/p&gt;
&lt;p&gt;스택 영역 Stack Segment : 함수의 호출에 의해 할당되고 함수 종료시 소멸하는 데이터
ex)매개변수, 지역변수 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;즉, PCB가 있는 커널영역과 사용자 영역을 구성하는 위 네가지 영역으로 프로세스가 구성된다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;프로세스의 상태&lt;/h2&gt;
&lt;p&gt;프로세스는 번갈아 실행되는 과정에서 여러 상태를 거치는데, 이 상태를 cpu는 알아야 한다.
입출력장치를 사용하는 프로세스의 경우 입력 완료 인터럽트를 기다려야 실행할 수 있는 경우가 있고, 실행이 끝난 프로세스는 메모리를 반환해야 하기 때문이다.
그래서 운영체제는 PCB에 프로세스의 상태를 저장하고 이를 읽어낸다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생성 상태(new)&lt;/li&gt;
&lt;li&gt;준비 상태(ready)&lt;/li&gt;
&lt;li&gt;대기상태(blocked) &lt;/li&gt;
&lt;li&gt;실행상태(running)&lt;/li&gt;
&lt;li&gt;종료상태(terminated)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;준비상태 vs 대기상태&lt;/code&gt;&lt;br&gt;
준비상태는 cpu에서 메모리를 할당받으면 실행할 수 있는 상태를 의미한다.
준비상태에서 실행상태가 되는 것을 &lt;strong&gt;dispatch&lt;/strong&gt;라고 한다 &lt;/p&gt;
&lt;p&gt;대기상태는 입출력 장치의 완료 신호(인터럽트)를 기다리는 등 특정 이벤트의 발생을 기다리는 상태를 의미한다. 대기상태에서 이벤트가 완료되면 &lt;strong&gt;준비상태&lt;/strong&gt;가 된다. &lt;/p&gt;
&lt;h2&gt;스레드&lt;/h2&gt;
&lt;h3&gt;프로세스와 스레드&lt;/h3&gt;
&lt;p&gt;스레드는 &lt;code class=&quot;language-text&quot;&gt;프로세스를 구성하는 실행 단위&lt;/code&gt;를 의미한다
스레드는 &lt;strong&gt;프로세스의 자원&lt;/strong&gt;을 공유하며 여러개가 존재 할 수 있다.
스레드들은 위에서 살펴 본 프로세스의 스택 영역에 존재하며 프로세스의 코드,데이터, 힙영역을 다른 스레드들과 공유할 수 있다. &lt;/p&gt;
&lt;h3&gt;멀티스레드&lt;/h3&gt;
&lt;p&gt;멀티프로세스와 비슷하게 스레드 또한 문맥교환을 하며 동시성을 가지고 처리된다. &lt;/p&gt;
&lt;p&gt;멀티스레드는 한 프로세스 내에서 필요한 자원을 공유하기 때문에 새로운 프로세스를 실행하는 것보다 효율적으로 메모리를 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 자원을 공유한다는 것은 한 스레드의 오류가 다른 스레드에 영향을 미칠 수 있음을 의미한다&lt;/p&gt;
&lt;h3&gt;프로세스와 스레드의 동기화 문제&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; max &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; maxCount&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
                count&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
                &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 얼핏 보면 문제가 없어보이지만 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;1
3
4
2
5
6&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;실행결과는 뒤죽박죽인채로 나온다.&lt;br&gt;
이렇게 같은 전역변수에 스레드가 무분별한 순서로 접근하거나, 정해진 순서대로 실행되어야 할 스레드가 순서대로 실행되지 않는 때 이 멀티 스레드는 &apos;&lt;code class=&quot;language-text&quot;&gt;Synchronization Issue&lt;/code&gt;를 가진다&apos;라고 한다.&lt;/p&gt;
&lt;h3&gt;프로세스 동기화 문제? 스레드 동기화 문제?&lt;/h3&gt;
&lt;p&gt;둘 다 동기화 문제를 가질 수 있다.&lt;br&gt;
위 예시에서는 스레드의 동기화를 사용했지만 &lt;code class=&quot;language-text&quot;&gt;실행의 흐름&lt;/code&gt;을 가지는 모든 것들이 동기화 문제를 내재하고 있다.   &lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code class=&quot;language-text&quot;&gt;Book.txt&lt;/code&gt;를 쓰는 프로세스 A와 같은 파일을 읽는 프로세스 B가 있다면 두 프로세스가 공유자원에 접근할 수 있다는 것이고 &lt;code class=&quot;language-text&quot;&gt;A-&gt;B&lt;/code&gt;의 정해진 순서대로 실행되어야 하기 때문이다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby와 Github Pages로 개인 블로그 만들기]]></title><description><![CDATA[Gatsby로 Github pages 개인 블로그 만들기 TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG…]]></description><link>https://jinkshower.github.io/gatsby_website/</link><guid isPermaLink="false">https://jinkshower.github.io/gatsby_website/</guid><pubDate>Tue, 26 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Gatsby로 Github pages 개인 블로그 만들기&lt;/h2&gt;
&lt;p&gt;TIL을 적는 블로그와 기술블로그를 분리하고 싶어서 따로 웹사이트 만들 방법을 찾다가 github pages과 연동하여 손쉽게 웹사이트를 만들 수 있는 SSG 프레임워크를 찾게 되었다. 여러가지가 있지만 가장 많이 쓰이는 것들은 &lt;code class=&quot;language-text&quot;&gt;Jekyll&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt; 이다. &lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;Jekyll&lt;/code&gt;로 웹사이트를 만들었지만 몇 가지 고치고 싶은 사항들이 보였는데 나는 Ruby를 잘 모르기 때문에 내가 나중에 커스텀하기에 조금 무리가 있는 것 같아 &lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt;로 프레임워크를 바꾸게 되었다.&lt;/p&gt;
&lt;p&gt;나는 미리 만들어진 &lt;a href=&quot;https://github.com/devHudi/gatsby-starter-hoodie&quot;&gt;테마&lt;/a&gt; 를 사용했다.(감사합니다)&lt;/p&gt;
&lt;h2&gt;Gatsby 설치 와 웹사이트 설정&lt;/h2&gt;
&lt;p&gt;Gatsby cli를 설치해준다 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install -g gatsby-cli&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Gatsby Starter Library&lt;/code&gt;에서 마음에 드는 테마를 선택할 수 있다.
원하는 테마를 고른 뒤&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npx gatsby new {local-folder-name} {theme-name}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행해 로컬에 Gatsby 템플레이트를  만든다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;cd {local-folder-name}
gatsby develop&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;을 실행하면 로컬에서 개츠비 서버가 구동된다. 서버 주소는 &lt;code class=&quot;language-text&quot;&gt;http://localhost:8000&lt;/code&gt;이다. &lt;/p&gt;
&lt;h2&gt;Github Repository연결&lt;/h2&gt;
&lt;p&gt;Github의 새 리포지토리를 생성한다.
나는 &lt;code class=&quot;language-text&quot;&gt;{username}.github.io&lt;/code&gt;로 이름을 지정했다.
다른 이름을 쓰거나 소스코드용 리포지토리를 따로 두고 싶다면
&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;Gatsby 공식문서&lt;/a&gt; 를 참고하길 바란다&lt;/p&gt;
&lt;p&gt;리포지토리를 생성했다면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git remote add origin {github-https-address}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행해 본인이 만든 웹사이트 폴더와 원격 저장소를 연결해준다.&lt;/p&gt;
&lt;p&gt;그리고 커스텀 블로그 설정, 포스트 작성등을 한 후 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git add .
git commit -m &quot;{commit-name}&quot;
git push origin main&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위를 실행하여 원격 저장소에 로컬의 변경사항을 푸쉬해준다.&lt;/p&gt;
&lt;h2&gt;배포 방법 정하기&lt;/h2&gt;
&lt;p&gt;배포 방법에는 여러가지가 있지만 대표적인 2가지만 설명한다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Netlify
Github과 유연하게 연동 되고 무료인 Netlify의 배포 시스템을 이용할 수 있다.
&lt;a href=&quot;https://www.netlify.com/blog/2016/02/24/a-step-by-step-guide-gatsby-on-netlify/&quot;&gt;A Step-by-Step Guide: Gatsby on Netlify&lt;/a&gt; 공식문서&lt;/li&gt;
&lt;li&gt;Github pages
Github pages에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;를 이용하여 배포할 수 있다
&lt;a href=&quot;https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/&quot;&gt;How Gatsby Works with GitHub Pages&lt;/a&gt;공식 문서&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;나는 Github pages를 이용했는데 Netlify는 커스텀 도메인이 없으면 &lt;code class=&quot;language-text&quot;&gt;{smt}.netflify.app&lt;/code&gt;를 도메인으로 제공해주는데 이 도메인보다 Github pages가 제공하는 &lt;code class=&quot;language-text&quot;&gt;{smt}.github.io&lt;/code&gt; 도메인이 마음에 들어서다(...)&lt;/p&gt;
&lt;h2&gt;Github Pages로 배포하기&lt;/h2&gt;
&lt;p&gt;배포용 브랜치 설정
gh-pages는 배포용 브랜치가 따로 있어야 한다.&lt;br&gt;
우리가 만든 gatsby 프로젝트의 main 브랜치에서 블로깅 작업을 했다면 public 폴더에 index.html이 있을텐데 기본적으로는 &lt;code class=&quot;language-text&quot;&gt;.gitignore&lt;/code&gt;에서 public을 푸쉬하지 않게 설정되어 있다.&lt;/p&gt;
&lt;p&gt;현 상태에서 배포용 브랜치를 하나 만들어 둔다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git branch deploy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 배포용 브랜치에 public 폴더를 따로 업로드하는 작업을 gh-pages가 해준다.
&lt;code class=&quot;language-text&quot;&gt;gh-pages&lt;/code&gt;패키지를 설치하자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm install gh-pages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[Trouble Shooting]&lt;br&gt;
나는 npm install 과중에서 dependency conflict가 발생했다.&lt;br&gt;
node 7 버전 이후 부터는 peer dependency를 자동으로 설치하기 때문에 이미 있는 dependency와 버전이 다를 경우 충돌이 발생한다고 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;-&gt; 위의 install 커맨드에 &lt;code class=&quot;language-text&quot;&gt;--force&lt;/code&gt; 를 추가해서 충돌이 일어난 peer dependency를 강제 설치하거나 &lt;code class=&quot;language-text&quot;&gt;--legacy-peer-deps&lt;/code&gt;로 자동설치를 막는 방법이 있다. 나는 &lt;code class=&quot;language-text&quot;&gt;--force&lt;/code&gt;로 설치했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다음은 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 에 배포에 사용할 스크립트를 추가해주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&quot;scripts&quot;: {
    &quot;deploy&quot;: &quot;gatsby build &amp;amp;&amp;amp; gh-pages -d public -b deploy&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;npm run deploy &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행한다.   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[Trouble Shooting]&lt;br&gt;
위 커맨드를 실행했을 때 Segmentation Fault오류가 발생했는데 잘못된 메모리 접근이라는 오류였기 때문에 &lt;code class=&quot;language-text&quot;&gt;npm run clean&lt;/code&gt;으로 캐쉬를 삭제 한후 다시 위 커맨드를 실행해주었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이후
Github repository의 Settings-Pages
&lt;code class=&quot;language-text&quot;&gt;Build and deployment&lt;/code&gt;에서 배포용 브랜치로 전환해준다.&lt;/p&gt;
&lt;p&gt;이렇게 까지 하면 &lt;code class=&quot;language-text&quot;&gt;Actions&lt;/code&gt;에서 웹사이트를 배포해주고 브라우저에서&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;https://{user-name}.github.io/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 주소로 접속이 가능해진다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[정적 팩토리 메서드, 언제 쓸까?]]></title><description><![CDATA[정적 팩토리 메서드란? Java…]]></description><link>https://jinkshower.github.io/staticfactorymethod/</link><guid isPermaLink="false">https://jinkshower.github.io/staticfactorymethod/</guid><pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;정적 팩토리 메서드란?&lt;/h2&gt;
&lt;p&gt;Java에서는 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;  연산자를 이용하여 클래스의 인스턴스를 생성하는 것 외에 &lt;code class=&quot;language-text&quot;&gt;static&lt;/code&gt; 메서드를 사용하여 인스턴스를 반환 받는 기법이 있다.&lt;/p&gt;
&lt;p&gt;간단한 예시로 사용방법을 알아 보자. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;   
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;Car&lt;/code&gt; 클래스는 두개의 변수를 받는 생성자를 가지고 있다.  여기에&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 팩토리 메서드&lt;/code&gt; 를 추가함으로써 인스턴스를 반환 받는 다른 &lt;code class=&quot;language-text&quot;&gt;통로&lt;/code&gt; 를  생성하는 기법이라고 할 수 있다. &lt;/p&gt;
&lt;h2&gt;정적팩토리 메서드, 왜 쓰나?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Effective Java&lt;/code&gt;는 1장에서 &lt;code class=&quot;language-text&quot;&gt;생성자 대신 정적 팩토리 메서드를 고려하라&lt;/code&gt; 라고 말한다. 그리고 그에 대한 장점과 단점에 대해 설명하는데 이와 관련된 잘 정리된 글이 많이 있으므로 &lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2020-05-26-static-factory-method/&quot;&gt;링크&lt;/a&gt;&lt;br&gt;
이 포스트에서는 내가  &lt;strong&gt;개인적으로&lt;/strong&gt; 언제 이 기법을 사용하는지 서술해 보려고 한다.&lt;/p&gt;
&lt;h3&gt;이름이 있는 것이 나은 경우&lt;/h3&gt;
&lt;p&gt;위의 예시는 없다치고 사용자가 입력한 텍스트로  Car 객체를 생성한다고 가정해보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createCar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; car1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; car2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;input&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 두 줄의 코드는 같은 기능을 하지만 이 코드를 읽는 사람에게는 다른 의미로 해석되곤 한다.
&lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt; 연산자는 &lt;code class=&quot;language-text&quot;&gt;이 Car는 input을 멤버 변수로 가지는군&lt;/code&gt; 이라면
&lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;이 input은 객체 내에서 특정한 로직으로 변환되겠군&lt;/code&gt; 이라는 멘탈 모델을 제공한다. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;이름을 가질 수 있다&lt;/code&gt; 는 것이 정적 팩토리 메서드의 가장 큰 장점인 만큼 이름이 있는 것이 나은 경우에 해당 기법을 쓴다.&lt;/p&gt;
&lt;h3&gt;한 가지 방법으로만 객체가 생성되게 하고 싶을 때&lt;/h3&gt;
&lt;p&gt;우리는 다른 프로그래머 혹은 미래의 나 자신이 실수로라도 User 클래스를 적합하지 않은 id로 생성하는 것을 막고 싶다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isInvalidId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서 이 때는 &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; 으로 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;연산자의 객체 생성을 막고, 정적 팩토리 메서드가 아니면 이 객체를 인스턴스화 할 수 없게 만들수 있다.
이는 &lt;code class=&quot;language-text&quot;&gt;싱글톤패턴&lt;/code&gt; 의 사용과도 일맥상통한다&lt;/p&gt;
&lt;h3&gt;같은 객체가 여러번 쓰여야할 때&lt;/h3&gt;
&lt;p&gt;같은 객체가 여러번 조회, 캐싱되는 경우에 쓰인다. 한번 만들어 놓고 계속 사용하거나 미리 캐싱된 객체가 없는 경우에&lt;em&gt;만&lt;/em&gt;  객체를 생성해 메모리를 아낄 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarFactory&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
	  &lt;span class=&quot;token comment&quot;&gt;//if cache doesn&apos;t contains key, only then instantiate new car&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[정리]&lt;br&gt;
1.생성자의 파라미터에 들어가는 값이 그대로 객체의 상태가 되지 않는 경우&lt;br&gt;
2.지정된 경우 이외의 객체 생성을 막고 싶은 경우&lt;br&gt;
3.여러번 쓰이는 같은 객체에 불필요한 메모리를 할당하고 싶지 않은 경우 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이외에도 여러가지 경우가 있지만 나 같은 경우 위의 세가지의 경우에 정적 팩토리 메서드의 필요성을 느끼고 사용하고 있다.&lt;/p&gt;
&lt;h2&gt;private으로 생성자 막기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Effective Java&lt;/code&gt; 는 private으로 생성자를 제한하고 정적 팩토리 메서드만을 두는 것은 단점이자 장점이라 서술한다. private으로 생성자를 막으면 하위 클래스를 만들 수 없기 때문에 &lt;code class=&quot;language-text&quot;&gt;Composition&lt;/code&gt;을 자연스럽게 지향하게 되고, 객체의 불변성에 기여할 수 있기 때문이라고 한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Car&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;coins &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
  
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;token comment&quot;&gt;//Complicated Logic..   &lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;//..  &lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CarSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 public 생성자와 정적 팩토리 메서드를 같이 가지는 객체도 장점이 있다고 생각한다
text를 검증과 파싱으로 만드는 정적 팩토리 메서드를 따로 두고 이미 만들어진 map으로도 해당 객체가생성되게 하면 이 객체의 &lt;code class=&quot;language-text&quot;&gt;재사용성&lt;/code&gt; 이 늘어날 수 있기 때문이다.&lt;/p&gt;</content:encoded></item></channel></rss>